import { URI } from "@codingame/monaco-vscode-api/vscode/vs/base/common/uri";
import { Event } from "@codingame/monaco-vscode-api/vscode/vs/base/common/event";
import { CancellationToken } from "@codingame/monaco-vscode-api/vscode/vs/base/common/cancellation";
import { IFileReadLimits, IFileStatWithMetadata, IWriteFileOptions } from "@codingame/monaco-vscode-api/vscode/vs/platform/files/common/files";
import { IFileService } from "@codingame/monaco-vscode-api/vscode/vs/platform/files/common/files.service";
import { ISaveOptions, IRevertOptions } from "@codingame/monaco-vscode-api/vscode/vs/workbench/common/editor";
import { IWorkingCopyService } from "@codingame/monaco-vscode-api/vscode/vs/workbench/services/workingCopy/common/workingCopyService.service";
import { IWorkingCopyBackup, IWorkingCopySaveEvent, WorkingCopyCapabilities } from "@codingame/monaco-vscode-86d65fc6-30f9-5dca-9501-e249de688591-common/vscode/vs/workbench/services/workingCopy/common/workingCopy";
import { ILogService } from "@codingame/monaco-vscode-api/vscode/vs/platform/log/common/log.service";
import { IWorkingCopyFileService } from "@codingame/monaco-vscode-api/vscode/vs/workbench/services/workingCopy/common/workingCopyFileService.service";
import { VSBufferReadableStream } from "@codingame/monaco-vscode-api/vscode/vs/base/common/buffer";
import { IFilesConfigurationService } from "@codingame/monaco-vscode-api/vscode/vs/workbench/services/filesConfiguration/common/filesConfigurationService.service";
import { IWorkingCopyBackupService } from "@codingame/monaco-vscode-api/vscode/vs/workbench/services/workingCopy/common/workingCopyBackup.service";
import { INotificationService } from "@codingame/monaco-vscode-api/vscode/vs/platform/notification/common/notification.service";
import { IWorkingCopyEditorService } from "@codingame/monaco-vscode-api/vscode/vs/workbench/services/workingCopy/common/workingCopyEditorService.service";
import { IEditorService } from "@codingame/monaco-vscode-api/vscode/vs/workbench/services/editor/common/editorService.service";
import { IElevatedFileService } from "@codingame/monaco-vscode-api/vscode/vs/workbench/services/files/common/elevatedFileService.service";
import { IResourceWorkingCopy, ResourceWorkingCopy } from "./resourceWorkingCopy.js";
import { IFileWorkingCopy, IFileWorkingCopyModel, IFileWorkingCopyModelFactory } from "./fileWorkingCopy.js";
import { IMarkdownString } from "@codingame/monaco-vscode-api/vscode/vs/base/common/htmlContent";
import { IProgressService } from "@codingame/monaco-vscode-api/vscode/vs/platform/progress/common/progress.service";
export interface IStoredFileWorkingCopyModelFactory<M extends IStoredFileWorkingCopyModel> extends IFileWorkingCopyModelFactory<M> {
}
export interface IStoredFileWorkingCopyModel extends IFileWorkingCopyModel {
    readonly onDidChangeContent: Event<IStoredFileWorkingCopyModelContentChangedEvent>;
    readonly versionId: unknown;
    pushStackElement(): void;
    save?(options: IWriteFileOptions, token: CancellationToken): Promise<IFileStatWithMetadata>;
}
export interface IStoredFileWorkingCopyModelContentChangedEvent {
    readonly isUndoing: boolean;
    readonly isRedoing: boolean;
}
export interface IStoredFileWorkingCopy<M extends IStoredFileWorkingCopyModel> extends IResourceWorkingCopy, IFileWorkingCopy<M> {
    readonly onDidResolve: Event<void>;
    readonly onDidSave: Event<IStoredFileWorkingCopySaveEvent>;
    readonly onDidSaveError: Event<void>;
    readonly onDidChangeReadonly: Event<void>;
    resolve(options?: IStoredFileWorkingCopyResolveOptions): Promise<void>;
    markModified(): void;
    hasState(state: StoredFileWorkingCopyState): boolean;
    joinState(state: StoredFileWorkingCopyState.PENDING_SAVE): Promise<void>;
    isResolved(): this is IResolvedStoredFileWorkingCopy<M>;
    isReadonly(): boolean | IMarkdownString;
    save(options?: IStoredFileWorkingCopySaveAsOptions): Promise<boolean>;
}
export interface IResolvedStoredFileWorkingCopy<M extends IStoredFileWorkingCopyModel> extends IStoredFileWorkingCopy<M> {
    readonly model: M;
}
export declare enum StoredFileWorkingCopyState {
    SAVED = 0,
    DIRTY = 1,
    PENDING_SAVE = 2,
    CONFLICT = 3,
    ORPHAN = 4,
    ERROR = 5
}
export interface IStoredFileWorkingCopySaveOptions extends ISaveOptions {
    readonly writeUnlock?: boolean;
    readonly writeElevated?: boolean;
    readonly ignoreModifiedSince?: boolean;
    readonly ignoreErrorHandler?: boolean;
}
export interface IStoredFileWorkingCopySaveAsOptions extends IStoredFileWorkingCopySaveOptions {
    readonly from?: URI;
}
export interface IStoredFileWorkingCopyResolver {
    (options?: IStoredFileWorkingCopyResolveOptions): Promise<void>;
}
export interface IStoredFileWorkingCopyResolveOptions {
    readonly contents?: VSBufferReadableStream;
    readonly forceReadFromFile?: boolean;
    readonly limits?: IFileReadLimits;
}
export interface IStoredFileWorkingCopySaveEvent extends IWorkingCopySaveEvent {
    readonly stat: IFileStatWithMetadata;
}
export declare function isStoredFileWorkingCopySaveEvent(e: IWorkingCopySaveEvent): e is IStoredFileWorkingCopySaveEvent;
export declare class StoredFileWorkingCopy<M extends IStoredFileWorkingCopyModel> extends ResourceWorkingCopy implements IStoredFileWorkingCopy<M> {
    readonly typeId: string;
    readonly name: string;
    private readonly modelFactory;
    private readonly externalResolver;
    private readonly logService;
    private readonly workingCopyFileService;
    private readonly filesConfigurationService;
    private readonly workingCopyBackupService;
    private readonly notificationService;
    private readonly workingCopyEditorService;
    private readonly editorService;
    private readonly elevatedFileService;
    private readonly progressService;
    readonly capabilities: WorkingCopyCapabilities;
    private _model;
    get model(): M | undefined;
    private readonly _onDidChangeContent;
    readonly onDidChangeContent: Event<void>;
    private readonly _onDidResolve;
    readonly onDidResolve: Event<void>;
    private readonly _onDidChangeDirty;
    readonly onDidChangeDirty: Event<void>;
    private readonly _onDidSaveError;
    readonly onDidSaveError: Event<void>;
    private readonly _onDidSave;
    readonly onDidSave: Event<IStoredFileWorkingCopySaveEvent>;
    private readonly _onDidRevert;
    readonly onDidRevert: Event<void>;
    private readonly _onDidChangeReadonly;
    readonly onDidChangeReadonly: Event<void>;
    constructor(typeId: string, resource: URI, name: string, modelFactory: IStoredFileWorkingCopyModelFactory<M>, externalResolver: IStoredFileWorkingCopyResolver, fileService: IFileService, logService: ILogService, workingCopyFileService: IWorkingCopyFileService, filesConfigurationService: IFilesConfigurationService, workingCopyBackupService: IWorkingCopyBackupService, workingCopyService: IWorkingCopyService, notificationService: INotificationService, workingCopyEditorService: IWorkingCopyEditorService, editorService: IEditorService, elevatedFileService: IElevatedFileService, progressService: IProgressService);
    private registerListeners;
    private dirty;
    private savedVersionId;
    isDirty(): this is IResolvedStoredFileWorkingCopy<M>;
    markModified(): void;
    private setDirty;
    private doSetDirty;
    lastResolvedFileStat: IFileStatWithMetadata | undefined;
    isResolved(): this is IResolvedStoredFileWorkingCopy<M>;
    resolve(options?: IStoredFileWorkingCopyResolveOptions): Promise<void>;
    private doResolve;
    private resolveFromBuffer;
    private resolveFromBackup;
    private doResolveFromBackup;
    private resolveFromFile;
    private resolveFromContent;
    private doCreateModel;
    private ignoreDirtyOnModelContentChange;
    private doUpdateModel;
    private installModelListeners;
    private onModelContentChanged;
    private forceResolveFromFile;
    get backupDelay(): number | undefined;
    backup(token: CancellationToken): Promise<IWorkingCopyBackup>;
    private versionId;
    private static readonly UNDO_REDO_SAVE_PARTICIPANTS_AUTO_SAVE_THROTTLE_THRESHOLD;
    private lastContentChangeFromUndoRedo;
    private readonly saveSequentializer;
    private ignoreSaveFromSaveParticipants;
    save(options?: IStoredFileWorkingCopySaveAsOptions): Promise<boolean>;
    private doSave;
    private doSaveSequential;
    private handleSaveSuccess;
    private handleSaveError;
    private doHandleSaveError;
    private updateLastResolvedFileStat;
    revert(options?: IRevertOptions): Promise<void>;
    private inConflictMode;
    private inErrorMode;
    hasState(state: StoredFileWorkingCopyState): boolean;
    joinState(state: StoredFileWorkingCopyState.PENDING_SAVE): Promise<void>;
    isReadonly(): boolean | IMarkdownString;
    private trace;
    dispose(): void;
}
