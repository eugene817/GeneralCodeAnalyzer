
import { __decorate, __param } from '@codingame/monaco-vscode-api/external/tslib/tslib.es6';
import { Emitter, Event } from '@codingame/monaco-vscode-api/vscode/vs/base/common/event';
import { DisposableStore, toDisposable, MutableDisposable } from '@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle';
import { Schemas } from '@codingame/monaco-vscode-api/vscode/vs/base/common/network';
import { generateUuid } from '@codingame/monaco-vscode-api/vscode/vs/base/common/uuid';
import { isCodeEditor, isDiffEditor, isCompositeEditor } from '@codingame/monaco-vscode-api/vscode/vs/editor/browser/editorBrowser';
import { Range } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/core/range';
import { createTextBufferFactoryFromSnapshot } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/model/textModel';
import { IEditorWorkerService } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/services/editorWorker.service';
import { IModelService } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/services/model.service';
import { ITextModelService } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/services/resolverService.service';
import { IContextKeyService } from '@codingame/monaco-vscode-api/vscode/vs/platform/contextkey/common/contextkey.service';
import { IInstantiationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/instantiation/common/instantiation';
import { ILogService } from '@codingame/monaco-vscode-api/vscode/vs/platform/log/common/log.service';
import { ITelemetryService } from '@codingame/monaco-vscode-api/vscode/vs/platform/telemetry/common/telemetry.service';
import { DEFAULT_EDITOR_ASSOCIATION } from '@codingame/monaco-vscode-api/vscode/vs/workbench/common/editor';
import { ChatAgentLocation } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatAgents';
import { IChatAgentService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatAgents.service';
import { IChatService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatService.service';
import { CTX_INLINE_CHAT_HAS_AGENT, CTX_INLINE_CHAT_HAS_AGENT2, CTX_INLINE_CHAT_POSSIBLE } from '@codingame/monaco-vscode-9a6d8b6c-ad4c-5ea3-9558-f43d6dc4c0ad-common/vscode/vs/workbench/contrib/inlineChat/common/inlineChat';
import { IEditorService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/editor/common/editorService.service';
import { UntitledTextEditorInput } from '@codingame/monaco-vscode-c4e2825a-b5b1-5f0e-b547-068c32e06d50-common/vscode/vs/workbench/services/untitled/common/untitledTextEditorInput';
import { Session, SessionWholeRange, HunkData, StashedSession } from './inlineChatSession.js';
import { isEqual } from '@codingame/monaco-vscode-api/vscode/vs/base/common/resources';
import { ILanguageService } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/languages/language.service';
import { ITextFileService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/textfile/common/textfiles.service';
import { WorkingSetEntryState } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatEditingService';
import { IChatEditingService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatEditingService.service';
import { assertType } from '@codingame/monaco-vscode-api/vscode/vs/base/common/types';
import '@codingame/monaco-vscode-api/vscode/vs/base/common/observableInternal/index';
import { ResourceMap } from '@codingame/monaco-vscode-api/vscode/vs/base/common/map';
import { autorun } from '@codingame/monaco-vscode-api/vscode/vs/base/common/observableInternal/autorun';

class InlineChatError extends Error {
    static { this.code = 'InlineChatError'; }
    constructor(message) {
        super(message);
        this.name = InlineChatError.code;
    }
}
let InlineChatSessionServiceImpl = class InlineChatSessionServiceImpl {
    constructor(_telemetryService, _modelService, _textModelService, _editorWorkerService, _logService, _instaService, _editorService, _textFileService, _languageService, _chatService, _chatAgentService, _chatEditingService) {
        this._telemetryService = _telemetryService;
        this._modelService = _modelService;
        this._textModelService = _textModelService;
        this._editorWorkerService = _editorWorkerService;
        this._logService = _logService;
        this._instaService = _instaService;
        this._editorService = _editorService;
        this._textFileService = _textFileService;
        this._languageService = _languageService;
        this._chatService = _chatService;
        this._chatAgentService = _chatAgentService;
        this._chatEditingService = _chatEditingService;
        this._store = ( new DisposableStore());
        this._onWillStartSession = this._store.add(( new Emitter()));
        this.onWillStartSession = this._onWillStartSession.event;
        this._onDidMoveSession = this._store.add(( new Emitter()));
        this.onDidMoveSession = this._onDidMoveSession.event;
        this._onDidEndSession = this._store.add(( new Emitter()));
        this.onDidEndSession = this._onDidEndSession.event;
        this._onDidStashSession = this._store.add(( new Emitter()));
        this.onDidStashSession = this._onDidStashSession.event;
        this._sessions = ( new Map());
        this._keyComputers = ( new Map());
        this._sessions2 = ( new ResourceMap());
        this._onDidChangeSessions = this._store.add(( new Emitter()));
        this.onDidChangeSessions = this._onDidChangeSessions.event;
    }
    dispose() {
        this._store.dispose();
        this._sessions.forEach(x => x.store.dispose());
        this._sessions.clear();
    }
    async createSession(editor, options, token) {
        const agent = this._chatAgentService.getDefaultAgent(ChatAgentLocation.Editor);
        if (!agent) {
            this._logService.trace('[IE] NO agent found');
            return undefined;
        }
        this._onWillStartSession.fire(editor);
        const textModel = editor.getModel();
        const selection = editor.getSelection();
        const store = ( new DisposableStore());
        this._logService.trace(`[IE] creating NEW session for ${editor.getId()}, ${agent.extensionId}`);
        const chatModel = options.session?.chatModel ?? this._chatService.startSession(ChatAgentLocation.Editor, token);
        if (!chatModel) {
            this._logService.trace('[IE] NO chatModel found');
            return undefined;
        }
        store.add(toDisposable(() => {
            const doesOtherSessionUseChatModel = ( [...( this._sessions.values())].some(data => data.session !== session && data.session.chatModel === chatModel));
            if (!doesOtherSessionUseChatModel) {
                this._chatService.clearSession(chatModel.sessionId);
                chatModel.dispose();
            }
        }));
        const lastResponseListener = store.add(( new MutableDisposable()));
        store.add(chatModel.onDidChange(e => {
            if (e.kind !== 'addRequest' || !e.request.response) {
                return;
            }
            const { response } = e.request;
            session.markModelVersion(e.request);
            lastResponseListener.value = response.onDidChange(() => {
                if (!response.isComplete) {
                    return;
                }
                lastResponseListener.clear();
                for (const part of response.response.value) {
                    if (part.kind !== 'textEditGroup' || part.uri.scheme !== Schemas.untitled || isEqual(part.uri, session.textModelN.uri)) {
                        continue;
                    }
                    const langSelection = this._languageService.createByFilepathOrFirstLine(part.uri, undefined);
                    const untitledTextModel = this._textFileService.untitled.create({
                        associatedResource: part.uri,
                        languageId: langSelection.languageId
                    });
                    untitledTextModel.resolve();
                    this._textModelService.createModelReference(part.uri).then(ref => {
                        store.add(ref);
                    });
                }
            });
        }));
        store.add(this._chatAgentService.onDidChangeAgents(e => {
            if (e === undefined && (!this._chatAgentService.getAgent(agent.id) || !this._chatAgentService.getActivatedAgents().includes(agent))) {
                this._logService.trace(`[IE] provider GONE for ${editor.getId()}, ${agent.extensionId}`);
                this._releaseSession(session, true);
            }
        }));
        const id = generateUuid();
        const targetUri = textModel.uri;
        store.add((await this._textModelService.createModelReference(textModel.uri)));
        const textModelN = textModel;
        const textModel0 = store.add(this._modelService.createModel(createTextBufferFactoryFromSnapshot(textModel.createSnapshot()), { languageId: textModel.getLanguageId(), onDidChange: Event.None }, targetUri.with({ scheme: Schemas.vscode, authority: 'inline-chat', path: '', query: ( ( new URLSearchParams({ id, 'textModel0': '' })).toString()) }), true));
        if (targetUri.scheme === Schemas.untitled) {
            store.add(this._editorService.onDidCloseEditor(() => {
                if (!this._editorService.isOpened({ resource: targetUri, typeId: UntitledTextEditorInput.ID, editorId: DEFAULT_EDITOR_ASSOCIATION.id })) {
                    this._releaseSession(session, true);
                }
            }));
        }
        let wholeRange = options.wholeRange;
        if (!wholeRange) {
            wholeRange = ( new Range(
                selection.selectionStartLineNumber,
                selection.selectionStartColumn,
                selection.positionLineNumber,
                selection.positionColumn
            ));
        }
        if (token.isCancellationRequested) {
            store.dispose();
            return undefined;
        }
        const session = ( new Session(
            options.headless ?? false,
            targetUri,
            textModel0,
            textModelN,
            agent,
            store.add(( new SessionWholeRange(textModelN, wholeRange))),
            store.add(( new HunkData(this._editorWorkerService, textModel0, textModelN))),
            chatModel,
            options.session?.versionsByRequest
        ));
        const key = this._key(editor, session.targetUri);
        if (( this._sessions.has(key))) {
            store.dispose();
            throw ( new Error(`Session already stored for ${key}`));
        }
        this._sessions.set(key, { session, editor, store });
        return session;
    }
    moveSession(session, target) {
        const newKey = this._key(target, session.targetUri);
        const existing = this._sessions.get(newKey);
        if (existing) {
            if (existing.session !== session) {
                throw ( new Error(`Cannot move session because the target editor already/still has one`));
            }
            else {
                return;
            }
        }
        let found = false;
        for (const [oldKey, data] of this._sessions) {
            if (data.session === session) {
                found = true;
                this._sessions.delete(oldKey);
                this._sessions.set(newKey, { ...data, editor: target });
                this._logService.trace(`[IE] did MOVE session for ${data.editor.getId()} to NEW EDITOR ${target.getId()}, ${session.agent.extensionId}`);
                this._onDidMoveSession.fire({ session, editor: target });
                break;
            }
        }
        if (!found) {
            throw ( new Error(`Cannot move session because it is not stored`));
        }
    }
    releaseSession(session) {
        this._releaseSession(session, false);
    }
    _releaseSession(session, byServer) {
        let tuple;
        for (const candidate of this._sessions) {
            if (candidate[1].session === session) {
                tuple = candidate;
                break;
            }
        }
        if (!tuple) {
            return;
        }
        this._telemetryService.publicLog2('interactiveEditor/session', session.asTelemetryData());
        const [key, value] = tuple;
        this._sessions.delete(key);
        this._logService.trace(`[IE] did RELEASED session for ${value.editor.getId()}, ${session.agent.extensionId}`);
        this._onDidEndSession.fire({ editor: value.editor, session, endedByExternalCause: byServer });
        value.store.dispose();
    }
    stashSession(session, editor, undoCancelEdits) {
        const result = this._instaService.createInstance(StashedSession, editor, session, undoCancelEdits);
        this._onDidStashSession.fire({ editor, session });
        this._logService.trace(`[IE] did STASH session for ${editor.getId()}, ${session.agent.extensionId}`);
        return result;
    }
    getCodeEditor(session) {
        for (const [, data] of this._sessions) {
            if (data.session === session) {
                return data.editor;
            }
        }
        throw ( new Error('session not found'));
    }
    getSession(editor, uri) {
        const key = this._key(editor, uri);
        return this._sessions.get(key)?.session;
    }
    _key(editor, uri) {
        const item = this._keyComputers.get(uri.scheme);
        return item
            ? item.getComparisonKey(editor, uri)
            : `${editor.getId()}@${( uri.toString())}`;
    }
    registerSessionKeyComputer(scheme, value) {
        this._keyComputers.set(scheme, value);
        return toDisposable(() => this._keyComputers.delete(scheme));
    }
    async createSession2(editor, uri, token) {
        assertType(editor.hasModel());
        if (( this._sessions2.has(uri))) {
            throw ( new Error('Session already exists'));
        }
        this._onWillStartSession.fire(editor);
        const chatModel = this._chatService.startSession(ChatAgentLocation.EditingSession, token);
        const editingSession = await this._chatEditingService.createEditingSession(chatModel.sessionId);
        editingSession.addFileToWorkingSet(uri);
        const store = ( new DisposableStore());
        store.add(toDisposable(() => {
            this._chatService.cancelCurrentRequestForSession(chatModel.sessionId);
            editingSession.reject();
            this._sessions2.delete(uri);
            this._onDidChangeSessions.fire(this);
        }));
        store.add(editingSession);
        store.add(chatModel);
        store.add(autorun(r => {
            const entries = editingSession.entries.read(r);
            if (entries.length === 0) {
                return;
            }
            const allSettled = entries.every(entry => {
                const state = entry.state.read(r);
                return state === WorkingSetEntryState.Accepted || state === WorkingSetEntryState.Rejected;
            });
            if (allSettled) {
                store.dispose();
            }
        }));
        const result = {
            uri,
            initialPosition: editor.getPosition().delta(-1),
            chatModel,
            editingSession,
            dispose: store.dispose.bind(store)
        };
        this._sessions2.set(uri, result);
        this._onDidChangeSessions.fire(this);
        return result;
    }
    getSession2(uri) {
        return this._sessions2.get(uri);
    }
};
InlineChatSessionServiceImpl = ( __decorate([
    ( __param(0, ITelemetryService)),
    ( __param(1, IModelService)),
    ( __param(2, ITextModelService)),
    ( __param(3, IEditorWorkerService)),
    ( __param(4, ILogService)),
    ( __param(5, IInstantiationService)),
    ( __param(6, IEditorService)),
    ( __param(7, ITextFileService)),
    ( __param(8, ILanguageService)),
    ( __param(9, IChatService)),
    ( __param(10, IChatAgentService)),
    ( __param(11, IChatEditingService))
], InlineChatSessionServiceImpl));
let InlineChatEnabler = class InlineChatEnabler {
    static { this.Id = 'inlineChat.enabler'; }
    constructor(contextKeyService, chatAgentService, editorService) {
        this._store = ( new DisposableStore());
        this._ctxHasProvider = CTX_INLINE_CHAT_HAS_AGENT.bindTo(contextKeyService);
        this._ctxHasProvider2 = CTX_INLINE_CHAT_HAS_AGENT2.bindTo(contextKeyService);
        this._ctxPossible = CTX_INLINE_CHAT_POSSIBLE.bindTo(contextKeyService);
        const updateAgent = () => {
            const agent = chatAgentService.getDefaultAgent(ChatAgentLocation.Editor);
            if (agent?.locations.length === 1) {
                this._ctxHasProvider.set(true);
                this._ctxHasProvider2.reset();
            }
            else if (agent?.locations.includes(ChatAgentLocation.EditingSession)) {
                this._ctxHasProvider.reset();
                this._ctxHasProvider2.set(true);
            }
            else {
                this._ctxHasProvider.reset();
                this._ctxHasProvider2.reset();
            }
        };
        this._store.add(chatAgentService.onDidChangeAgents(updateAgent));
        updateAgent();
        const updateEditor = () => {
            const ctrl = editorService.activeEditorPane?.getControl();
            const isCodeEditorLike = isCodeEditor(ctrl) || isDiffEditor(ctrl) || isCompositeEditor(ctrl);
            this._ctxPossible.set(isCodeEditorLike);
        };
        this._store.add(editorService.onDidActiveEditorChange(updateEditor));
        updateEditor();
    }
    dispose() {
        this._ctxPossible.reset();
        this._ctxHasProvider.reset();
        this._store.dispose();
    }
};
InlineChatEnabler = ( __decorate([
    ( __param(0, IContextKeyService)),
    ( __param(1, IChatAgentService)),
    ( __param(2, IEditorService))
], InlineChatEnabler));

export { InlineChatEnabler, InlineChatError, InlineChatSessionServiceImpl };
