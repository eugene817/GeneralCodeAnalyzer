
import { __decorate, __param } from '../../../../../../../../../../external/tslib/tslib.es6.js';
import { trackFocus } from '../../../../../../../base/browser/dom.js';
import { renderIcon } from '../../../../../../../base/browser/ui/iconLabel/iconLabels.js';
import { Codicon } from '../../../../../../../base/common/codicons.js';
import { Disposable, DisposableStore, toDisposable } from '../../../../../../../base/common/lifecycle.js';
import '../../../../../../../base/common/observableInternal/index.js';
import { observableFromEvent, constObservable, debouncedObservable, runOnChange } from '../../../../../../../base/common/observableInternal/utils.js';
import { IAccessibilityService } from '../../../../../../../platform/accessibility/common/accessibility.service.js';
import { IHoverService } from '../../../../../../../platform/hover/browser/hover.service.js';
import { IInstantiationService } from '../../../../../../../platform/instantiation/common/instantiation.js';
import { asCssVariable } from '../../../../../../../platform/theme/common/colorUtils.js';
import { Rect } from '../../../../../../browser/rect.js';
import { EditorOption } from '../../../../../../common/config/editorOptions.js';
import { OffsetRange } from '../../../../../../common/core/offsetRange.js';
import { StickyScrollController } from '../../../../../stickyScroll/browser/stickyScrollController.js';
import { inlineEditIndicatorBackground, inlineEditIndicatorsuccessfulForeground, inlineEditIndicatorPrimaryForeground, inlineEditIndicatorSecondaryForeground, inlineEditIndicatorsuccessfulBackground, inlineEditIndicatorPrimaryBackground, inlineEditIndicatorSecondaryBackground } from '../theme.js';
import { mapOutFalsy, rectToProps, InlineEditTabAction } from '../utils/utils.js';
import { GutterIndicatorMenuContent } from './gutterIndicatorMenu.js';
import { derived } from '../../../../../../../base/common/observableInternal/derived.js';
import { n } from '../../../../../../../base/browser/domImpl/n.js';
import { observableValue } from '../../../../../../../base/common/observableInternal/base.js';

let InlineEditsGutterIndicator = class InlineEditsGutterIndicator extends Disposable {
    constructor(_editorObs, _originalRange, _verticalOffset, _host, _isHoveringOverInlineEdit, _focusIsInMenu, _hoverService, _instantiationService, accessibilityService) {
        super();
        this._editorObs = _editorObs;
        this._originalRange = _originalRange;
        this._verticalOffset = _verticalOffset;
        this._host = _host;
        this._isHoveringOverInlineEdit = _isHoveringOverInlineEdit;
        this._focusIsInMenu = _focusIsInMenu;
        this._hoverService = _hoverService;
        this._instantiationService = _instantiationService;
        this._originalRangeObs = mapOutFalsy(this._originalRange);
        this._state = derived(reader => {
            const range = this._originalRangeObs.read(reader);
            if (!range) {
                return undefined;
            }
            return {
                range,
                lineOffsetRange: this._editorObs.observeLineOffsetRange(range, this._store),
            };
        });
        this._stickyScrollController = StickyScrollController.get(this._editorObs.editor);
        this._stickyScrollHeight = this._stickyScrollController
            ? observableFromEvent(this._stickyScrollController.onDidChangeStickyScrollHeight, () => this._stickyScrollController.stickyScrollWidgetHeight)
            : constObservable(0);
        this._layout = derived(this, reader => {
            const s = this._state.read(reader);
            if (!s) {
                return undefined;
            }
            const layout = this._editorObs.layoutInfo.read(reader);
            const bottomPadding = 1;
            const fullViewPort = Rect.fromLeftTopRightBottom(0, 0, layout.width, layout.height - bottomPadding);
            const viewPortWithStickyScroll = fullViewPort.withTop(this._stickyScrollHeight.read(reader));
            const targetVertRange = s.lineOffsetRange.read(reader);
            const space = 1;
            const targetRect = Rect.fromRanges(OffsetRange.fromTo(space + layout.glyphMarginLeft, layout.lineNumbersLeft + layout.lineNumbersWidth + 4), targetVertRange);
            const lineHeight = this._editorObs.getOption(EditorOption.lineHeight).read(reader);
            const pillOffset = this._verticalOffset.read(reader);
            const pillRect = targetRect.withHeight(lineHeight).withWidth(22).translateY(pillOffset);
            const pillRectMoved = pillRect.moveToBeContainedIn(viewPortWithStickyScroll);
            const rect = targetRect;
            const iconRect = (targetRect.containsRect(pillRectMoved))
                ? pillRectMoved
                : pillRectMoved.moveToBeContainedIn(fullViewPort.intersect(targetRect.union(fullViewPort.withHeight(lineHeight))));
            return {
                rect,
                iconRect,
                arrowDirection: (targetRect.containsRect(iconRect) ? 'right'
                    : iconRect.top > targetRect.top ? 'top' : 'bottom'),
                docked: rect.containsRect(iconRect) && viewPortWithStickyScroll.containsRect(iconRect),
            };
        });
        this._iconRef = n.ref();
        this._hoverVisible = observableValue(this, false);
        this.isHoverVisible = this._hoverVisible;
        this._isHoveredOverIcon = observableValue(this, false);
        this._indicator = n.div({
            class: 'inline-edits-view-gutter-indicator',
            onclick: () => {
                const docked = ( this._layout.map(l => l && l.docked)).get();
                this._editorObs.editor.focus();
                if (docked) {
                    this._host.accept();
                }
                else {
                    this._host.jump();
                }
            },
            tabIndex: 0,
            style: {
                position: 'absolute',
                overflow: 'visible',
            },
        }, ( mapOutFalsy(this._layout).map(layout => !layout ? [] : [
            n.div({
                style: {
                    position: 'absolute',
                    background: asCssVariable(inlineEditIndicatorBackground),
                    borderRadius: '4px',
                    ...rectToProps(reader => layout.read(reader).rect),
                }
            }),
            n.div({
                class: 'icon',
                ref: this._iconRef,
                onmouseenter: () => {
                    this._isHoveredOverIcon.set(true, undefined);
                    this._showHover();
                },
                onmouseleave: () => { this._isHoveredOverIcon.set(false, undefined); },
                style: {
                    cursor: 'pointer',
                    zIndex: '1000',
                    position: 'absolute',
                    backgroundColor: ( this._host.tabAction.map(v => {
                        switch (v) {
                            case InlineEditTabAction.Inactive: return asCssVariable(inlineEditIndicatorSecondaryBackground);
                            case InlineEditTabAction.Jump: return asCssVariable(inlineEditIndicatorPrimaryBackground);
                            case InlineEditTabAction.Accept: return asCssVariable(inlineEditIndicatorsuccessfulBackground);
                        }
                    })),
                    ['--vscodeIconForeground']: ( this._host.tabAction.map(v => {
                        switch (v) {
                            case InlineEditTabAction.Inactive: return asCssVariable(inlineEditIndicatorSecondaryForeground);
                            case InlineEditTabAction.Jump: return asCssVariable(inlineEditIndicatorPrimaryForeground);
                            case InlineEditTabAction.Accept: return asCssVariable(inlineEditIndicatorsuccessfulForeground);
                        }
                    })),
                    borderRadius: '4px',
                    display: 'flex',
                    justifyContent: 'center',
                    transition: 'background-color 0.2s ease-in-out',
                    ...rectToProps(reader => layout.read(reader).iconRect),
                }
            }, [
                n.div({
                    style: {
                        rotate: ( layout.map(l => {
                            switch (l.arrowDirection) {
                                case 'right': return '0deg';
                                case 'bottom': return '90deg';
                                case 'top': return '-90deg';
                            }
                        })),
                        transition: 'rotate 0.2s ease-in-out',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                    }
                }, [
                    ( this._host.tabAction.map(
                        v => v === InlineEditTabAction.Accept ? renderIcon(Codicon.keyboardTab) : renderIcon(Codicon.arrowRight)
                    ))
                ])
            ]),
        ]))).keepUpdated(this._store);
        this._register(this._editorObs.createOverlayWidget({
            domNode: this._indicator.element,
            position: constObservable(null),
            allowEditorOverflow: false,
            minContentWidthInPx: constObservable(0),
        }));
        if (!accessibilityService.isMotionReduced()) {
            const debouncedIsHovering = debouncedObservable(this._isHoveringOverInlineEdit, 100);
            this._register(runOnChange(debouncedIsHovering, (isHovering) => {
                if (!isHovering) {
                    return;
                }
                this._iconRef.element.animate([
                    { transform: 'rotate(0) scale(1)', offset: 0 },
                    { transform: 'rotate(14.4deg) scale(1.1)', offset: 0.15 },
                    { transform: 'rotate(-14.4deg) scale(1.2)', offset: 0.3 },
                    { transform: 'rotate(14.4deg) scale(1.1)', offset: 0.45 },
                    { transform: 'rotate(-14.4deg) scale(1.2)', offset: 0.6 },
                    { transform: 'rotate(0) scale(1)', offset: 1 }
                ], { duration: 800 });
            }));
        }
    }
    _showHover() {
        if (this._hoverVisible.get()) {
            return;
        }
        const disposableStore = ( new DisposableStore());
        const content = disposableStore.add(this._instantiationService.createInstance(GutterIndicatorMenuContent, this._host, (focusEditor) => {
            if (focusEditor) {
                this._editorObs.editor.focus();
            }
            h?.dispose();
        }, this._editorObs).toDisposableLiveElement());
        const focusTracker = disposableStore.add(trackFocus(content.element));
        disposableStore.add(focusTracker.onDidBlur(() => this._focusIsInMenu.set(false, undefined)));
        disposableStore.add(focusTracker.onDidFocus(() => this._focusIsInMenu.set(true, undefined)));
        disposableStore.add(toDisposable(() => this._focusIsInMenu.set(false, undefined)));
        const h = this._hoverService.showHover({
            target: this._iconRef.element,
            content: content.element,
        });
        if (h) {
            this._hoverVisible.set(true, undefined);
            disposableStore.add(h.onDispose(() => {
                this._hoverVisible.set(false, undefined);
                disposableStore.dispose();
            }));
        }
        else {
            disposableStore.dispose();
        }
    }
};
InlineEditsGutterIndicator = ( __decorate([
    ( __param(6, IHoverService)),
    ( __param(7, IInstantiationService)),
    ( __param(8, IAccessibilityService))
], InlineEditsGutterIndicator));

export { InlineEditsGutterIndicator };
