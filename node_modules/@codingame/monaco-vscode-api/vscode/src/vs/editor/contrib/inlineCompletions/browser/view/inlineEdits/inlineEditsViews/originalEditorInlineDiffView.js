
import { Emitter } from '../../../../../../../base/common/event.js';
import { Disposable } from '../../../../../../../base/common/lifecycle.js';
import '../../../../../../../base/common/observableInternal/index.js';
import { MouseTargetType } from '../../../../../../browser/editorBrowser.js';
import { observableCodeEditor } from '../../../../../../browser/observableCodeEditor.js';
import { rangeIsSingleLine } from '../../../../../../browser/widget/diffEditor/components/diffEditorViewZones/diffEditorViewZones.js';
import { RenderOptions, LineSource, renderLines } from '../../../../../../browser/widget/diffEditor/components/diffEditorViewZones/renderLines.js';
import { diffAddDecoration } from '../../../../../../browser/widget/diffEditor/registrations.contribution.js';
import { applyViewZones } from '../../../../../../browser/widget/diffEditor/utils.js';
import { EditorOption } from '../../../../../../common/config/editorOptions.js';
import { OffsetRange } from '../../../../../../common/core/offsetRange.js';
import { Range } from '../../../../../../common/core/range.js';
import { EndOfLinePreference, InjectedTextCursorStops } from '../../../../../../common/model.js';
import { ModelDecorationOptions } from '../../../../../../common/model/textModel.js';
import { InlineDecoration, InlineDecorationType } from '../../../../../../common/viewModel.js';
import { classNames } from '../utils/utils.js';
import { derived } from '../../../../../../../base/common/observableInternal/derived.js';
import { autorunWithStore } from '../../../../../../../base/common/observableInternal/autorun.js';
import { observableFromEvent } from '../../../../../../../base/common/observableInternal/utils.js';

class OriginalEditorInlineDiffView extends Disposable {
    static supportsInlineDiffRendering(mapping) {
        return allowsTrueInlineDiffRendering(mapping);
    }
    constructor(_originalEditor, _state, _modifiedTextModel) {
        super();
        this._originalEditor = _originalEditor;
        this._state = _state;
        this._modifiedTextModel = _modifiedTextModel;
        this._onDidClick = this._register(( new Emitter()));
        this.onDidClick = this._onDidClick.event;
        this.isHovered = observableCodeEditor(this._originalEditor).isTargetHovered(p => p.target.type === MouseTargetType.CONTENT_TEXT && p.target.detail.injectedText?.options.attachedData instanceof InlineEditAttachedData, this._store);
        this._tokenizationFinished = modelTokenizationFinished(this._modifiedTextModel);
        this._decorations = derived(this, reader => {
            const diff = this._state.read(reader);
            if (!diff) {
                return undefined;
            }
            const modified = diff.modifiedText;
            const showInline = diff.mode === 'mixedLines' || diff.mode === 'insertionInline';
            const showEmptyDecorations = true;
            const originalDecorations = [];
            const modifiedDecorations = [];
            const diffLineAddDecorationBackground = ModelDecorationOptions.register({
                className: 'inlineCompletions-line-insert',
                description: 'line-insert',
                isWholeLine: true,
                marginClassName: 'gutter-insert',
            });
            const diffLineDeleteDecorationBackground = ModelDecorationOptions.register({
                className: 'inlineCompletions-line-delete',
                description: 'line-delete',
                isWholeLine: true,
                marginClassName: 'gutter-delete',
            });
            const diffWholeLineDeleteDecoration = ModelDecorationOptions.register({
                className: 'inlineCompletions-char-delete',
                description: 'char-delete',
                isWholeLine: false,
            });
            const diffWholeLineAddDecoration = ModelDecorationOptions.register({
                className: 'inlineCompletions-char-insert',
                description: 'char-insert',
                isWholeLine: true,
            });
            const diffAddDecoration = ModelDecorationOptions.register({
                className: 'inlineCompletions-char-insert',
                description: 'char-insert',
                shouldFillLineOnLineBreak: true,
            });
            const diffAddDecorationEmpty = ModelDecorationOptions.register({
                className: 'inlineCompletions-char-insert diff-range-empty',
                description: 'char-insert diff-range-empty',
            });
            for (const m of diff.diff) {
                const showFullLineDecorations = diff.mode !== 'sideBySide';
                if (showFullLineDecorations) {
                    if (!m.original.isEmpty) {
                        originalDecorations.push({
                            range: m.original.toInclusiveRange(),
                            options: diffLineDeleteDecorationBackground,
                        });
                    }
                    if (!m.modified.isEmpty) {
                        modifiedDecorations.push({
                            range: m.modified.toInclusiveRange(),
                            options: diffLineAddDecorationBackground,
                        });
                    }
                }
                if (m.modified.isEmpty || m.original.isEmpty) {
                    if (!m.original.isEmpty) {
                        originalDecorations.push({ range: m.original.toInclusiveRange(), options: diffWholeLineDeleteDecoration });
                    }
                    if (!m.modified.isEmpty) {
                        modifiedDecorations.push({ range: m.modified.toInclusiveRange(), options: diffWholeLineAddDecoration });
                    }
                }
                else {
                    const useInlineDiff = showInline && allowsTrueInlineDiffRendering(m);
                    for (const i of m.innerChanges || []) {
                        if (m.original.contains(i.originalRange.startLineNumber)) {
                            const replacedText = this._originalEditor.getModel()?.getValueInRange(i.originalRange, EndOfLinePreference.LF);
                            originalDecorations.push({
                                range: i.originalRange,
                                options: {
                                    description: 'char-delete',
                                    shouldFillLineOnLineBreak: false,
                                    className: classNames('inlineCompletions-char-delete', i.originalRange.isSingleLine() && diff.mode === 'insertionInline' && 'single-line-inline', i.originalRange.isEmpty() && 'empty', ((i.originalRange.isEmpty() || diff.mode === 'deletion' && replacedText === '\n') && showEmptyDecorations && !useInlineDiff) && 'diff-range-empty'),
                                    inlineClassName: useInlineDiff ? classNames('strike-through', 'inlineCompletions') : null,
                                    zIndex: 1
                                }
                            });
                        }
                        if (m.modified.contains(i.modifiedRange.startLineNumber)) {
                            modifiedDecorations.push({
                                range: i.modifiedRange,
                                options: (i.modifiedRange.isEmpty() && showEmptyDecorations && !useInlineDiff)
                                    ? diffAddDecorationEmpty
                                    : diffAddDecoration
                            });
                        }
                        if (useInlineDiff) {
                            const insertedText = modified.getValueOfRange(i.modifiedRange);
                            const textSegments = insertedText.length > 3 ?
                                [
                                    { text: insertedText.slice(0, 1), extraClasses: ['start'], offsetRange: ( new OffsetRange(i.modifiedRange.startColumn - 1, i.modifiedRange.startColumn)) },
                                    { text: insertedText.slice(1, -1), extraClasses: [], offsetRange: ( new OffsetRange(i.modifiedRange.startColumn, i.modifiedRange.endColumn - 2)) },
                                    { text: insertedText.slice(-1), extraClasses: ['end'], offsetRange: ( new OffsetRange(i.modifiedRange.endColumn - 2, i.modifiedRange.endColumn - 1)) }
                                ] :
                                [
                                    { text: insertedText, extraClasses: ['start', 'end'], offsetRange: ( new OffsetRange(i.modifiedRange.startColumn - 1, i.modifiedRange.endColumn)) }
                                ];
                            this._tokenizationFinished.read(reader);
                            const lineTokens = this._modifiedTextModel.tokenization.getLineTokens(i.modifiedRange.startLineNumber);
                            for (const { text, extraClasses, offsetRange } of textSegments) {
                                originalDecorations.push({
                                    range: Range.fromPositions(i.originalRange.getEndPosition()),
                                    options: {
                                        description: 'inserted-text',
                                        before: {
                                            tokens: lineTokens.getTokensInRange(offsetRange),
                                            content: text,
                                            inlineClassName: classNames('inlineCompletions-char-insert', i.modifiedRange.isSingleLine() && diff.mode === 'insertionInline' && 'single-line-inline', ...extraClasses
                                            ),
                                            cursorStops: InjectedTextCursorStops.None,
                                            attachedData: ( new InlineEditAttachedData()),
                                        },
                                        zIndex: 2,
                                        showIfCollapsed: true,
                                    }
                                });
                            }
                        }
                    }
                }
            }
            return { originalDecorations, modifiedDecorations };
        });
        this._register(observableCodeEditor(this._originalEditor).setDecorations(( this._decorations.map(d => d?.originalDecorations ?? []))));
        const modifiedCodeEditor = ( this._state.map(s => s?.modifiedCodeEditor));
        this._register(autorunWithStore((reader, store) => {
            const e = modifiedCodeEditor.read(reader);
            if (e) {
                store.add(observableCodeEditor(e).setDecorations(( this._decorations.map(d => d?.modifiedDecorations ?? []))));
            }
        }));
        const editor = observableCodeEditor(this._originalEditor);
        this._register(this._originalEditor.onMouseUp(e => {
            if (e.target.type !== MouseTargetType.CONTENT_TEXT) {
                return;
            }
            const a = e.target.detail.injectedText?.options.attachedData;
            if (a instanceof InlineEditAttachedData) {
                this._onDidClick.fire(e.event);
            }
        }));
        const originalViewZones = derived(this, (reader) => {
            const originalModel = editor.model.read(reader);
            if (!originalModel) {
                return [];
            }
            const origViewZones = [];
            const renderOptions = RenderOptions.fromEditor(this._originalEditor);
            const modLineHeight = editor.getOption(EditorOption.lineHeight).read(reader);
            const s = this._state.read(reader);
            if (!s) {
                return origViewZones;
            }
            for (const diff of s.diff) {
                if (s.mode !== 'interleavedLines') {
                    continue;
                }
                this._tokenizationFinished.read(reader);
                const source = ( new LineSource(
                    diff.modified.mapToLineArray(l => this._modifiedTextModel.tokenization.getLineTokens(l))
                ));
                const decorations = [];
                for (const i of diff.innerChanges || []) {
                    decorations.push(( new InlineDecoration(
                        i.modifiedRange.delta(-(diff.original.startLineNumber - 1)),
                        diffAddDecoration.className,
                        InlineDecorationType.Regular
                    )));
                }
                const deletedCodeDomNode = document.createElement('div');
                deletedCodeDomNode.classList.add('view-lines', 'line-insert', 'monaco-mouse-cursor-text');
                const result = renderLines(source, renderOptions, decorations, deletedCodeDomNode);
                origViewZones.push({
                    afterLineNumber: diff.original.endLineNumberExclusive - 1,
                    domNode: deletedCodeDomNode,
                    heightInPx: result.heightInLines * modLineHeight,
                    minWidthInPx: result.minWidthInPx,
                    showInHiddenAreas: true,
                    suppressMouseDown: true,
                });
            }
            return origViewZones;
        });
        this._register(applyViewZones(this._originalEditor, originalViewZones));
    }
}
class InlineEditAttachedData {
}
function allowsTrueInlineDiffRendering(mapping) {
    if (!mapping.innerChanges) {
        return false;
    }
    return mapping.innerChanges.every(c => (rangeIsSingleLine(c.modifiedRange) && rangeIsSingleLine(c.originalRange)));
}
let i = 0;
function modelTokenizationFinished(model) {
    return observableFromEvent(model.onDidChangeTokens, () => i++);
}

export { OriginalEditorInlineDiffView };
