import { ILanguageIdCodec } from "../languages.js";
import { LineTokens } from "../tokens/lineTokens.js";
import { StandardTokenType } from "../encodedTokenAttributes.js";
import { TextModel } from "./textModel.js";
import { IModelContentChangedEvent } from "../textModelEvents.js";
import { AbstractTokens } from "./tokens.js";
import { ITreeSitterTokenizationStoreService } from "./treeSitterTokenStoreService.service.js";
import { BackgroundTokenizationState } from "../tokenizationTextModelPart.js";
import { Emitter, Event } from "../../../base/common/event.js";
export declare class TreeSitterTokens extends AbstractTokens {
    private readonly _tokenStore;
    private _tokenizationSupport;
    protected _backgroundTokenizationState: BackgroundTokenizationState;
    protected readonly _onDidChangeBackgroundTokenizationState: Emitter<void>;
    readonly onDidChangeBackgroundTokenizationState: Event<void>;
    private _lastLanguageId;
    private readonly _tokensChangedListener;
    private readonly _firstTokenizationCompleteListener;
    constructor(languageIdCodec: ILanguageIdCodec, textModel: TextModel, languageId: () => string, _tokenStore: ITreeSitterTokenizationStoreService);
    private _initialize;
    getLineTokens(lineNumber: number): LineTokens;
    resetTokenization(fireTokenChangeEvent?: boolean): void;
    handleDidChangeAttached(): void;
    handleDidChangeContent(e: IModelContentChangedEvent): void;
    forceTokenization(lineNumber: number): void;
    hasAccurateTokensForLine(lineNumber: number): boolean;
    isCheapToTokenize(lineNumber: number): boolean;
    getTokenTypeIfInsertingCharacter(lineNumber: number, column: number, character: string): StandardTokenType;
    tokenizeLinesAt(lineNumber: number, lines: string[]): LineTokens[] | null;
    get hasTokens(): boolean;
}
