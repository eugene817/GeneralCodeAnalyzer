import { Disposable, DisposableStore, IDisposable } from "../../base/common/lifecycle.js";
import { IObservable, IObservableWithChange, ITransaction } from "../../base/common/observable.js";
import { EditorOption, FindComputedEditorOptionValueById } from "../common/config/editorOptions.js";
import { LineRange } from "../common/core/lineRange.js";
import { OffsetRange } from "../common/core/offsetRange.js";
import { Position } from "../common/core/position.js";
import { Selection } from "../common/core/selection.js";
import { ICursorSelectionChangedEvent } from "../common/cursorEvents.js";
import { IModelDeltaDecoration, ITextModel } from "../common/model.js";
import { IModelContentChangedEvent } from "../common/textModelEvents.js";
import { ICodeEditor, IContentWidgetPosition, IEditorMouseEvent, IOverlayWidgetPosition, IPasteEvent } from "./editorBrowser.js";
import { Point } from "./point.js";
export declare function observableCodeEditor(editor: ICodeEditor): ObservableCodeEditor;
export declare class ObservableCodeEditor extends Disposable {
    readonly editor: ICodeEditor;
    private static readonly _map;
    static get(editor: ICodeEditor): ObservableCodeEditor;
    private _updateCounter;
    private _currentTransaction;
    private _beginUpdate;
    private _endUpdate;
    private constructor();
    forceUpdate(): void;
    forceUpdate<T>(cb: (tx: ITransaction) => T): T;
    private _forceUpdate;
    private readonly _model;
    readonly model: IObservable<ITextModel | null>;
    readonly isReadonly: IObservable<boolean>;
    private readonly _versionId;
    readonly versionId: IObservableWithChange<number | null, IModelContentChangedEvent | undefined>;
    private readonly _selections;
    readonly selections: IObservableWithChange<Selection[] | null, ICursorSelectionChangedEvent | undefined>;
    readonly positions: IObservable<readonly Position[] | null>;
    readonly isFocused: IObservable<boolean>;
    readonly isTextFocused: IObservable<boolean>;
    readonly inComposition: IObservable<boolean>;
    readonly value: import("../../base/common/observable.js").ISettableObservable<string, void>;
    readonly valueIsEmpty: IObservable<boolean>;
    readonly cursorSelection: IObservable<Selection | null>;
    readonly cursorPosition: IObservable<Position | null>;
    readonly cursorLineNumber: IObservable<number | null>;
    readonly onDidType: import("../../base/common/observable.js").IObservableSignal<string>;
    readonly onDidPaste: import("../../base/common/observable.js").IObservableSignal<IPasteEvent>;
    readonly scrollTop: IObservable<number>;
    readonly scrollLeft: IObservable<number>;
    readonly layoutInfo: IObservable<import("../common/config/editorOptions.js").EditorLayoutInfo>;
    readonly layoutInfoContentLeft: IObservable<number>;
    readonly layoutInfoDecorationsLeft: IObservable<number>;
    readonly layoutInfoWidth: IObservable<number>;
    readonly layoutInfoMinimap: IObservable<import("../common/config/editorOptions.js").EditorMinimapLayoutInfo>;
    readonly layoutInfoVerticalScrollbarWidth: IObservable<number>;
    readonly contentWidth: IObservable<number>;
    getOption<T extends EditorOption>(id: T): IObservable<FindComputedEditorOptionValueById<T>>;
    setDecorations(decorations: IObservable<IModelDeltaDecoration[]>): IDisposable;
    private _widgetCounter;
    createOverlayWidget(widget: IObservableOverlayWidget): IDisposable;
    createContentWidget(widget: IObservableContentWidget): IDisposable;
    observeLineOffsetRange(lineRange: IObservable<LineRange>, store: DisposableStore): IObservable<OffsetRange>;
    observePosition(position: IObservable<Position | null>, store: DisposableStore): IObservable<Point | null>;
    readonly openedPeekWidgets: import("../../base/common/observable.js").ISettableObservable<number, void>;
    isTargetHovered(predicate: (target: IEditorMouseEvent) => boolean, store: DisposableStore): IObservable<boolean>;
}
interface IObservableOverlayWidget {
    get domNode(): HTMLElement;
    readonly position: IObservable<IOverlayWidgetPosition | null>;
    readonly minContentWidthInPx: IObservable<number>;
    get allowEditorOverflow(): boolean;
}
interface IObservableContentWidget {
    get domNode(): HTMLElement;
    readonly position: IObservable<IContentWidgetPosition | null>;
    get allowEditorOverflow(): boolean;
}
export {};
