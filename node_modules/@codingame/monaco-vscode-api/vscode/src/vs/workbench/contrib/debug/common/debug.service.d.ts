import { Event } from "../../../../base/common/event.js";
import { URI as uri } from "../../../../base/common/uri.js";
import { ITextModel as EditorIModel } from "../../../../editor/common/model.js";
import { State, IDebugSessionOptions, IDebugSession, IConfigurationManager, IAdapterManager, IStackFrame, IThread, IBreakpointData, IBreakpoint, IBreakpointUpdateData, IEnablement, IExceptionBreakpoint, ILaunch, IConfig, IDebugModel, IViewModel } from "./debug.js";
import { IFunctionBreakpointOptions, IDataBreakpointOptions, IInstructionBreakpointOptions } from "@codingame/monaco-vscode-88aa9a78-75f5-5aaa-89e9-bbdd580b3b5c-common/vscode/vs/workbench/contrib/debug/common/debugModel";
export declare const IDebugService: import("../../../../platform/instantiation/common/instantiation.js").ServiceIdentifier<IDebugService>;
export interface IDebugService {
    readonly _serviceBrand: undefined;
    readonly state: State;
    readonly initializingOptions?: IDebugSessionOptions | undefined;
    onDidChangeState: Event<State>;
    onWillNewSession: Event<IDebugSession>;
    onDidNewSession: Event<IDebugSession>;
    onDidEndSession: Event<{
        session: IDebugSession;
        restart: boolean;
    }>;
    getConfigurationManager(): IConfigurationManager;
    getAdapterManager(): IAdapterManager;
    focusStackFrame(focusedStackFrame: IStackFrame | undefined, thread?: IThread, session?: IDebugSession, options?: {
        explicit?: boolean;
        preserveFocus?: boolean;
        sideBySide?: boolean;
        pinned?: boolean;
    }): Promise<void>;
    canSetBreakpointsIn(model: EditorIModel): boolean;
    addBreakpoints(uri: uri, rawBreakpoints: IBreakpointData[], ariaAnnounce?: boolean): Promise<IBreakpoint[]>;
    updateBreakpoints(originalUri: uri, data: Map<string, IBreakpointUpdateData>, sendOnResourceSaved: boolean): Promise<void>;
    enableOrDisableBreakpoints(enable: boolean, breakpoint?: IEnablement): Promise<void>;
    setBreakpointsActivated(activated: boolean): Promise<void>;
    removeBreakpoints(id?: string): Promise<any>;
    addFunctionBreakpoint(opts?: IFunctionBreakpointOptions, id?: string): void;
    updateFunctionBreakpoint(id: string, update: {
        name?: string;
        hitCondition?: string;
        condition?: string;
    }): Promise<void>;
    removeFunctionBreakpoints(id?: string): Promise<void>;
    addDataBreakpoint(opts: IDataBreakpointOptions): Promise<void>;
    updateDataBreakpoint(id: string, update: {
        hitCondition?: string;
        condition?: string;
    }): Promise<void>;
    removeDataBreakpoints(id?: string): Promise<void>;
    addInstructionBreakpoint(opts: IInstructionBreakpointOptions): Promise<void>;
    removeInstructionBreakpoints(instructionReference?: string, offset?: number): Promise<void>;
    setExceptionBreakpointCondition(breakpoint: IExceptionBreakpoint, condition: string | undefined): Promise<void>;
    setExceptionBreakpointsForSession(session: IDebugSession, filters: DebugProtocol.ExceptionBreakpointsFilter[]): void;
    sendAllBreakpoints(session?: IDebugSession): Promise<any>;
    sendBreakpoints(modelUri: uri, sourceModified?: boolean, session?: IDebugSession): Promise<any>;
    addWatchExpression(name?: string): void;
    renameWatchExpression(id: string, newName: string): void;
    moveWatchExpression(id: string, position: number): void;
    removeWatchExpressions(id?: string): void;
    startDebugging(launch: ILaunch | undefined, configOrName?: IConfig | string, options?: IDebugSessionOptions, saveBeforeStart?: boolean): Promise<boolean>;
    restartSession(session: IDebugSession, restartData?: any): Promise<any>;
    stopSession(session: IDebugSession | undefined, disconnect?: boolean, suspend?: boolean): Promise<any>;
    sourceIsNotAvailable(uri: uri): void;
    getModel(): IDebugModel;
    getViewModel(): IViewModel;
    runTo(uri: uri, lineNumber: number, column?: number): Promise<void>;
}
