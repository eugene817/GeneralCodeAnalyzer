
import { coalesce, asArray, isNonEmptyArray } from '../../../base/common/arrays.js';
import { encodeBase64, VSBuffer } from '../../../base/common/buffer.js';
import { UriList } from '../../../base/common/dataTransfer.js';
import { createSingleCallFunction } from '../../../base/common/functional.js';
import { parseHrefAndDimensions, isMarkdownString } from '../../../base/common/htmlContent.js';
import { ResourceSet, ResourceMap } from '../../../base/common/map.js';
import { marked } from 'marked';
import { parse, revive } from '../../../base/common/marshalling.js';
import { MarshalledId } from '../../../base/common/marshallingIds.js';
import { Mimes } from '../../../base/common/mime.js';
import { cloneAndChange } from '../../../base/common/objects.js';
import { isWindows } from '../../../base/common/platform.js';
import { WellDefinedPrefixTree } from '../../../base/common/prefixTree.js';
import { basename } from '../../../base/common/resources.js';
import { ThemeIcon } from '../../../base/common/themables.js';
import { isString, isNumber, isEmptyObject, isUndefinedOrNull, isDefined } from '../../../base/common/types.js';
import { URI, isUriComponents } from '../../../base/common/uri.js';
import { generateUuid } from '../../../base/common/uuid.js';
import { RenderLineNumbersType } from '../../../editor/common/config/editorOptions.js';
import { Range as Range$2 } from '../../../editor/common/core/range.js';
import { StandardTokenType } from '../../../editor/common/encodedTokenAttributes.js';
import { SymbolKind as SymbolKind$1, SymbolTag as SymbolTag$2, CompletionTriggerKind as CompletionTriggerKind$2, CompletionItemTag as CompletionItemTag$2, CompletionItemKind as CompletionItemKind$2, CompletionItemInsertTextRule, Command, FoldingRangeKind as FoldingRangeKind$2, CodeActionTriggerType, PartialAcceptTriggerKind as PartialAcceptTriggerKind$2 } from '../../../editor/common/languages.js';
import { TrackedRangeStickiness, EndOfLineSequence } from '../../../editor/common/model.js';
import { MarkerTag, MarkerSeverity } from '../../../platform/markers/common/markers.js';
import { ProgressLocation as ProgressLocation$2 } from '../../../platform/progress/common/progress.js';
import { SaveReason, DEFAULT_EDITOR_ASSOCIATION } from '../../common/editor.js';
import { ChatAgentLocation } from '../../contrib/chat/common/chatAgents.js';
import { ChatMessageRole } from '../../contrib/chat/common/languageModels.js';
import { DebugTreeItemCollapsibleState } from '../../contrib/debug/common/debug.js';
import { CellEditType, NotebookCellExecutionState as NotebookCellExecutionState$1, CellKind, CellStatusbarAlignment } from '../../contrib/notebook/common/notebookCommon.js';
import { TestId } from '../../contrib/testing/common/testId.js';
import { TestMessageType, namespaceTestTag, denamespaceTestTag, TestRunProfileBitset, DetailType } from '../../contrib/testing/common/testTypes.js';
import { SIDE_GROUP, ACTIVE_GROUP } from '../../services/editor/common/editorService.js';
import { checkProposedApiEnabled } from '../../services/extensions/common/extensions.js';
import { getPrivateApiFor } from './extHostTestingPrivateApi.js';
import { Position as Position$1, Selection as Selection$1, Range as Range$1, Location as Location$1, StandardTokenType as StandardTokenType$1, DiagnosticTag as DiagnosticTag$1, Diagnostic as Diagnostic$1, DiagnosticRelatedInformation as DiagnosticRelatedInformation$1, DiagnosticSeverity as DiagnosticSeverity$1, ViewColumn as ViewColumn$1, MarkdownString as MarkdownString$1, DecorationRangeBehavior as DecorationRangeBehavior$1, TextEdit as TextEdit$1, WorkspaceEdit as WorkspaceEdit$1, FileEditType, SnippetTextEdit, SnippetString, SymbolKind as SymbolKind$2, SymbolTag as SymbolTag$1, SymbolInformation, DocumentSymbol as DocumentSymbol$1, CallHierarchyItem as CallHierarchyItem$1, CallHierarchyIncomingCall as CallHierarchyIncomingCall$1, CallHierarchyOutgoingCall as CallHierarchyOutgoingCall$1, VerboseHover, EvaluatableExpression as EvaluatableExpression$1, InlineValueText, InlineValueVariableLookup, InlineValueEvaluatableExpression, InlineValueContext as InlineValueContext$1, DocumentHighlight as DocumentHighlight$1, MultiDocumentHighlight as MultiDocumentHighlight$1, CompletionTriggerKind as CompletionTriggerKind$1, CompletionItemTag as CompletionItemTag$1, CompletionItemKind as CompletionItemKind$1, CompletionItem as CompletionItem$1, InlayHint as InlayHint$1, InlayHintLabelPart as InlayHintLabelPart$1, DocumentLink as DocumentLink$1, ColorPresentation as ColorPresentation$1, Color as Color$1, SelectionRange as SelectionRange$1, TextDocumentSaveReason as TextDocumentSaveReason$1, TextEditorLineNumbersStyle as TextEditorLineNumbersStyle$1, EndOfLine as EndOfLine$1, ProgressLocation as ProgressLocation$1, FoldingRangeKind as FoldingRangeKind$1, RelativePattern, NotebookRange as NotebookRange$1, NotebookCellExecutionState as NotebookCellExecutionState$2, NotebookCellKind as NotebookCellKind$1, NotebookCellData as NotebookCellData$1, NotebookData as NotebookData$1, NotebookCellOutputItem as NotebookCellOutputItem$1, NotebookCellOutput as NotebookCellOutput$1, NotebookCellStatusBarAlignment, NotebookRendererScript as NotebookRendererScript$1, TestMessage as TestMessage$1, TestRunProfileKind as TestRunProfileKind$1, TestTag as TestTag$1, StatementCoverage, BranchCoverage, DeclarationCoverage, validateTestCoverageCount, FileCoverage, CodeActionTriggerKind as CodeActionTriggerKind$1, TypeHierarchyItem as TypeHierarchyItem$1, InternalFileDataTransferItem, DataTransferFile, InternalDataTransferItem, DataTransfer as DataTransfer$1, LanguageModelChatMessageRole as LanguageModelChatMessageRole$1, LanguageModelTextPart, LanguageModelPromptTsxPart, LanguageModelToolResultPart, LanguageModelToolCallPart, LanguageModelChatMessage as LanguageModelChatMessage$1, ChatResponseMarkdownPart as ChatResponseMarkdownPart$1, ChatResponseCodeblockUriPart as ChatResponseCodeblockUriPart$1, ChatResponseMarkdownWithVulnerabilitiesPart as ChatResponseMarkdownWithVulnerabilitiesPart$1, ChatResponseFileTreePart, ChatResponseAnchorPart as ChatResponseAnchorPart$1, ChatResponseProgressPart as ChatResponseProgressPart$1, ChatResponseWarningPart as ChatResponseWarningPart$1, ChatResponseMovePart as ChatResponseMovePart$1, ChatResponseCommandButtonPart as ChatResponseCommandButtonPart$1, ChatResponseTextEditPart as ChatResponseTextEditPart$1, ChatResponseReferencePart as ChatResponseReferencePart$1, ChatResponseNotebookEditPart as ChatResponseNotebookEditPart$1, ChatResponseConfirmationPart as ChatResponseConfirmationPart$1, ChatResponseCodeCitationPart as ChatResponseCodeCitationPart$1, ChatLocation as ChatLocation$1, ChatReferenceBinaryData, ChatReferenceDiagnostic, LanguageModelToolResult as LanguageModelToolResult$1, ChatEditingSessionActionOutcome, PartialAcceptTriggerKind as PartialAcceptTriggerKind$1 } from './extHostTypes.js';

var Selection;
(function (Selection) {
    function to(selection) {
        const { selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn } = selection;
        const start = new Position$1(selectionStartLineNumber - 1, selectionStartColumn - 1);
        const end = new Position$1(positionLineNumber - 1, positionColumn - 1);
        return new Selection$1(start, end);
    }
    Selection.to = to;
    function from(selection) {
        const { anchor, active } = selection;
        return {
            selectionStartLineNumber: anchor.line + 1,
            selectionStartColumn: anchor.character + 1,
            positionLineNumber: active.line + 1,
            positionColumn: active.character + 1
        };
    }
    Selection.from = from;
})(Selection || (Selection = {}));
var Range;
(function (Range) {
    function from(range) {
        if (!range) {
            return undefined;
        }
        const { start, end } = range;
        return {
            startLineNumber: start.line + 1,
            startColumn: start.character + 1,
            endLineNumber: end.line + 1,
            endColumn: end.character + 1
        };
    }
    Range.from = from;
    function to(range) {
        if (!range) {
            return undefined;
        }
        const { startLineNumber, startColumn, endLineNumber, endColumn } = range;
        return new Range$1(startLineNumber - 1, startColumn - 1, endLineNumber - 1, endColumn - 1);
    }
    Range.to = to;
})(Range || (Range = {}));
var Location;
(function (Location) {
    function from(location) {
        return {
            uri: location.uri,
            range: Range.from(location.range)
        };
    }
    Location.from = from;
    function to(location) {
        return new Location$1(URI.revive(location.uri), Range.to(location.range));
    }
    Location.to = to;
})(Location || (Location = {}));
var TokenType;
(function (TokenType) {
    function to(type) {
        switch (type) {
            case StandardTokenType.Comment: return StandardTokenType$1.Comment;
            case StandardTokenType.Other: return StandardTokenType$1.Other;
            case StandardTokenType.RegEx: return StandardTokenType$1.RegEx;
            case StandardTokenType.String: return StandardTokenType$1.String;
        }
    }
    TokenType.to = to;
})(TokenType || (TokenType = {}));
var Position;
(function (Position) {
    function to(position) {
        return new Position$1(position.lineNumber - 1, position.column - 1);
    }
    Position.to = to;
    function from(position) {
        return { lineNumber: position.line + 1, column: position.character + 1 };
    }
    Position.from = from;
})(Position || (Position = {}));
var DocumentSelector;
(function (DocumentSelector) {
    function from(value, uriTransformer, extension) {
        return coalesce(( asArray(value).map(sel => _doTransformDocumentSelector(sel, uriTransformer, extension))));
    }
    DocumentSelector.from = from;
    function _doTransformDocumentSelector(selector, uriTransformer, extension) {
        if (typeof selector === 'string') {
            return {
                $serialized: true,
                language: selector,
                isBuiltin: extension?.isBuiltin,
            };
        }
        if (selector) {
            return {
                $serialized: true,
                language: selector.language,
                scheme: _transformScheme(selector.scheme, uriTransformer),
                pattern: GlobPattern.from(selector.pattern) ?? undefined,
                exclusive: selector.exclusive,
                notebookType: selector.notebookType,
                isBuiltin: extension?.isBuiltin
            };
        }
        return undefined;
    }
    function _transformScheme(scheme, uriTransformer) {
        if (uriTransformer && typeof scheme === 'string') {
            return uriTransformer.transformOutgoingScheme(scheme);
        }
        return scheme;
    }
})(DocumentSelector || (DocumentSelector = {}));
var DiagnosticTag;
(function (DiagnosticTag) {
    function from(value) {
        switch (value) {
            case DiagnosticTag$1.Unnecessary:
                return MarkerTag.Unnecessary;
            case DiagnosticTag$1.Deprecated:
                return MarkerTag.Deprecated;
        }
        return undefined;
    }
    DiagnosticTag.from = from;
    function to(value) {
        switch (value) {
            case MarkerTag.Unnecessary:
                return DiagnosticTag$1.Unnecessary;
            case MarkerTag.Deprecated:
                return DiagnosticTag$1.Deprecated;
            default:
                return undefined;
        }
    }
    DiagnosticTag.to = to;
})(DiagnosticTag || (DiagnosticTag = {}));
var Diagnostic;
(function (Diagnostic) {
    function from(value) {
        let code;
        if (value.code) {
            if (isString(value.code) || isNumber(value.code)) {
                code = String(value.code);
            }
            else {
                code = {
                    value: String(value.code.value),
                    target: value.code.target,
                };
            }
        }
        return {
            ...Range.from(value.range),
            message: value.message,
            source: value.source,
            code,
            severity: DiagnosticSeverity.from(value.severity),
            relatedInformation: value.relatedInformation && ( value.relatedInformation.map(DiagnosticRelatedInformation.from)),
            tags: Array.isArray(value.tags) ? coalesce(( value.tags.map(DiagnosticTag.from))) : undefined,
        };
    }
    Diagnostic.from = from;
    function to(value) {
        const res = new Diagnostic$1(Range.to(value), value.message, DiagnosticSeverity.to(value.severity));
        res.source = value.source;
        res.code = isString(value.code) ? value.code : value.code?.value;
        res.relatedInformation = value.relatedInformation && ( value.relatedInformation.map(DiagnosticRelatedInformation.to));
        res.tags = value.tags && coalesce(( value.tags.map(DiagnosticTag.to)));
        return res;
    }
    Diagnostic.to = to;
})(Diagnostic || (Diagnostic = {}));
var DiagnosticRelatedInformation;
(function (DiagnosticRelatedInformation) {
    function from(value) {
        return {
            ...Range.from(value.location.range),
            message: value.message,
            resource: value.location.uri
        };
    }
    DiagnosticRelatedInformation.from = from;
    function to(value) {
        return new DiagnosticRelatedInformation$1(new Location$1(value.resource, Range.to(value)), value.message);
    }
    DiagnosticRelatedInformation.to = to;
})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
var DiagnosticSeverity;
(function (DiagnosticSeverity) {
    function from(value) {
        switch (value) {
            case DiagnosticSeverity$1.Error:
                return MarkerSeverity.Error;
            case DiagnosticSeverity$1.Warning:
                return MarkerSeverity.Warning;
            case DiagnosticSeverity$1.Information:
                return MarkerSeverity.Info;
            case DiagnosticSeverity$1.Hint:
                return MarkerSeverity.Hint;
        }
        return MarkerSeverity.Error;
    }
    DiagnosticSeverity.from = from;
    function to(value) {
        switch (value) {
            case MarkerSeverity.Info:
                return DiagnosticSeverity$1.Information;
            case MarkerSeverity.Warning:
                return DiagnosticSeverity$1.Warning;
            case MarkerSeverity.Error:
                return DiagnosticSeverity$1.Error;
            case MarkerSeverity.Hint:
                return DiagnosticSeverity$1.Hint;
            default:
                return DiagnosticSeverity$1.Error;
        }
    }
    DiagnosticSeverity.to = to;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
var ViewColumn;
(function (ViewColumn) {
    function from(column) {
        if (typeof column === 'number' && column >= ViewColumn$1.One) {
            return column - 1;
        }
        if (column === ViewColumn$1.Beside) {
            return SIDE_GROUP;
        }
        return ACTIVE_GROUP;
    }
    ViewColumn.from = from;
    function to(position) {
        if (typeof position === 'number' && position >= 0) {
            return position + 1;
        }
        throw ( new Error(`invalid 'EditorGroupColumn'`));
    }
    ViewColumn.to = to;
})(ViewColumn || (ViewColumn = {}));
function isDecorationOptions(something) {
    return (typeof something.range !== 'undefined');
}
function isDecorationOptionsArr(something) {
    if (something.length === 0) {
        return true;
    }
    return isDecorationOptions(something[0]) ? true : false;
}
var MarkdownString;
(function (MarkdownString) {
    function fromMany(markup) {
        return ( markup.map(MarkdownString.from));
    }
    MarkdownString.fromMany = fromMany;
    function isCodeblock(thing) {
        return thing && typeof thing === 'object'
            && typeof thing.language === 'string'
            && typeof thing.value === 'string';
    }
    function from(markup) {
        let res;
        if (isCodeblock(markup)) {
            const { language, value } = markup;
            res = { value: '```' + language + '\n' + value + '\n```\n' };
        }
        else if (MarkdownString$1.isMarkdownString(markup)) {
            res = { value: markup.value, isTrusted: markup.isTrusted, supportThemeIcons: markup.supportThemeIcons, supportHtml: markup.supportHtml, baseUri: markup.baseUri };
        }
        else if (typeof markup === 'string') {
            res = { value: markup };
        }
        else {
            res = { value: '' };
        }
        const resUris = Object.create(null);
        res.uris = resUris;
        const collectUri = ({ href }) => {
            try {
                let uri = ( URI.parse(href, true));
                uri = uri.with({ query: _uriMassage(uri.query, resUris) });
                resUris[href] = uri;
            }
            catch (e) {
            }
            return '';
        };
        marked.walkTokens(marked.lexer(res.value), token => {
            if (token.type === 'link') {
                collectUri({ href: token.href });
            }
            else if (token.type === 'image') {
                if (typeof token.href === 'string') {
                    collectUri(parseHrefAndDimensions(token.href));
                }
            }
        });
        return res;
    }
    MarkdownString.from = from;
    function _uriMassage(part, bucket) {
        if (!part) {
            return part;
        }
        let data;
        try {
            data = parse(part);
        }
        catch (e) {
        }
        if (!data) {
            return part;
        }
        let changed = false;
        data = cloneAndChange(data, value => {
            if (URI.isUri(value)) {
                const key = `__uri_${( Math.random().toString(16)).slice(2, 8)}`;
                bucket[key] = value;
                changed = true;
                return key;
            }
            else {
                return undefined;
            }
        });
        if (!changed) {
            return part;
        }
        return JSON.stringify(data);
    }
    function to(value) {
        const result = new MarkdownString$1(value.value, value.supportThemeIcons);
        result.isTrusted = value.isTrusted;
        result.supportHtml = value.supportHtml;
        result.baseUri = value.baseUri ? ( URI.from(value.baseUri)) : undefined;
        return result;
    }
    MarkdownString.to = to;
    function fromStrict(value) {
        if (!value) {
            return undefined;
        }
        return typeof value === 'string' ? value : MarkdownString.from(value);
    }
    MarkdownString.fromStrict = fromStrict;
})(MarkdownString || (MarkdownString = {}));
function fromRangeOrRangeWithMessage(ranges) {
    if (isDecorationOptionsArr(ranges)) {
        return ( ranges.map((r) => {
            return {
                range: Range.from(r.range),
                hoverMessage: Array.isArray(r.hoverMessage)
                    ? MarkdownString.fromMany(r.hoverMessage)
                    : (r.hoverMessage ? MarkdownString.from(r.hoverMessage) : undefined),
                renderOptions:  r.renderOptions
            };
        }));
    }
    else {
        return ( ranges.map((r) => {
            return {
                range: Range.from(r)
            };
        }));
    }
}
function pathOrURIToURI(value) {
    if (typeof value === 'undefined') {
        return value;
    }
    if (typeof value === 'string') {
        return URI.file(value);
    }
    else {
        return value;
    }
}
var ThemableDecorationAttachmentRenderOptions;
(function (ThemableDecorationAttachmentRenderOptions) {
    function from(options) {
        if (typeof options === 'undefined') {
            return options;
        }
        return {
            contentText: options.contentText,
            contentIconPath: options.contentIconPath ? pathOrURIToURI(options.contentIconPath) : undefined,
            border: options.border,
            borderColor: options.borderColor,
            fontStyle: options.fontStyle,
            fontWeight: options.fontWeight,
            textDecoration: options.textDecoration,
            color: options.color,
            backgroundColor: options.backgroundColor,
            margin: options.margin,
            width: options.width,
            height: options.height,
        };
    }
    ThemableDecorationAttachmentRenderOptions.from = from;
})(ThemableDecorationAttachmentRenderOptions || (ThemableDecorationAttachmentRenderOptions = {}));
var ThemableDecorationRenderOptions;
(function (ThemableDecorationRenderOptions) {
    function from(options) {
        if (typeof options === 'undefined') {
            return options;
        }
        return {
            backgroundColor: options.backgroundColor,
            outline: options.outline,
            outlineColor: options.outlineColor,
            outlineStyle: options.outlineStyle,
            outlineWidth: options.outlineWidth,
            border: options.border,
            borderColor: options.borderColor,
            borderRadius: options.borderRadius,
            borderSpacing: options.borderSpacing,
            borderStyle: options.borderStyle,
            borderWidth: options.borderWidth,
            fontStyle: options.fontStyle,
            fontWeight: options.fontWeight,
            textDecoration: options.textDecoration,
            cursor: options.cursor,
            color: options.color,
            opacity: options.opacity,
            letterSpacing: options.letterSpacing,
            gutterIconPath: options.gutterIconPath ? pathOrURIToURI(options.gutterIconPath) : undefined,
            gutterIconSize: options.gutterIconSize,
            overviewRulerColor: options.overviewRulerColor,
            before: options.before ? ThemableDecorationAttachmentRenderOptions.from(options.before) : undefined,
            after: options.after ? ThemableDecorationAttachmentRenderOptions.from(options.after) : undefined,
        };
    }
    ThemableDecorationRenderOptions.from = from;
})(ThemableDecorationRenderOptions || (ThemableDecorationRenderOptions = {}));
var DecorationRangeBehavior;
(function (DecorationRangeBehavior) {
    function from(value) {
        if (typeof value === 'undefined') {
            return value;
        }
        switch (value) {
            case DecorationRangeBehavior$1.OpenOpen:
                return TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges;
            case DecorationRangeBehavior$1.ClosedClosed:
                return TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges;
            case DecorationRangeBehavior$1.OpenClosed:
                return TrackedRangeStickiness.GrowsOnlyWhenTypingBefore;
            case DecorationRangeBehavior$1.ClosedOpen:
                return TrackedRangeStickiness.GrowsOnlyWhenTypingAfter;
        }
    }
    DecorationRangeBehavior.from = from;
})(DecorationRangeBehavior || (DecorationRangeBehavior = {}));
var DecorationRenderOptions;
(function (DecorationRenderOptions) {
    function from(options) {
        return {
            isWholeLine: options.isWholeLine,
            rangeBehavior: options.rangeBehavior ? DecorationRangeBehavior.from(options.rangeBehavior) : undefined,
            overviewRulerLane: options.overviewRulerLane,
            light: options.light ? ThemableDecorationRenderOptions.from(options.light) : undefined,
            dark: options.dark ? ThemableDecorationRenderOptions.from(options.dark) : undefined,
            backgroundColor: options.backgroundColor,
            outline: options.outline,
            outlineColor: options.outlineColor,
            outlineStyle: options.outlineStyle,
            outlineWidth: options.outlineWidth,
            border: options.border,
            borderColor: options.borderColor,
            borderRadius: options.borderRadius,
            borderSpacing: options.borderSpacing,
            borderStyle: options.borderStyle,
            borderWidth: options.borderWidth,
            fontStyle: options.fontStyle,
            fontWeight: options.fontWeight,
            textDecoration: options.textDecoration,
            cursor: options.cursor,
            color: options.color,
            opacity: options.opacity,
            letterSpacing: options.letterSpacing,
            gutterIconPath: options.gutterIconPath ? pathOrURIToURI(options.gutterIconPath) : undefined,
            gutterIconSize: options.gutterIconSize,
            overviewRulerColor: options.overviewRulerColor,
            before: options.before ? ThemableDecorationAttachmentRenderOptions.from(options.before) : undefined,
            after: options.after ? ThemableDecorationAttachmentRenderOptions.from(options.after) : undefined,
        };
    }
    DecorationRenderOptions.from = from;
})(DecorationRenderOptions || (DecorationRenderOptions = {}));
var TextEdit;
(function (TextEdit) {
    function from(edit) {
        return {
            text: edit.newText,
            eol: edit.newEol && EndOfLine.from(edit.newEol),
            range: Range.from(edit.range)
        };
    }
    TextEdit.from = from;
    function to(edit) {
        const result = new TextEdit$1(Range.to(edit.range), edit.text);
        result.newEol = (typeof edit.eol === 'undefined' ? undefined : EndOfLine.to(edit.eol));
        return result;
    }
    TextEdit.to = to;
})(TextEdit || (TextEdit = {}));
var WorkspaceEdit;
(function (WorkspaceEdit) {
    function from(value, versionInfo) {
        const result = {
            edits: []
        };
        if (value instanceof WorkspaceEdit$1) {
            const toCreate = ( new ResourceSet());
            for (const entry of value._allEntries()) {
                if (entry._type === FileEditType.File && URI.isUri(entry.to) && entry.from === undefined) {
                    toCreate.add(entry.to);
                }
            }
            for (const entry of value._allEntries()) {
                if (entry._type === FileEditType.File) {
                    let contents;
                    if (entry.options?.contents) {
                        if (ArrayBuffer.isView(entry.options.contents)) {
                            contents = { type: 'base64', value: encodeBase64(VSBuffer.wrap(entry.options.contents)) };
                        }
                        else {
                            contents = { type: 'dataTransferItem', id: entry.options.contents._itemId };
                        }
                    }
                    result.edits.push({
                        oldResource: entry.from,
                        newResource: entry.to,
                        options: { ...entry.options, contents },
                        metadata: entry.metadata
                    });
                }
                else if (entry._type === FileEditType.Text) {
                    result.edits.push({
                        resource: entry.uri,
                        textEdit: TextEdit.from(entry.edit),
                        versionId: !( toCreate.has(entry.uri)) ? versionInfo?.getTextDocumentVersion(entry.uri) : undefined,
                        metadata: entry.metadata
                    });
                }
                else if (entry._type === FileEditType.Snippet) {
                    result.edits.push({
                        resource: entry.uri,
                        textEdit: {
                            range: Range.from(entry.range),
                            text: entry.edit.value,
                            insertAsSnippet: true,
                            keepWhitespace: entry.keepWhitespace
                        },
                        versionId: !( toCreate.has(entry.uri)) ? versionInfo?.getTextDocumentVersion(entry.uri) : undefined,
                        metadata: entry.metadata
                    });
                }
                else if (entry._type === FileEditType.Cell) {
                    result.edits.push({
                        metadata: entry.metadata,
                        resource: entry.uri,
                        cellEdit: entry.edit,
                        notebookVersionId: versionInfo?.getNotebookDocumentVersion(entry.uri)
                    });
                }
                else if (entry._type === FileEditType.CellReplace) {
                    result.edits.push({
                        metadata: entry.metadata,
                        resource: entry.uri,
                        notebookVersionId: versionInfo?.getNotebookDocumentVersion(entry.uri),
                        cellEdit: {
                            editType: CellEditType.Replace,
                            index: entry.index,
                            count: entry.count,
                            cells: ( entry.cells.map(NotebookCellData.from))
                        }
                    });
                }
            }
        }
        return result;
    }
    WorkspaceEdit.from = from;
    function to(value) {
        const result = new WorkspaceEdit$1();
        const edits = ( new ResourceMap());
        for (const edit of value.edits) {
            if (edit.textEdit) {
                const item = edit;
                const uri = URI.revive(item.resource);
                const range = Range.to(item.textEdit.range);
                const text = item.textEdit.text;
                const isSnippet = item.textEdit.insertAsSnippet;
                let editOrSnippetTest;
                if (isSnippet) {
                    editOrSnippetTest = SnippetTextEdit.replace(range, new SnippetString(text));
                }
                else {
                    editOrSnippetTest = TextEdit$1.replace(range, text);
                }
                const array = edits.get(uri);
                if (!array) {
                    edits.set(uri, [editOrSnippetTest]);
                }
                else {
                    array.push(editOrSnippetTest);
                }
            }
            else {
                result.renameFile(URI.revive(edit.oldResource), URI.revive(edit.newResource), edit.options);
            }
        }
        for (const [uri, array] of edits) {
            result.set(uri, array);
        }
        return result;
    }
    WorkspaceEdit.to = to;
})(WorkspaceEdit || (WorkspaceEdit = {}));
var SymbolKind;
(function (SymbolKind) {
    const _fromMapping = Object.create(null);
    _fromMapping[SymbolKind$2.File] = SymbolKind$1.File;
    _fromMapping[SymbolKind$2.Module] = SymbolKind$1.Module;
    _fromMapping[SymbolKind$2.Namespace] = SymbolKind$1.Namespace;
    _fromMapping[SymbolKind$2.Package] = SymbolKind$1.Package;
    _fromMapping[SymbolKind$2.Class] = SymbolKind$1.Class;
    _fromMapping[SymbolKind$2.Method] = SymbolKind$1.Method;
    _fromMapping[SymbolKind$2.Property] = SymbolKind$1.Property;
    _fromMapping[SymbolKind$2.Field] = SymbolKind$1.Field;
    _fromMapping[SymbolKind$2.Constructor] = SymbolKind$1.Constructor;
    _fromMapping[SymbolKind$2.Enum] = SymbolKind$1.Enum;
    _fromMapping[SymbolKind$2.Interface] = SymbolKind$1.Interface;
    _fromMapping[SymbolKind$2.Function] = SymbolKind$1.Function;
    _fromMapping[SymbolKind$2.Variable] = SymbolKind$1.Variable;
    _fromMapping[SymbolKind$2.Constant] = SymbolKind$1.Constant;
    _fromMapping[SymbolKind$2.String] = SymbolKind$1.String;
    _fromMapping[SymbolKind$2.Number] = SymbolKind$1.Number;
    _fromMapping[SymbolKind$2.Boolean] = SymbolKind$1.Boolean;
    _fromMapping[SymbolKind$2.Array] = SymbolKind$1.Array;
    _fromMapping[SymbolKind$2.Object] = SymbolKind$1.Object;
    _fromMapping[SymbolKind$2.Key] = SymbolKind$1.Key;
    _fromMapping[SymbolKind$2.Null] = SymbolKind$1.Null;
    _fromMapping[SymbolKind$2.EnumMember] = SymbolKind$1.EnumMember;
    _fromMapping[SymbolKind$2.Struct] = SymbolKind$1.Struct;
    _fromMapping[SymbolKind$2.Event] = SymbolKind$1.Event;
    _fromMapping[SymbolKind$2.Operator] = SymbolKind$1.Operator;
    _fromMapping[SymbolKind$2.TypeParameter] = SymbolKind$1.TypeParameter;
    function from(kind) {
        return typeof _fromMapping[kind] === 'number' ? _fromMapping[kind] : SymbolKind$1.Property;
    }
    SymbolKind.from = from;
    function to(kind) {
        for (const k in _fromMapping) {
            if (_fromMapping[k] === kind) {
                return Number(k);
            }
        }
        return SymbolKind$2.Property;
    }
    SymbolKind.to = to;
})(SymbolKind || (SymbolKind = {}));
var SymbolTag;
(function (SymbolTag) {
    function from(kind) {
        switch (kind) {
            case SymbolTag$1.Deprecated: return SymbolTag$2.Deprecated;
        }
    }
    SymbolTag.from = from;
    function to(kind) {
        switch (kind) {
            case SymbolTag$2.Deprecated: return SymbolTag$1.Deprecated;
        }
    }
    SymbolTag.to = to;
})(SymbolTag || (SymbolTag = {}));
var WorkspaceSymbol;
(function (WorkspaceSymbol) {
    function from(info) {
        return {
            name: info.name,
            kind: SymbolKind.from(info.kind),
            tags: info.tags && ( info.tags.map(SymbolTag.from)),
            containerName: info.containerName,
            location: location.from(info.location)
        };
    }
    WorkspaceSymbol.from = from;
    function to(info) {
        const result = new SymbolInformation(info.name, SymbolKind.to(info.kind), info.containerName, location.to(info.location));
        result.tags = info.tags && ( info.tags.map(SymbolTag.to));
        return result;
    }
    WorkspaceSymbol.to = to;
})(WorkspaceSymbol || (WorkspaceSymbol = {}));
var DocumentSymbol;
(function (DocumentSymbol) {
    function from(info) {
        const result = {
            name: info.name || '!!MISSING: name!!',
            detail: info.detail,
            range: Range.from(info.range),
            selectionRange: Range.from(info.selectionRange),
            kind: SymbolKind.from(info.kind),
            tags: info.tags?.map(SymbolTag.from) ?? []
        };
        if (info.children) {
            result.children = ( info.children.map(from));
        }
        return result;
    }
    DocumentSymbol.from = from;
    function to(info) {
        const result = new DocumentSymbol$1(info.name, info.detail, SymbolKind.to(info.kind), Range.to(info.range), Range.to(info.selectionRange));
        if (isNonEmptyArray(info.tags)) {
            result.tags = ( info.tags.map(SymbolTag.to));
        }
        if (info.children) {
            result.children = ( info.children.map(to));
        }
        return result;
    }
    DocumentSymbol.to = to;
})(DocumentSymbol || (DocumentSymbol = {}));
var CallHierarchyItem;
(function (CallHierarchyItem) {
    function to(item) {
        const result = new CallHierarchyItem$1(SymbolKind.to(item.kind), item.name, item.detail || '', URI.revive(item.uri), Range.to(item.range), Range.to(item.selectionRange));
        result._sessionId = item._sessionId;
        result._itemId = item._itemId;
        return result;
    }
    CallHierarchyItem.to = to;
    function from(item, sessionId, itemId) {
        sessionId = sessionId ?? item._sessionId;
        itemId = itemId ?? item._itemId;
        if (sessionId === undefined || itemId === undefined) {
            throw ( new Error('invalid item'));
        }
        return {
            _sessionId: sessionId,
            _itemId: itemId,
            name: item.name,
            detail: item.detail,
            kind: SymbolKind.from(item.kind),
            uri: item.uri,
            range: Range.from(item.range),
            selectionRange: Range.from(item.selectionRange),
            tags: item.tags?.map(SymbolTag.from)
        };
    }
    CallHierarchyItem.from = from;
})(CallHierarchyItem || (CallHierarchyItem = {}));
var CallHierarchyIncomingCall;
(function (CallHierarchyIncomingCall) {
    function to(item) {
        return new CallHierarchyIncomingCall$1(CallHierarchyItem.to(item.from), ( item.fromRanges.map(r => Range.to(r))));
    }
    CallHierarchyIncomingCall.to = to;
})(CallHierarchyIncomingCall || (CallHierarchyIncomingCall = {}));
var CallHierarchyOutgoingCall;
(function (CallHierarchyOutgoingCall) {
    function to(item) {
        return new CallHierarchyOutgoingCall$1(CallHierarchyItem.to(item.to), ( item.fromRanges.map(r => Range.to(r))));
    }
    CallHierarchyOutgoingCall.to = to;
})(CallHierarchyOutgoingCall || (CallHierarchyOutgoingCall = {}));
var location;
(function (location) {
    function from(value) {
        return {
            range: value.range && Range.from(value.range),
            uri: value.uri
        };
    }
    location.from = from;
    function to(value) {
        return new Location$1(URI.revive(value.uri), Range.to(value.range));
    }
    location.to = to;
})(location || (location = {}));
var DefinitionLink;
(function (DefinitionLink) {
    function from(value) {
        const definitionLink = value;
        const location = value;
        return {
            originSelectionRange: definitionLink.originSelectionRange
                ? Range.from(definitionLink.originSelectionRange)
                : undefined,
            uri: definitionLink.targetUri ? definitionLink.targetUri : location.uri,
            range: Range.from(definitionLink.targetRange ? definitionLink.targetRange : location.range),
            targetSelectionRange: definitionLink.targetSelectionRange
                ? Range.from(definitionLink.targetSelectionRange)
                : undefined,
        };
    }
    DefinitionLink.from = from;
    function to(value) {
        return {
            targetUri: URI.revive(value.uri),
            targetRange: Range.to(value.range),
            targetSelectionRange: value.targetSelectionRange
                ? Range.to(value.targetSelectionRange)
                : undefined,
            originSelectionRange: value.originSelectionRange
                ? Range.to(value.originSelectionRange)
                : undefined
        };
    }
    DefinitionLink.to = to;
})(DefinitionLink || (DefinitionLink = {}));
var Hover;
(function (Hover) {
    function from(hover) {
        const convertedHover = {
            range: Range.from(hover.range),
            contents: MarkdownString.fromMany(hover.contents),
            canIncreaseVerbosity: hover.canIncreaseVerbosity,
            canDecreaseVerbosity: hover.canDecreaseVerbosity,
        };
        return convertedHover;
    }
    Hover.from = from;
    function to(info) {
        const contents = ( info.contents.map(MarkdownString.to));
        const range = Range.to(info.range);
        const canIncreaseVerbosity = info.canIncreaseVerbosity;
        const canDecreaseVerbosity = info.canDecreaseVerbosity;
        return new VerboseHover(contents, range, canIncreaseVerbosity, canDecreaseVerbosity);
    }
    Hover.to = to;
})(Hover || (Hover = {}));
var EvaluatableExpression;
(function (EvaluatableExpression) {
    function from(expression) {
        return {
            range: Range.from(expression.range),
            expression: expression.expression
        };
    }
    EvaluatableExpression.from = from;
    function to(info) {
        return new EvaluatableExpression$1(Range.to(info.range), info.expression);
    }
    EvaluatableExpression.to = to;
})(EvaluatableExpression || (EvaluatableExpression = {}));
var InlineValue;
(function (InlineValue) {
    function from(inlineValue) {
        if (inlineValue instanceof InlineValueText) {
            return {
                type: 'text',
                range: Range.from(inlineValue.range),
                text: inlineValue.text
            };
        }
        else if (inlineValue instanceof InlineValueVariableLookup) {
            return {
                type: 'variable',
                range: Range.from(inlineValue.range),
                variableName: inlineValue.variableName,
                caseSensitiveLookup: inlineValue.caseSensitiveLookup
            };
        }
        else if (inlineValue instanceof InlineValueEvaluatableExpression) {
            return {
                type: 'expression',
                range: Range.from(inlineValue.range),
                expression: inlineValue.expression
            };
        }
        else {
            throw ( new Error(`Unknown 'InlineValue' type`));
        }
    }
    InlineValue.from = from;
    function to(inlineValue) {
        switch (inlineValue.type) {
            case 'text':
                return {
                    range: Range.to(inlineValue.range),
                    text: inlineValue.text
                };
            case 'variable':
                return {
                    range: Range.to(inlineValue.range),
                    variableName: inlineValue.variableName,
                    caseSensitiveLookup: inlineValue.caseSensitiveLookup
                };
            case 'expression':
                return {
                    range: Range.to(inlineValue.range),
                    expression: inlineValue.expression
                };
        }
    }
    InlineValue.to = to;
})(InlineValue || (InlineValue = {}));
var InlineValueContext;
(function (InlineValueContext) {
    function from(inlineValueContext) {
        return {
            frameId: inlineValueContext.frameId,
            stoppedLocation: Range.from(inlineValueContext.stoppedLocation)
        };
    }
    InlineValueContext.from = from;
    function to(inlineValueContext) {
        return new InlineValueContext$1(inlineValueContext.frameId, Range.to(inlineValueContext.stoppedLocation));
    }
    InlineValueContext.to = to;
})(InlineValueContext || (InlineValueContext = {}));
var DocumentHighlight;
(function (DocumentHighlight) {
    function from(documentHighlight) {
        return {
            range: Range.from(documentHighlight.range),
            kind: documentHighlight.kind
        };
    }
    DocumentHighlight.from = from;
    function to(occurrence) {
        return new DocumentHighlight$1(Range.to(occurrence.range), occurrence.kind);
    }
    DocumentHighlight.to = to;
})(DocumentHighlight || (DocumentHighlight = {}));
var MultiDocumentHighlight;
(function (MultiDocumentHighlight) {
    function from(multiDocumentHighlight) {
        return {
            uri: multiDocumentHighlight.uri,
            highlights: ( multiDocumentHighlight.highlights.map(DocumentHighlight.from))
        };
    }
    MultiDocumentHighlight.from = from;
    function to(multiDocumentHighlight) {
        return new MultiDocumentHighlight$1(URI.revive(multiDocumentHighlight.uri), ( multiDocumentHighlight.highlights.map(DocumentHighlight.to)));
    }
    MultiDocumentHighlight.to = to;
})(MultiDocumentHighlight || (MultiDocumentHighlight = {}));
var CompletionTriggerKind;
(function (CompletionTriggerKind) {
    function to(kind) {
        switch (kind) {
            case CompletionTriggerKind$2.TriggerCharacter:
                return CompletionTriggerKind$1.TriggerCharacter;
            case CompletionTriggerKind$2.TriggerForIncompleteCompletions:
                return CompletionTriggerKind$1.TriggerForIncompleteCompletions;
            case CompletionTriggerKind$2.Invoke:
            default:
                return CompletionTriggerKind$1.Invoke;
        }
    }
    CompletionTriggerKind.to = to;
})(CompletionTriggerKind || (CompletionTriggerKind = {}));
var CompletionContext;
(function (CompletionContext) {
    function to(context) {
        return {
            triggerKind: CompletionTriggerKind.to(context.triggerKind),
            triggerCharacter: context.triggerCharacter
        };
    }
    CompletionContext.to = to;
})(CompletionContext || (CompletionContext = {}));
var CompletionItemTag;
(function (CompletionItemTag) {
    function from(kind) {
        switch (kind) {
            case CompletionItemTag$1.Deprecated: return CompletionItemTag$2.Deprecated;
        }
    }
    CompletionItemTag.from = from;
    function to(kind) {
        switch (kind) {
            case CompletionItemTag$2.Deprecated: return CompletionItemTag$1.Deprecated;
        }
    }
    CompletionItemTag.to = to;
})(CompletionItemTag || (CompletionItemTag = {}));
var CompletionItemKind;
(function (CompletionItemKind) {
    const _from = ( new Map([
        [CompletionItemKind$1.Method, CompletionItemKind$2.Method],
        [CompletionItemKind$1.Function, CompletionItemKind$2.Function],
        [CompletionItemKind$1.Constructor, CompletionItemKind$2.Constructor],
        [CompletionItemKind$1.Field, CompletionItemKind$2.Field],
        [CompletionItemKind$1.Variable, CompletionItemKind$2.Variable],
        [CompletionItemKind$1.Class, CompletionItemKind$2.Class],
        [CompletionItemKind$1.Interface, CompletionItemKind$2.Interface],
        [CompletionItemKind$1.Struct, CompletionItemKind$2.Struct],
        [CompletionItemKind$1.Module, CompletionItemKind$2.Module],
        [CompletionItemKind$1.Property, CompletionItemKind$2.Property],
        [CompletionItemKind$1.Unit, CompletionItemKind$2.Unit],
        [CompletionItemKind$1.Value, CompletionItemKind$2.Value],
        [CompletionItemKind$1.Constant, CompletionItemKind$2.Constant],
        [CompletionItemKind$1.Enum, CompletionItemKind$2.Enum],
        [CompletionItemKind$1.EnumMember, CompletionItemKind$2.EnumMember],
        [CompletionItemKind$1.Keyword, CompletionItemKind$2.Keyword],
        [CompletionItemKind$1.Snippet, CompletionItemKind$2.Snippet],
        [CompletionItemKind$1.Text, CompletionItemKind$2.Text],
        [CompletionItemKind$1.Color, CompletionItemKind$2.Color],
        [CompletionItemKind$1.File, CompletionItemKind$2.File],
        [CompletionItemKind$1.Reference, CompletionItemKind$2.Reference],
        [CompletionItemKind$1.Folder, CompletionItemKind$2.Folder],
        [CompletionItemKind$1.Event, CompletionItemKind$2.Event],
        [CompletionItemKind$1.Operator, CompletionItemKind$2.Operator],
        [CompletionItemKind$1.TypeParameter, CompletionItemKind$2.TypeParameter],
        [CompletionItemKind$1.Issue, CompletionItemKind$2.Issue],
        [CompletionItemKind$1.User, CompletionItemKind$2.User],
    ]));
    function from(kind) {
        return _from.get(kind) ?? CompletionItemKind$2.Property;
    }
    CompletionItemKind.from = from;
    const _to = ( new Map([
        [CompletionItemKind$2.Method, CompletionItemKind$1.Method],
        [CompletionItemKind$2.Function, CompletionItemKind$1.Function],
        [CompletionItemKind$2.Constructor, CompletionItemKind$1.Constructor],
        [CompletionItemKind$2.Field, CompletionItemKind$1.Field],
        [CompletionItemKind$2.Variable, CompletionItemKind$1.Variable],
        [CompletionItemKind$2.Class, CompletionItemKind$1.Class],
        [CompletionItemKind$2.Interface, CompletionItemKind$1.Interface],
        [CompletionItemKind$2.Struct, CompletionItemKind$1.Struct],
        [CompletionItemKind$2.Module, CompletionItemKind$1.Module],
        [CompletionItemKind$2.Property, CompletionItemKind$1.Property],
        [CompletionItemKind$2.Unit, CompletionItemKind$1.Unit],
        [CompletionItemKind$2.Value, CompletionItemKind$1.Value],
        [CompletionItemKind$2.Constant, CompletionItemKind$1.Constant],
        [CompletionItemKind$2.Enum, CompletionItemKind$1.Enum],
        [CompletionItemKind$2.EnumMember, CompletionItemKind$1.EnumMember],
        [CompletionItemKind$2.Keyword, CompletionItemKind$1.Keyword],
        [CompletionItemKind$2.Snippet, CompletionItemKind$1.Snippet],
        [CompletionItemKind$2.Text, CompletionItemKind$1.Text],
        [CompletionItemKind$2.Color, CompletionItemKind$1.Color],
        [CompletionItemKind$2.File, CompletionItemKind$1.File],
        [CompletionItemKind$2.Reference, CompletionItemKind$1.Reference],
        [CompletionItemKind$2.Folder, CompletionItemKind$1.Folder],
        [CompletionItemKind$2.Event, CompletionItemKind$1.Event],
        [CompletionItemKind$2.Operator, CompletionItemKind$1.Operator],
        [CompletionItemKind$2.TypeParameter, CompletionItemKind$1.TypeParameter],
        [CompletionItemKind$2.User, CompletionItemKind$1.User],
        [CompletionItemKind$2.Issue, CompletionItemKind$1.Issue],
    ]));
    function to(kind) {
        return _to.get(kind) ?? CompletionItemKind$1.Property;
    }
    CompletionItemKind.to = to;
})(CompletionItemKind || (CompletionItemKind = {}));
var CompletionItem;
(function (CompletionItem) {
    function to(suggestion, converter) {
        const result = new CompletionItem$1(suggestion.label);
        result.insertText = suggestion.insertText;
        result.kind = CompletionItemKind.to(suggestion.kind);
        result.tags = suggestion.tags?.map(CompletionItemTag.to);
        result.detail = suggestion.detail;
        result.documentation = isMarkdownString(suggestion.documentation) ? MarkdownString.to(suggestion.documentation) : suggestion.documentation;
        result.sortText = suggestion.sortText;
        result.filterText = suggestion.filterText;
        result.preselect = suggestion.preselect;
        result.commitCharacters = suggestion.commitCharacters;
        if (Range$2.isIRange(suggestion.range)) {
            result.range = Range.to(suggestion.range);
        }
        else if (typeof suggestion.range === 'object') {
            result.range = { inserting: Range.to(suggestion.range.insert), replacing: Range.to(suggestion.range.replace) };
        }
        result.keepWhitespace = typeof suggestion.insertTextRules === 'undefined' ? false : Boolean(suggestion.insertTextRules & CompletionItemInsertTextRule.KeepWhitespace);
        if (typeof suggestion.insertTextRules !== 'undefined' && suggestion.insertTextRules & CompletionItemInsertTextRule.InsertAsSnippet) {
            result.insertText = new SnippetString(suggestion.insertText);
        }
        else {
            result.insertText = suggestion.insertText;
            result.textEdit = result.range instanceof Range$1 ? new TextEdit$1(result.range, result.insertText) : undefined;
        }
        if (suggestion.additionalTextEdits && suggestion.additionalTextEdits.length > 0) {
            result.additionalTextEdits = ( suggestion.additionalTextEdits.map(e => TextEdit.to(e)));
        }
        result.command = converter && suggestion.command ? converter.fromInternal(suggestion.command) : undefined;
        return result;
    }
    CompletionItem.to = to;
})(CompletionItem || (CompletionItem = {}));
var ParameterInformation;
(function (ParameterInformation) {
    function from(info) {
        if (typeof info.label !== 'string' && !Array.isArray(info.label)) {
            throw ( new TypeError('Invalid label'));
        }
        return {
            label: info.label,
            documentation: MarkdownString.fromStrict(info.documentation)
        };
    }
    ParameterInformation.from = from;
    function to(info) {
        return {
            label: info.label,
            documentation: isMarkdownString(info.documentation) ? MarkdownString.to(info.documentation) : info.documentation
        };
    }
    ParameterInformation.to = to;
})(ParameterInformation || (ParameterInformation = {}));
var SignatureInformation;
(function (SignatureInformation) {
    function from(info) {
        return {
            label: info.label,
            documentation: MarkdownString.fromStrict(info.documentation),
            parameters: Array.isArray(info.parameters) ? ( info.parameters.map(ParameterInformation.from)) : [],
            activeParameter: info.activeParameter,
        };
    }
    SignatureInformation.from = from;
    function to(info) {
        return {
            label: info.label,
            documentation: isMarkdownString(info.documentation) ? MarkdownString.to(info.documentation) : info.documentation,
            parameters: Array.isArray(info.parameters) ? ( info.parameters.map(ParameterInformation.to)) : [],
            activeParameter: info.activeParameter,
        };
    }
    SignatureInformation.to = to;
})(SignatureInformation || (SignatureInformation = {}));
var SignatureHelp;
(function (SignatureHelp) {
    function from(help) {
        return {
            activeSignature: help.activeSignature,
            activeParameter: help.activeParameter,
            signatures: Array.isArray(help.signatures) ? ( help.signatures.map(SignatureInformation.from)) : [],
        };
    }
    SignatureHelp.from = from;
    function to(help) {
        return {
            activeSignature: help.activeSignature,
            activeParameter: help.activeParameter,
            signatures: Array.isArray(help.signatures) ? ( help.signatures.map(SignatureInformation.to)) : [],
        };
    }
    SignatureHelp.to = to;
})(SignatureHelp || (SignatureHelp = {}));
var InlayHint;
(function (InlayHint) {
    function to(converter, hint) {
        const res = new InlayHint$1(Position.to(hint.position), typeof hint.label === 'string' ? hint.label : ( hint.label.map(InlayHintLabelPart.to.bind(undefined, converter))), hint.kind && InlayHintKind.to(hint.kind));
        res.textEdits = hint.textEdits && ( hint.textEdits.map(TextEdit.to));
        res.tooltip = isMarkdownString(hint.tooltip) ? MarkdownString.to(hint.tooltip) : hint.tooltip;
        res.paddingLeft = hint.paddingLeft;
        res.paddingRight = hint.paddingRight;
        return res;
    }
    InlayHint.to = to;
})(InlayHint || (InlayHint = {}));
var InlayHintLabelPart;
(function (InlayHintLabelPart) {
    function to(converter, part) {
        const result = new InlayHintLabelPart$1(part.label);
        result.tooltip = isMarkdownString(part.tooltip)
            ? MarkdownString.to(part.tooltip)
            : part.tooltip;
        if (Command.is(part.command)) {
            result.command = converter.fromInternal(part.command);
        }
        if (part.location) {
            result.location = location.to(part.location);
        }
        return result;
    }
    InlayHintLabelPart.to = to;
})(InlayHintLabelPart || (InlayHintLabelPart = {}));
var InlayHintKind;
(function (InlayHintKind) {
    function from(kind) {
        return kind;
    }
    InlayHintKind.from = from;
    function to(kind) {
        return kind;
    }
    InlayHintKind.to = to;
})(InlayHintKind || (InlayHintKind = {}));
var DocumentLink;
(function (DocumentLink) {
    function from(link) {
        return {
            range: Range.from(link.range),
            url: link.target,
            tooltip: link.tooltip
        };
    }
    DocumentLink.from = from;
    function to(link) {
        let target = undefined;
        if (link.url) {
            try {
                target = typeof link.url === 'string' ? ( URI.parse(link.url, true)) : URI.revive(link.url);
            }
            catch (err) {
            }
        }
        const result = new DocumentLink$1(Range.to(link.range), target);
        result.tooltip = link.tooltip;
        return result;
    }
    DocumentLink.to = to;
})(DocumentLink || (DocumentLink = {}));
var ColorPresentation;
(function (ColorPresentation) {
    function to(colorPresentation) {
        const cp = new ColorPresentation$1(colorPresentation.label);
        if (colorPresentation.textEdit) {
            cp.textEdit = TextEdit.to(colorPresentation.textEdit);
        }
        if (colorPresentation.additionalTextEdits) {
            cp.additionalTextEdits = ( colorPresentation.additionalTextEdits.map(value => TextEdit.to(value)));
        }
        return cp;
    }
    ColorPresentation.to = to;
    function from(colorPresentation) {
        return {
            label: colorPresentation.label,
            textEdit: colorPresentation.textEdit ? TextEdit.from(colorPresentation.textEdit) : undefined,
            additionalTextEdits: colorPresentation.additionalTextEdits ? ( colorPresentation.additionalTextEdits.map(value => TextEdit.from(value))) : undefined
        };
    }
    ColorPresentation.from = from;
})(ColorPresentation || (ColorPresentation = {}));
var Color;
(function (Color) {
    function to(c) {
        return new Color$1(c[0], c[1], c[2], c[3]);
    }
    Color.to = to;
    function from(color) {
        return [color.red, color.green, color.blue, color.alpha];
    }
    Color.from = from;
})(Color || (Color = {}));
var SelectionRange;
(function (SelectionRange) {
    function from(obj) {
        return { range: Range.from(obj.range) };
    }
    SelectionRange.from = from;
    function to(obj) {
        return new SelectionRange$1(Range.to(obj.range));
    }
    SelectionRange.to = to;
})(SelectionRange || (SelectionRange = {}));
var TextDocumentSaveReason;
(function (TextDocumentSaveReason) {
    function to(reason) {
        switch (reason) {
            case SaveReason.AUTO:
                return TextDocumentSaveReason$1.AfterDelay;
            case SaveReason.EXPLICIT:
                return TextDocumentSaveReason$1.Manual;
            case SaveReason.FOCUS_CHANGE:
            case SaveReason.WINDOW_CHANGE:
                return TextDocumentSaveReason$1.FocusOut;
        }
    }
    TextDocumentSaveReason.to = to;
})(TextDocumentSaveReason || (TextDocumentSaveReason = {}));
var TextEditorLineNumbersStyle;
(function (TextEditorLineNumbersStyle) {
    function from(style) {
        switch (style) {
            case TextEditorLineNumbersStyle$1.Off:
                return RenderLineNumbersType.Off;
            case TextEditorLineNumbersStyle$1.Relative:
                return RenderLineNumbersType.Relative;
            case TextEditorLineNumbersStyle$1.Interval:
                return RenderLineNumbersType.Interval;
            case TextEditorLineNumbersStyle$1.On:
            default:
                return RenderLineNumbersType.On;
        }
    }
    TextEditorLineNumbersStyle.from = from;
    function to(style) {
        switch (style) {
            case RenderLineNumbersType.Off:
                return TextEditorLineNumbersStyle$1.Off;
            case RenderLineNumbersType.Relative:
                return TextEditorLineNumbersStyle$1.Relative;
            case RenderLineNumbersType.Interval:
                return TextEditorLineNumbersStyle$1.Interval;
            case RenderLineNumbersType.On:
            default:
                return TextEditorLineNumbersStyle$1.On;
        }
    }
    TextEditorLineNumbersStyle.to = to;
})(TextEditorLineNumbersStyle || (TextEditorLineNumbersStyle = {}));
var EndOfLine;
(function (EndOfLine) {
    function from(eol) {
        if (eol === EndOfLine$1.CRLF) {
            return EndOfLineSequence.CRLF;
        }
        else if (eol === EndOfLine$1.LF) {
            return EndOfLineSequence.LF;
        }
        return undefined;
    }
    EndOfLine.from = from;
    function to(eol) {
        if (eol === EndOfLineSequence.CRLF) {
            return EndOfLine$1.CRLF;
        }
        else if (eol === EndOfLineSequence.LF) {
            return EndOfLine$1.LF;
        }
        return undefined;
    }
    EndOfLine.to = to;
})(EndOfLine || (EndOfLine = {}));
var ProgressLocation;
(function (ProgressLocation) {
    function from(loc) {
        if (typeof loc === 'object') {
            return loc.viewId;
        }
        switch (loc) {
            case ProgressLocation$1.SourceControl: return ProgressLocation$2.Scm;
            case ProgressLocation$1.Window: return ProgressLocation$2.Window;
            case ProgressLocation$1.Notification: return ProgressLocation$2.Notification;
        }
        throw ( new Error(`Unknown 'ProgressLocation'`));
    }
    ProgressLocation.from = from;
})(ProgressLocation || (ProgressLocation = {}));
var FoldingRange;
(function (FoldingRange) {
    function from(r) {
        const range = { start: r.start + 1, end: r.end + 1 };
        if (r.kind) {
            range.kind = FoldingRangeKind.from(r.kind);
        }
        return range;
    }
    FoldingRange.from = from;
    function to(r) {
        const range = { start: r.start - 1, end: r.end - 1 };
        if (r.kind) {
            range.kind = FoldingRangeKind.to(r.kind);
        }
        return range;
    }
    FoldingRange.to = to;
})(FoldingRange || (FoldingRange = {}));
var FoldingRangeKind;
(function (FoldingRangeKind) {
    function from(kind) {
        if (kind) {
            switch (kind) {
                case FoldingRangeKind$1.Comment:
                    return FoldingRangeKind$2.Comment;
                case FoldingRangeKind$1.Imports:
                    return FoldingRangeKind$2.Imports;
                case FoldingRangeKind$1.Region:
                    return FoldingRangeKind$2.Region;
            }
        }
        return undefined;
    }
    FoldingRangeKind.from = from;
    function to(kind) {
        if (kind) {
            switch (kind.value) {
                case FoldingRangeKind$2.Comment.value:
                    return FoldingRangeKind$1.Comment;
                case FoldingRangeKind$2.Imports.value:
                    return FoldingRangeKind$1.Imports;
                case FoldingRangeKind$2.Region.value:
                    return FoldingRangeKind$1.Region;
            }
        }
        return undefined;
    }
    FoldingRangeKind.to = to;
})(FoldingRangeKind || (FoldingRangeKind = {}));
var TextEditorOpenOptions;
(function (TextEditorOpenOptions) {
    function from(options) {
        if (options) {
            return {
                pinned: typeof options.preview === 'boolean' ? !options.preview : undefined,
                inactive: options.background,
                preserveFocus: options.preserveFocus,
                selection: typeof options.selection === 'object' ? Range.from(options.selection) : undefined,
                override: typeof options.override === 'boolean' ? DEFAULT_EDITOR_ASSOCIATION.id : undefined
            };
        }
        return undefined;
    }
    TextEditorOpenOptions.from = from;
})(TextEditorOpenOptions || (TextEditorOpenOptions = {}));
var GlobPattern;
(function (GlobPattern) {
    function from(pattern) {
        if (pattern instanceof RelativePattern) {
            return pattern.toJSON();
        }
        if (typeof pattern === 'string') {
            return pattern;
        }
        if (isRelativePatternShape(pattern) || isLegacyRelativePatternShape(pattern)) {
            return new RelativePattern(pattern.baseUri ?? pattern.base, pattern.pattern).toJSON();
        }
        return pattern;
    }
    GlobPattern.from = from;
    function isRelativePatternShape(obj) {
        const rp = obj;
        if (!rp) {
            return false;
        }
        return URI.isUri(rp.baseUri) && typeof rp.pattern === 'string';
    }
    function isLegacyRelativePatternShape(obj) {
        const rp = obj;
        if (!rp) {
            return false;
        }
        return typeof rp.base === 'string' && typeof rp.pattern === 'string';
    }
    function to(pattern) {
        if (typeof pattern === 'string') {
            return pattern;
        }
        return new RelativePattern(URI.revive(pattern.baseUri), pattern.pattern);
    }
    GlobPattern.to = to;
})(GlobPattern || (GlobPattern = {}));
var LanguageSelector;
(function (LanguageSelector) {
    function from(selector) {
        if (!selector) {
            return undefined;
        }
        else if (Array.isArray(selector)) {
            return ( selector.map(from));
        }
        else if (typeof selector === 'string') {
            return selector;
        }
        else {
            const filter = selector;
            return {
                language: filter.language,
                scheme: filter.scheme,
                pattern: GlobPattern.from(filter.pattern) ?? undefined,
                exclusive: filter.exclusive,
                notebookType: filter.notebookType
            };
        }
    }
    LanguageSelector.from = from;
})(LanguageSelector || (LanguageSelector = {}));
var NotebookRange;
(function (NotebookRange) {
    function from(range) {
        return { start: range.start, end: range.end };
    }
    NotebookRange.from = from;
    function to(range) {
        return new NotebookRange$1(range.start, range.end);
    }
    NotebookRange.to = to;
})(NotebookRange || (NotebookRange = {}));
var NotebookCellExecutionSummary;
(function (NotebookCellExecutionSummary) {
    function to(data) {
        return {
            timing: typeof data.runStartTime === 'number' && typeof data.runEndTime === 'number' ? { startTime: data.runStartTime, endTime: data.runEndTime } : undefined,
            executionOrder: data.executionOrder,
            success: data.lastRunSuccess
        };
    }
    NotebookCellExecutionSummary.to = to;
    function from(data) {
        return {
            lastRunSuccess: data.success,
            runStartTime: data.timing?.startTime,
            runEndTime: data.timing?.endTime,
            executionOrder: data.executionOrder
        };
    }
    NotebookCellExecutionSummary.from = from;
})(NotebookCellExecutionSummary || (NotebookCellExecutionSummary = {}));
var NotebookCellExecutionState;
(function (NotebookCellExecutionState) {
    function to(state) {
        if (state === NotebookCellExecutionState$1.Unconfirmed) {
            return NotebookCellExecutionState$2.Pending;
        }
        else if (state === NotebookCellExecutionState$1.Pending) {
            return undefined;
        }
        else if (state === NotebookCellExecutionState$1.Executing) {
            return NotebookCellExecutionState$2.Executing;
        }
        else {
            throw ( new Error(`Unknown state: ${state}`));
        }
    }
    NotebookCellExecutionState.to = to;
})(NotebookCellExecutionState || (NotebookCellExecutionState = {}));
var NotebookCellKind;
(function (NotebookCellKind) {
    function from(data) {
        switch (data) {
            case NotebookCellKind$1.Markup:
                return CellKind.Markup;
            case NotebookCellKind$1.Code:
            default:
                return CellKind.Code;
        }
    }
    NotebookCellKind.from = from;
    function to(data) {
        switch (data) {
            case CellKind.Markup:
                return NotebookCellKind$1.Markup;
            case CellKind.Code:
            default:
                return NotebookCellKind$1.Code;
        }
    }
    NotebookCellKind.to = to;
})(NotebookCellKind || (NotebookCellKind = {}));
var NotebookData;
(function (NotebookData) {
    function from(data) {
        const res = {
            metadata: data.metadata ?? Object.create(null),
            cells: [],
        };
        for (const cell of data.cells) {
            NotebookCellData$1.validate(cell);
            res.cells.push(NotebookCellData.from(cell));
        }
        return res;
    }
    NotebookData.from = from;
    function to(data) {
        const res = new NotebookData$1(( data.cells.map(NotebookCellData.to)));
        if (!isEmptyObject(data.metadata)) {
            res.metadata = data.metadata;
        }
        return res;
    }
    NotebookData.to = to;
})(NotebookData || (NotebookData = {}));
var NotebookCellData;
(function (NotebookCellData) {
    function from(data) {
        return {
            cellKind: NotebookCellKind.from(data.kind),
            language: data.languageId,
            mime: data.mime,
            source: data.value,
            metadata: data.metadata,
            internalMetadata: NotebookCellExecutionSummary.from(data.executionSummary ?? {}),
            outputs: data.outputs ? ( data.outputs.map(NotebookCellOutput.from)) : []
        };
    }
    NotebookCellData.from = from;
    function to(data) {
        return new NotebookCellData$1(NotebookCellKind.to(data.cellKind), data.source, data.language, data.mime, data.outputs ? ( data.outputs.map(NotebookCellOutput.to)) : undefined, data.metadata, data.internalMetadata ? NotebookCellExecutionSummary.to(data.internalMetadata) : undefined);
    }
    NotebookCellData.to = to;
})(NotebookCellData || (NotebookCellData = {}));
var NotebookCellOutputItem;
(function (NotebookCellOutputItem) {
    function from(item) {
        return {
            mime: item.mime,
            valueBytes: VSBuffer.wrap(item.data),
        };
    }
    NotebookCellOutputItem.from = from;
    function to(item) {
        return new NotebookCellOutputItem$1(item.valueBytes.buffer, item.mime);
    }
    NotebookCellOutputItem.to = to;
})(NotebookCellOutputItem || (NotebookCellOutputItem = {}));
var NotebookCellOutput;
(function (NotebookCellOutput) {
    function from(output) {
        return {
            outputId: output.id,
            items: ( output.items.map(NotebookCellOutputItem.from)),
            metadata: output.metadata
        };
    }
    NotebookCellOutput.from = from;
    function to(output) {
        const items = ( output.items.map(NotebookCellOutputItem.to));
        return new NotebookCellOutput$1(items, output.outputId, output.metadata);
    }
    NotebookCellOutput.to = to;
})(NotebookCellOutput || (NotebookCellOutput = {}));
var NotebookExclusiveDocumentPattern;
(function (NotebookExclusiveDocumentPattern) {
    function from(pattern) {
        if (isExclusivePattern(pattern)) {
            return {
                include: GlobPattern.from(pattern.include) ?? undefined,
                exclude: GlobPattern.from(pattern.exclude) ?? undefined,
            };
        }
        return GlobPattern.from(pattern) ?? undefined;
    }
    NotebookExclusiveDocumentPattern.from = from;
    function to(pattern) {
        if (isExclusivePattern(pattern)) {
            return {
                include: GlobPattern.to(pattern.include),
                exclude: GlobPattern.to(pattern.exclude)
            };
        }
        return GlobPattern.to(pattern);
    }
    NotebookExclusiveDocumentPattern.to = to;
    function isExclusivePattern(obj) {
        const ep = obj;
        if (!ep) {
            return false;
        }
        return !isUndefinedOrNull(ep.include) && !isUndefinedOrNull(ep.exclude);
    }
})(NotebookExclusiveDocumentPattern || (NotebookExclusiveDocumentPattern = {}));
var NotebookStatusBarItem;
(function (NotebookStatusBarItem) {
    function from(item, commandsConverter, disposables) {
        const command = typeof item.command === 'string' ? { title: '', command: item.command } : item.command;
        return {
            alignment: item.alignment === NotebookCellStatusBarAlignment.Left ? CellStatusbarAlignment.Left : CellStatusbarAlignment.Right,
            command: commandsConverter.toInternal(command, disposables),
            text: item.text,
            tooltip: item.tooltip,
            accessibilityInformation: item.accessibilityInformation,
            priority: item.priority
        };
    }
    NotebookStatusBarItem.from = from;
})(NotebookStatusBarItem || (NotebookStatusBarItem = {}));
var NotebookKernelSourceAction;
(function (NotebookKernelSourceAction) {
    function from(item, commandsConverter, disposables) {
        const command = typeof item.command === 'string' ? { title: '', command: item.command } : item.command;
        return {
            command: commandsConverter.toInternal(command, disposables),
            label: item.label,
            description: item.description,
            detail: item.detail,
            documentation: item.documentation
        };
    }
    NotebookKernelSourceAction.from = from;
})(NotebookKernelSourceAction || (NotebookKernelSourceAction = {}));
var NotebookDocumentContentOptions;
(function (NotebookDocumentContentOptions) {
    function from(options) {
        return {
            transientOutputs: options?.transientOutputs ?? false,
            transientCellMetadata: options?.transientCellMetadata ?? {},
            transientDocumentMetadata: options?.transientDocumentMetadata ?? {},
            cellContentMetadata: options?.cellContentMetadata ?? {}
        };
    }
    NotebookDocumentContentOptions.from = from;
})(NotebookDocumentContentOptions || (NotebookDocumentContentOptions = {}));
var NotebookRendererScript;
(function (NotebookRendererScript) {
    function from(preload) {
        return {
            uri: preload.uri,
            provides: preload.provides
        };
    }
    NotebookRendererScript.from = from;
    function to(preload) {
        return new NotebookRendererScript$1(URI.revive(preload.uri), preload.provides);
    }
    NotebookRendererScript.to = to;
})(NotebookRendererScript || (NotebookRendererScript = {}));
var TestMessage;
(function (TestMessage) {
    function from(message) {
        return {
            message: MarkdownString.fromStrict(message.message) || '',
            type: TestMessageType.Error,
            expected: message.expectedOutput,
            actual: message.actualOutput,
            contextValue: message.contextValue,
            location: message.location && ({ range: Range.from(message.location.range), uri: message.location.uri }),
            stackTrace: message.stackTrace?.map(s => ({
                label: s.label,
                position: s.position && Position.from(s.position),
                uri: s.uri && URI.revive(s.uri).toJSON(),
            })),
        };
    }
    TestMessage.from = from;
    function to(item) {
        const message = new TestMessage$1(typeof item.message === 'string' ? item.message : MarkdownString.to(item.message));
        message.actualOutput = item.actual;
        message.expectedOutput = item.expected;
        message.contextValue = item.contextValue;
        message.location = item.location ? location.to(item.location) : undefined;
        return message;
    }
    TestMessage.to = to;
})(TestMessage || (TestMessage = {}));
var TestTag;
(function (TestTag) {
    TestTag.namespace = namespaceTestTag;
    TestTag.denamespace = denamespaceTestTag;
})(TestTag || (TestTag = {}));
var TestRunProfile;
(function (TestRunProfile) {
    function from(item) {
        return {
            controllerId: item.controllerId,
            profileId: item.profileId,
            group: TestRunProfileKind.from(item.kind),
        };
    }
    TestRunProfile.from = from;
})(TestRunProfile || (TestRunProfile = {}));
var TestRunProfileKind;
(function (TestRunProfileKind) {
    const profileGroupToBitset = {
        [TestRunProfileKind$1.Coverage]: TestRunProfileBitset.Coverage,
        [TestRunProfileKind$1.Debug]: TestRunProfileBitset.Debug,
        [TestRunProfileKind$1.Run]: TestRunProfileBitset.Run,
    };
    function from(kind) {
        return profileGroupToBitset.hasOwnProperty(kind) ? profileGroupToBitset[kind] : TestRunProfileBitset.Run;
    }
    TestRunProfileKind.from = from;
})(TestRunProfileKind || (TestRunProfileKind = {}));
var TestItem;
(function (TestItem) {
    function from(item) {
        const ctrlId = getPrivateApiFor(item).controllerId;
        return {
            extId: ( TestId.fromExtHostTestItem(item, ctrlId).toString()),
            label: item.label,
            uri: URI.revive(item.uri),
            busy: item.busy,
            tags: ( item.tags.map(t => TestTag.namespace(ctrlId, t.id))),
            range: Range$2.lift(Range.from(item.range)),
            description: item.description || null,
            sortText: item.sortText || null,
            error: item.error ? (MarkdownString.fromStrict(item.error) || null) : null,
        };
    }
    TestItem.from = from;
    function toPlain(item) {
        return {
            parent: undefined,
            error: undefined,
            id: TestId.fromString(item.extId).localId,
            label: item.label,
            uri: URI.revive(item.uri),
            tags: ( (item.tags || []).map(t => {
                const { tagId } = TestTag.denamespace(t);
                return new TestTag$1(tagId);
            })),
            children: {
                add: () => { },
                delete: () => { },
                forEach: () => { },
                *[Symbol.iterator]() { },
                get: () => undefined,
                replace: () => { },
                size: 0,
            },
            range: Range.to(item.range || undefined),
            canResolveChildren: false,
            busy: item.busy,
            description: item.description || undefined,
            sortText: item.sortText || undefined,
        };
    }
    TestItem.toPlain = toPlain;
})(TestItem || (TestItem = {}));
(function (TestTag) {
    function from(tag) {
        return { id: tag.id };
    }
    TestTag.from = from;
    function to(tag) {
        return new TestTag$1(tag.id);
    }
    TestTag.to = to;
})(TestTag || (TestTag = {}));
var TestResults;
(function (TestResults) {
    const convertTestResultItem = (node, parent) => {
        const item = node.value;
        if (!item) {
            return undefined;
        }
        const snapshot = ({
            ...TestItem.toPlain(item.item),
            parent,
            taskStates: ( item.tasks.map(t => ({
                state: t.state,
                duration: t.duration,
                messages: ( t.messages
                    .filter((m) => m.type === TestMessageType.Error)
                    .map(TestMessage.to)),
            }))),
            children: [],
        });
        if (node.children) {
            for (const child of ( node.children.values())) {
                const c = convertTestResultItem(child, snapshot);
                if (c) {
                    snapshot.children.push(c);
                }
            }
        }
        return snapshot;
    };
    function to(serialized) {
        const tree = ( new WellDefinedPrefixTree());
        for (const item of serialized.items) {
            tree.insert(TestId.fromString(item.item.extId).path, item);
        }
        const queue = [tree.nodes];
        const roots = [];
        while (queue.length) {
            for (const node of queue.pop()) {
                if (node.value) {
                    roots.push(node);
                }
                else if (node.children) {
                    queue.push(( node.children.values()));
                }
            }
        }
        return {
            completedAt: serialized.completedAt,
            results: ( roots.map(r => convertTestResultItem(r))).filter(isDefined),
        };
    }
    TestResults.to = to;
})(TestResults || (TestResults = {}));
var TestCoverage;
(function (TestCoverage) {
    function fromCoverageCount(count) {
        return { covered: count.covered, total: count.total };
    }
    function fromLocation(location) {
        return 'line' in location ? Position.from(location) : Range.from(location);
    }
    function toLocation(location) {
        if (!location) {
            return undefined;
        }
        return 'endLineNumber' in location ? Range.to(location) : Position.to(location);
    }
    function to(serialized) {
        if (serialized.type === DetailType.Statement) {
            const branches = [];
            if (serialized.branches) {
                for (const branch of serialized.branches) {
                    branches.push({
                        executed: branch.count,
                        location: toLocation(branch.location),
                        label: branch.label
                    });
                }
            }
            return new StatementCoverage(serialized.count, toLocation(serialized.location), serialized.branches?.map(b => new BranchCoverage(b.count, toLocation(b.location), b.label)));
        }
        else {
            return new DeclarationCoverage(serialized.name, serialized.count, toLocation(serialized.location));
        }
    }
    TestCoverage.to = to;
    function fromDetails(coverage) {
        if (typeof coverage.executed === 'number' && coverage.executed < 0) {
            throw ( new Error(`Invalid coverage count ${coverage.executed}`));
        }
        if ('branches' in coverage) {
            return {
                count: coverage.executed,
                location: fromLocation(coverage.location),
                type: DetailType.Statement,
                branches: coverage.branches.length
                    ? ( coverage.branches.map(
                    b => ({ count: b.executed, location: b.location && fromLocation(b.location), label: b.label })
                ))
                    : undefined,
            };
        }
        else {
            return {
                type: DetailType.Declaration,
                name: coverage.name,
                count: coverage.executed,
                location: fromLocation(coverage.location),
            };
        }
    }
    TestCoverage.fromDetails = fromDetails;
    function fromFile(controllerId, id, coverage) {
        validateTestCoverageCount(coverage.statementCoverage);
        validateTestCoverageCount(coverage.branchCoverage);
        validateTestCoverageCount(coverage.declarationCoverage);
        return {
            id,
            uri: coverage.uri,
            statement: fromCoverageCount(coverage.statementCoverage),
            branch: coverage.branchCoverage && fromCoverageCount(coverage.branchCoverage),
            declaration: coverage.declarationCoverage && fromCoverageCount(coverage.declarationCoverage),
            testIds: coverage instanceof FileCoverage && coverage.includesTests.length ?
                ( coverage.includesTests.map(t => ( TestId.fromExtHostTestItem(t, controllerId).toString()))) : undefined,
        };
    }
    TestCoverage.fromFile = fromFile;
})(TestCoverage || (TestCoverage = {}));
var CodeActionTriggerKind;
(function (CodeActionTriggerKind) {
    function to(value) {
        switch (value) {
            case CodeActionTriggerType.Invoke:
                return CodeActionTriggerKind$1.Invoke;
            case CodeActionTriggerType.Auto:
                return CodeActionTriggerKind$1.Automatic;
        }
    }
    CodeActionTriggerKind.to = to;
})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
var TypeHierarchyItem;
(function (TypeHierarchyItem) {
    function to(item) {
        const result = new TypeHierarchyItem$1(SymbolKind.to(item.kind), item.name, item.detail || '', URI.revive(item.uri), Range.to(item.range), Range.to(item.selectionRange));
        result._sessionId = item._sessionId;
        result._itemId = item._itemId;
        return result;
    }
    TypeHierarchyItem.to = to;
    function from(item, sessionId, itemId) {
        sessionId = sessionId ?? item._sessionId;
        itemId = itemId ?? item._itemId;
        if (sessionId === undefined || itemId === undefined) {
            throw ( new Error('invalid item'));
        }
        return {
            _sessionId: sessionId,
            _itemId: itemId,
            kind: SymbolKind.from(item.kind),
            name: item.name,
            detail: item.detail ?? '',
            uri: item.uri,
            range: Range.from(item.range),
            selectionRange: Range.from(item.selectionRange),
            tags: item.tags?.map(SymbolTag.from)
        };
    }
    TypeHierarchyItem.from = from;
})(TypeHierarchyItem || (TypeHierarchyItem = {}));
var ViewBadge;
(function (ViewBadge) {
    function from(badge) {
        if (!badge) {
            return undefined;
        }
        return {
            value: badge.value,
            tooltip: badge.tooltip
        };
    }
    ViewBadge.from = from;
})(ViewBadge || (ViewBadge = {}));
var DataTransferItem;
(function (DataTransferItem) {
    function to(mime, item, resolveFileData) {
        const file = item.fileData;
        if (file) {
            return new InternalFileDataTransferItem(new DataTransferFile(file.name, URI.revive(file.uri), file.id, createSingleCallFunction(() => resolveFileData(file.id))));
        }
        if (mime === Mimes.uriList && item.uriListData) {
            return new InternalDataTransferItem(reviveUriList(item.uriListData));
        }
        return new InternalDataTransferItem(item.asString);
    }
    DataTransferItem.to = to;
    async function from(mime, item, id = generateUuid()) {
        const stringValue = await item.asString();
        if (mime === Mimes.uriList) {
            return {
                id,
                asString: stringValue,
                fileData: undefined,
                uriListData: serializeUriList(stringValue),
            };
        }
        const fileValue = item.asFile();
        return {
            id,
            asString: stringValue,
            fileData: fileValue ? {
                name: fileValue.name,
                uri: fileValue.uri,
                id: fileValue._itemId ?? fileValue.id,
            } : undefined,
        };
    }
    DataTransferItem.from = from;
    function serializeUriList(stringValue) {
        return ( UriList.split(stringValue).map(part => {
            if (part.startsWith('#')) {
                return part;
            }
            try {
                return ( URI.parse(part));
            }
            catch {
            }
            return part;
        }));
    }
    function reviveUriList(parts) {
        return UriList.create(( parts.map(part => {
            return typeof part === 'string' ? part : URI.revive(part);
        })));
    }
})(DataTransferItem || (DataTransferItem = {}));
var DataTransfer;
(function (DataTransfer) {
    function toDataTransfer(value, resolveFileData) {
        const init = ( value.items.map(([type, item]) => {
            return [type, DataTransferItem.to(type, item, resolveFileData)];
        }));
        return new DataTransfer$1(init);
    }
    DataTransfer.toDataTransfer = toDataTransfer;
    async function from(dataTransfer) {
        const items = await Promise.all(Array.from(dataTransfer, async ([mime, value]) => {
            return [mime, await DataTransferItem.from(mime, value)];
        }));
        return { items };
    }
    DataTransfer.from = from;
    async function fromList(dataTransfer) {
        const items = await Promise.all(Array.from(dataTransfer, async ([mime, value]) => {
            return [mime, await DataTransferItem.from(mime, value, value.id)];
        }));
        return { items };
    }
    DataTransfer.fromList = fromList;
})(DataTransfer || (DataTransfer = {}));
var ChatFollowup;
(function (ChatFollowup) {
    function from(followup, request) {
        return {
            kind: 'reply',
            agentId: followup.participant ?? request?.agentId ?? '',
            subCommand: followup.command ?? request?.command,
            message: followup.prompt,
            title: followup.label
        };
    }
    ChatFollowup.from = from;
    function to(followup) {
        return {
            prompt: followup.message,
            label: followup.title,
            participant: followup.agentId,
            command: followup.subCommand,
        };
    }
    ChatFollowup.to = to;
})(ChatFollowup || (ChatFollowup = {}));
var LanguageModelChatMessageRole;
(function (LanguageModelChatMessageRole) {
    function to(role) {
        switch (role) {
            case ChatMessageRole.System: return LanguageModelChatMessageRole$1.System;
            case ChatMessageRole.User: return LanguageModelChatMessageRole$1.User;
            case ChatMessageRole.Assistant: return LanguageModelChatMessageRole$1.Assistant;
        }
    }
    LanguageModelChatMessageRole.to = to;
    function from(role) {
        switch (role) {
            case LanguageModelChatMessageRole$1.System: return ChatMessageRole.System;
            case LanguageModelChatMessageRole$1.User: return ChatMessageRole.User;
            case LanguageModelChatMessageRole$1.Assistant: return ChatMessageRole.Assistant;
        }
        return ChatMessageRole.User;
    }
    LanguageModelChatMessageRole.from = from;
})(LanguageModelChatMessageRole || (LanguageModelChatMessageRole = {}));
var LanguageModelChatMessage;
(function (LanguageModelChatMessage) {
    function to(message) {
        const content = ( message.content.map(c => {
            if (c.type === 'text') {
                return ( new LanguageModelTextPart(c.value));
            }
            else if (c.type === 'tool_result') {
                const content = ( c.value.map(part => {
                    if (part.type === 'text') {
                        return new LanguageModelTextPart(part.value);
                    }
                    else {
                        return new LanguageModelPromptTsxPart(part.value);
                    }
                }));
                return new LanguageModelToolResultPart(c.toolCallId, content, c.isError);
            }
            else {
                return new LanguageModelToolCallPart(c.toolCallId, c.name, c.parameters);
            }
        }));
        const role = LanguageModelChatMessageRole.to(message.role);
        const result = new LanguageModelChatMessage$1(role, content, message.name);
        return result;
    }
    LanguageModelChatMessage.to = to;
    function from(message) {
        const role = LanguageModelChatMessageRole.from(message.role);
        const name = message.name;
        let messageContent = message.content;
        if (typeof messageContent === 'string') {
            messageContent = [new LanguageModelTextPart(messageContent)];
        }
        const content = ( messageContent.map((c) => {
            if (c instanceof LanguageModelToolResultPart) {
                return {
                    type: 'tool_result',
                    toolCallId: c.callId,
                    value: coalesce(( c.content.map(part => {
                        if (part instanceof LanguageModelTextPart) {
                            return {
                                type: 'text',
                                value: part.value
                            };
                        }
                        else if (part instanceof LanguageModelPromptTsxPart) {
                            return {
                                type: 'prompt_tsx',
                                value: part.value,
                            };
                        }
                        else {
                            return undefined;
                        }
                    }))),
                    isError: c.isError
                };
            }
            else if (c instanceof LanguageModelToolCallPart) {
                return {
                    type: 'tool_use',
                    toolCallId: c.callId,
                    name: c.name,
                    parameters: c.input
                };
            }
            else if (c instanceof LanguageModelTextPart) {
                return {
                    type: 'text',
                    value: c.value
                };
            }
            else {
                if (typeof c !== 'string') {
                    throw ( new Error('Unexpected chat message content type'));
                }
                return {
                    type: 'text',
                    value: c
                };
            }
        }));
        return {
            role,
            name,
            content
        };
    }
    LanguageModelChatMessage.from = from;
})(LanguageModelChatMessage || (LanguageModelChatMessage = {}));
var ChatResponseMarkdownPart;
(function (ChatResponseMarkdownPart) {
    function from(part) {
        return {
            kind: 'markdownContent',
            content: MarkdownString.from(part.value)
        };
    }
    ChatResponseMarkdownPart.from = from;
    function to(part) {
        return new ChatResponseMarkdownPart$1(MarkdownString.to(part.content));
    }
    ChatResponseMarkdownPart.to = to;
})(ChatResponseMarkdownPart || (ChatResponseMarkdownPart = {}));
var ChatResponseCodeblockUriPart;
(function (ChatResponseCodeblockUriPart) {
    function from(part) {
        return {
            kind: 'codeblockUri',
            uri: part.value,
        };
    }
    ChatResponseCodeblockUriPart.from = from;
    function to(part) {
        return new ChatResponseCodeblockUriPart$1(URI.revive(part.uri));
    }
    ChatResponseCodeblockUriPart.to = to;
})(ChatResponseCodeblockUriPart || (ChatResponseCodeblockUriPart = {}));
var ChatResponseMarkdownWithVulnerabilitiesPart;
(function (ChatResponseMarkdownWithVulnerabilitiesPart) {
    function from(part) {
        return {
            kind: 'markdownVuln',
            content: MarkdownString.from(part.value),
            vulnerabilities: part.vulnerabilities,
        };
    }
    ChatResponseMarkdownWithVulnerabilitiesPart.from = from;
    function to(part) {
        return new ChatResponseMarkdownWithVulnerabilitiesPart$1(MarkdownString.to(part.content), part.vulnerabilities);
    }
    ChatResponseMarkdownWithVulnerabilitiesPart.to = to;
})(ChatResponseMarkdownWithVulnerabilitiesPart || (ChatResponseMarkdownWithVulnerabilitiesPart = {}));
var ChatResponseConfirmationPart;
(function (ChatResponseConfirmationPart) {
    function from(part) {
        return {
            kind: 'confirmation',
            title: part.title,
            message: part.message,
            data: part.data,
            buttons: part.buttons
        };
    }
    ChatResponseConfirmationPart.from = from;
})(ChatResponseConfirmationPart || (ChatResponseConfirmationPart = {}));
var ChatResponseFilesPart;
(function (ChatResponseFilesPart) {
    function from(part) {
        const { value, baseUri } = part;
        function convert(items, baseUri) {
            return ( items.map(item => {
                const myUri = URI.joinPath(baseUri, item.name);
                return {
                    label: item.name,
                    uri: myUri,
                    children: item.children && convert(item.children, myUri)
                };
            }));
        }
        return {
            kind: 'treeData',
            treeData: {
                label: basename(baseUri),
                uri: baseUri,
                children: convert(value, baseUri)
            }
        };
    }
    ChatResponseFilesPart.from = from;
    function to(part) {
        const treeData = revive(part.treeData);
        function convert(items) {
            return ( items.map(item => {
                return {
                    name: item.label,
                    children: item.children && convert(item.children)
                };
            }));
        }
        const baseUri = treeData.uri;
        const items = treeData.children ? convert(treeData.children) : [];
        return new ChatResponseFileTreePart(items, baseUri);
    }
    ChatResponseFilesPart.to = to;
})(ChatResponseFilesPart || (ChatResponseFilesPart = {}));
var ChatResponseAnchorPart;
(function (ChatResponseAnchorPart) {
    function from(part) {
        const isUri = (thing) => URI.isUri(thing);
        const isSymbolInformation = (thing) => 'name' in thing;
        return {
            kind: 'inlineReference',
            name: part.title,
            inlineReference: isUri(part.value)
                ? part.value
                : isSymbolInformation(part.value)
                    ? WorkspaceSymbol.from(part.value)
                    : Location.from(part.value)
        };
    }
    ChatResponseAnchorPart.from = from;
    function to(part) {
        const value = revive(part);
        return new ChatResponseAnchorPart$1(URI.isUri(value.inlineReference)
            ? value.inlineReference
            : 'location' in value.inlineReference
                ? WorkspaceSymbol.to(value.inlineReference)
                : Location.to(value.inlineReference), part.name);
    }
    ChatResponseAnchorPart.to = to;
})(ChatResponseAnchorPart || (ChatResponseAnchorPart = {}));
var ChatResponseProgressPart;
(function (ChatResponseProgressPart) {
    function from(part) {
        return {
            kind: 'progressMessage',
            content: MarkdownString.from(part.value)
        };
    }
    ChatResponseProgressPart.from = from;
    function to(part) {
        return new ChatResponseProgressPart$1(part.content.value);
    }
    ChatResponseProgressPart.to = to;
})(ChatResponseProgressPart || (ChatResponseProgressPart = {}));
var ChatResponseWarningPart;
(function (ChatResponseWarningPart) {
    function from(part) {
        return {
            kind: 'warning',
            content: MarkdownString.from(part.value)
        };
    }
    ChatResponseWarningPart.from = from;
    function to(part) {
        return new ChatResponseWarningPart$1(part.content.value);
    }
    ChatResponseWarningPart.to = to;
})(ChatResponseWarningPart || (ChatResponseWarningPart = {}));
var ChatResponseMovePart;
(function (ChatResponseMovePart) {
    function from(part) {
        return {
            kind: 'move',
            uri: part.uri,
            range: Range.from(part.range),
        };
    }
    ChatResponseMovePart.from = from;
    function to(part) {
        return new ChatResponseMovePart$1(URI.revive(part.uri), Range.to(part.range));
    }
    ChatResponseMovePart.to = to;
})(ChatResponseMovePart || (ChatResponseMovePart = {}));
var ChatTask;
(function (ChatTask) {
    function from(part) {
        return {
            kind: 'progressTask',
            content: MarkdownString.from(part.value),
        };
    }
    ChatTask.from = from;
})(ChatTask || (ChatTask = {}));
var ChatTaskResult;
(function (ChatTaskResult) {
    function from(part) {
        return {
            kind: 'progressTaskResult',
            content: typeof part === 'string' ? MarkdownString.from(part) : undefined
        };
    }
    ChatTaskResult.from = from;
})(ChatTaskResult || (ChatTaskResult = {}));
var ChatResponseCommandButtonPart;
(function (ChatResponseCommandButtonPart) {
    function from(part, commandsConverter, commandDisposables) {
        const command = commandsConverter.toInternal(part.value, commandDisposables) ?? { command: part.value.command, title: part.value.title };
        return {
            kind: 'command',
            command
        };
    }
    ChatResponseCommandButtonPart.from = from;
    function to(part, commandsConverter) {
        return new ChatResponseCommandButtonPart$1(commandsConverter.fromInternal(part.command) ?? { command: part.command.id, title: part.command.title });
    }
    ChatResponseCommandButtonPart.to = to;
})(ChatResponseCommandButtonPart || (ChatResponseCommandButtonPart = {}));
var ChatResponseTextEditPart;
(function (ChatResponseTextEditPart) {
    function from(part) {
        return {
            kind: 'textEdit',
            uri: part.uri,
            edits: ( part.edits.map(e => TextEdit.from(e))),
            done: part.isDone
        };
    }
    ChatResponseTextEditPart.from = from;
    function to(part) {
        const result = new ChatResponseTextEditPart$1(URI.revive(part.uri), ( part.edits.map(e => TextEdit.to(e))));
        result.isDone = part.done;
        return result;
    }
    ChatResponseTextEditPart.to = to;
})(ChatResponseTextEditPart || (ChatResponseTextEditPart = {}));
var NotebookEdit;
(function (NotebookEdit) {
    function from(edit) {
        if (edit.newCellMetadata) {
            return {
                editType: CellEditType.Metadata,
                index: edit.range.start,
                metadata: edit.newCellMetadata
            };
        }
        else if (edit.newNotebookMetadata) {
            return {
                editType: CellEditType.DocumentMetadata,
                metadata: edit.newNotebookMetadata
            };
        }
        else {
            return {
                editType: CellEditType.Replace,
                index: edit.range.start,
                count: edit.range.end - edit.range.start,
                cells: ( edit.newCells.map(NotebookCellData.from))
            };
        }
    }
    NotebookEdit.from = from;
})(NotebookEdit || (NotebookEdit = {}));
var ChatResponseNotebookEditPart;
(function (ChatResponseNotebookEditPart) {
    function from(part) {
        return {
            kind: 'notebookEdit',
            uri: part.uri,
            edits: ( part.edits.map(NotebookEdit.from)),
            done: part.isDone
        };
    }
    ChatResponseNotebookEditPart.from = from;
})(ChatResponseNotebookEditPart || (ChatResponseNotebookEditPart = {}));
var ChatResponseReferencePart;
(function (ChatResponseReferencePart) {
    function from(part) {
        const iconPath = ThemeIcon.isThemeIcon(part.iconPath) ? part.iconPath
            : URI.isUri(part.iconPath) ? { light: URI.revive(part.iconPath) }
                : (part.iconPath && 'light' in part.iconPath && 'dark' in part.iconPath && URI.isUri(part.iconPath.light) && URI.isUri(part.iconPath.dark) ? { light: URI.revive(part.iconPath.light), dark: URI.revive(part.iconPath.dark) }
                    : undefined);
        if (typeof part.value === 'object' && 'variableName' in part.value) {
            return {
                kind: 'reference',
                reference: {
                    variableName: part.value.variableName,
                    value: URI.isUri(part.value.value) || !part.value.value ?
                        part.value.value :
                        Location.from(part.value.value)
                },
                iconPath,
                options: part.options
            };
        }
        return {
            kind: 'reference',
            reference: URI.isUri(part.value) || typeof part.value === 'string' ?
                part.value :
                Location.from(part.value),
            iconPath,
            options: part.options
        };
    }
    ChatResponseReferencePart.from = from;
    function to(part) {
        const value = revive(part);
        const mapValue = (value) => URI.isUri(value) ?
            value :
            Location.to(value);
        return new ChatResponseReferencePart$1(typeof value.reference === 'string' ? value.reference : 'variableName' in value.reference ? {
            variableName: value.reference.variableName,
            value: value.reference.value && mapValue(value.reference.value)
        } :
            mapValue(value.reference));
    }
    ChatResponseReferencePart.to = to;
})(ChatResponseReferencePart || (ChatResponseReferencePart = {}));
var ChatResponseCodeCitationPart;
(function (ChatResponseCodeCitationPart) {
    function from(part) {
        return {
            kind: 'codeCitation',
            value: part.value,
            license: part.license,
            snippet: part.snippet
        };
    }
    ChatResponseCodeCitationPart.from = from;
})(ChatResponseCodeCitationPart || (ChatResponseCodeCitationPart = {}));
var ChatResponsePart;
(function (ChatResponsePart) {
    function from(part, commandsConverter, commandDisposables) {
        if (part instanceof ChatResponseMarkdownPart$1) {
            return ChatResponseMarkdownPart.from(part);
        }
        else if (part instanceof ChatResponseAnchorPart$1) {
            return ChatResponseAnchorPart.from(part);
        }
        else if (part instanceof ChatResponseReferencePart$1) {
            return ChatResponseReferencePart.from(part);
        }
        else if (part instanceof ChatResponseProgressPart$1) {
            return ChatResponseProgressPart.from(part);
        }
        else if (part instanceof ChatResponseFileTreePart) {
            return ChatResponseFilesPart.from(part);
        }
        else if (part instanceof ChatResponseCommandButtonPart$1) {
            return ChatResponseCommandButtonPart.from(part, commandsConverter, commandDisposables);
        }
        else if (part instanceof ChatResponseTextEditPart$1) {
            return ChatResponseTextEditPart.from(part);
        }
        else if (part instanceof ChatResponseNotebookEditPart$1) {
            return ChatResponseNotebookEditPart.from(part);
        }
        else if (part instanceof ChatResponseMarkdownWithVulnerabilitiesPart$1) {
            return ChatResponseMarkdownWithVulnerabilitiesPart.from(part);
        }
        else if (part instanceof ChatResponseCodeblockUriPart$1) {
            return ChatResponseCodeblockUriPart.from(part);
        }
        else if (part instanceof ChatResponseWarningPart$1) {
            return ChatResponseWarningPart.from(part);
        }
        else if (part instanceof ChatResponseConfirmationPart$1) {
            return ChatResponseConfirmationPart.from(part);
        }
        else if (part instanceof ChatResponseCodeCitationPart$1) {
            return ChatResponseCodeCitationPart.from(part);
        }
        else if (part instanceof ChatResponseMovePart$1) {
            return ChatResponseMovePart.from(part);
        }
        return {
            kind: 'markdownContent',
            content: MarkdownString.from('')
        };
    }
    ChatResponsePart.from = from;
    function to(part, commandsConverter) {
        switch (part.kind) {
            case 'reference': return ChatResponseReferencePart.to(part);
            case 'markdownContent':
            case 'inlineReference':
            case 'progressMessage':
            case 'treeData':
            case 'command':
                return toContent(part, commandsConverter);
        }
        return undefined;
    }
    ChatResponsePart.to = to;
    function toContent(part, commandsConverter) {
        switch (part.kind) {
            case 'markdownContent': return ChatResponseMarkdownPart.to(part);
            case 'inlineReference': return ChatResponseAnchorPart.to(part);
            case 'progressMessage': return undefined;
            case 'treeData': return ChatResponseFilesPart.to(part);
            case 'command': return ChatResponseCommandButtonPart.to(part, commandsConverter);
        }
        return undefined;
    }
    ChatResponsePart.toContent = toContent;
})(ChatResponsePart || (ChatResponsePart = {}));
var ChatAgentRequest;
(function (ChatAgentRequest) {
    function to(request, location2, model, hasReadonlyProposal, diagnostics) {
        const toolReferences = request.variables.variables.filter(v => v.isTool);
        const variableReferences = request.variables.variables.filter(v => !v.isTool);
        return {
            prompt: request.message,
            command: request.command,
            attempt: request.attempt ?? 0,
            enableCommandDetection: request.enableCommandDetection ?? true,
            isParticipantDetected: request.isParticipantDetected ?? false,
            references: ( variableReferences.map(v => ChatPromptReference.to(v, hasReadonlyProposal, diagnostics))),
            toolReferences: ( toolReferences.map(ChatLanguageModelToolReference.to)),
            location: ChatLocation.to(request.location),
            acceptedConfirmationData: request.acceptedConfirmationData,
            rejectedConfirmationData: request.rejectedConfirmationData,
            location2,
            toolInvocationToken: ( Object.freeze({ sessionId: request.sessionId })),
            model
        };
    }
    ChatAgentRequest.to = to;
})(ChatAgentRequest || (ChatAgentRequest = {}));
var ChatRequestDraft;
(function (ChatRequestDraft) {
    function to(request) {
        return {
            prompt: request.prompt,
            files: ( request.files.map((uri) => URI.revive(uri)))
        };
    }
    ChatRequestDraft.to = to;
})(ChatRequestDraft || (ChatRequestDraft = {}));
var ChatLocation;
(function (ChatLocation) {
    function to(loc) {
        switch (loc) {
            case ChatAgentLocation.Notebook: return ChatLocation$1.Notebook;
            case ChatAgentLocation.Terminal: return ChatLocation$1.Terminal;
            case ChatAgentLocation.Panel: return ChatLocation$1.Panel;
            case ChatAgentLocation.Editor: return ChatLocation$1.Editor;
            case ChatAgentLocation.EditingSession: return ChatLocation$1.EditingSession;
        }
    }
    ChatLocation.to = to;
    function from(loc) {
        switch (loc) {
            case ChatLocation$1.Notebook: return ChatAgentLocation.Notebook;
            case ChatLocation$1.Terminal: return ChatAgentLocation.Terminal;
            case ChatLocation$1.Panel: return ChatAgentLocation.Panel;
            case ChatLocation$1.Editor: return ChatAgentLocation.Editor;
            case ChatLocation$1.EditingSession: return ChatAgentLocation.EditingSession;
        }
    }
    ChatLocation.from = from;
})(ChatLocation || (ChatLocation = {}));
var ChatPromptReference;
(function (ChatPromptReference) {
    function to(variable, hasReadonlyProposal, diagnostics) {
        let value = variable.value;
        if (!value) {
            throw ( new Error('Invalid value reference'));
        }
        if (isUriComponents(value)) {
            value = URI.revive(value);
        }
        else if (value && typeof value === 'object' && 'uri' in value && 'range' in value && isUriComponents(value.uri)) {
            value = Location.to(revive(value));
        }
        else if (variable.isImage) {
            value = new ChatReferenceBinaryData(variable.mimeType ?? 'image/png', () => Promise.resolve(( new Uint8Array(( Object.values(variable.value))))), variable.references && URI.isUri(variable.references[0].reference) ? variable.references[0].reference : undefined);
        }
        else if (variable.kind === 'diagnostic') {
            const filterSeverity = variable.filterSeverity && DiagnosticSeverity.to(variable.filterSeverity);
            const filterUri = variable.filterUri && ( URI.revive(variable.filterUri).toString());
            value = new ChatReferenceDiagnostic(( diagnostics.map(([uri, d]) => {
                if (variable.filterUri && ( uri.toString()) !== filterUri) {
                    return [uri, []];
                }
                return [uri, d.filter(d => {
                        if (filterSeverity && d.severity > filterSeverity) {
                            return false;
                        }
                        if (variable.filterRange && !Range$2.areIntersectingOrTouching(variable.filterRange, Range.from(d.range))) {
                            return false;
                        }
                        return true;
                    })];
            })).filter(([, d]) => d.length > 0));
        }
        return {
            id: variable.id,
            name: variable.name,
            range: variable.range && [variable.range.start, variable.range.endExclusive],
            value,
            modelDescription: variable.modelDescription,
            isReadonly: hasReadonlyProposal ? variable.isMarkedReadonly : undefined,
        };
    }
    ChatPromptReference.to = to;
})(ChatPromptReference || (ChatPromptReference = {}));
var ChatLanguageModelToolReference;
(function (ChatLanguageModelToolReference) {
    function to(variable) {
        const value = variable.value;
        if (value) {
            throw ( new Error('Invalid tool reference'));
        }
        return {
            name: variable.id,
            range: variable.range && [variable.range.start, variable.range.endExclusive],
        };
    }
    ChatLanguageModelToolReference.to = to;
})(ChatLanguageModelToolReference || (ChatLanguageModelToolReference = {}));
var ChatAgentCompletionItem;
(function (ChatAgentCompletionItem) {
    function from(item, commandsConverter, disposables) {
        return {
            id: item.id,
            label: item.label,
            fullName: item.fullName,
            icon: item.icon?.id,
            value: item.values[0].value,
            insertText: item.insertText,
            detail: item.detail,
            documentation: item.documentation,
            command: commandsConverter.toInternal(item.command, disposables),
        };
    }
    ChatAgentCompletionItem.from = from;
})(ChatAgentCompletionItem || (ChatAgentCompletionItem = {}));
var ChatAgentResult;
(function (ChatAgentResult) {
    function to(result) {
        return {
            errorDetails: result.errorDetails,
            metadata: reviveMetadata(result.metadata),
            nextQuestion: result.nextQuestion,
        };
    }
    ChatAgentResult.to = to;
    function from(result) {
        return {
            errorDetails: result.errorDetails,
            metadata: result.metadata,
            nextQuestion: result.nextQuestion,
        };
    }
    ChatAgentResult.from = from;
    function reviveMetadata(metadata) {
        return cloneAndChange(metadata, value => {
            if (value.$mid === MarshalledId.LanguageModelToolResult) {
                return new LanguageModelToolResult$1(cloneAndChange(value.content, reviveMetadata));
            }
            else if (value.$mid === MarshalledId.LanguageModelTextPart) {
                return new LanguageModelTextPart(value.value);
            }
            else if (value.$mid === MarshalledId.LanguageModelPromptTsxPart) {
                return new LanguageModelPromptTsxPart(value.value);
            }
            return undefined;
        });
    }
})(ChatAgentResult || (ChatAgentResult = {}));
var ChatAgentUserActionEvent;
(function (ChatAgentUserActionEvent) {
    function to(result, event, commandsConverter) {
        if (event.action.kind === 'vote') {
            return;
        }
        const ehResult = ChatAgentResult.to(result);
        if (event.action.kind === 'command') {
            const command = event.action.commandButton.command;
            const commandButton = {
                command: commandsConverter.fromInternal(command) ?? { command: command.id, title: command.title },
            };
            const commandAction = { kind: 'command', commandButton };
            return { action: commandAction, result: ehResult };
        }
        else if (event.action.kind === 'followUp') {
            const followupAction = { kind: 'followUp', followup: ChatFollowup.to(event.action.followup) };
            return { action: followupAction, result: ehResult };
        }
        else if (event.action.kind === 'inlineChat') {
            return { action: { kind: 'editor', accepted: event.action.action === 'accepted' }, result: ehResult };
        }
        else if (event.action.kind === 'chatEditingSessionAction') {
            const outcomes = ( new Map([
                ['accepted', ChatEditingSessionActionOutcome.Accepted],
                ['rejected', ChatEditingSessionActionOutcome.Rejected],
                ['saved', ChatEditingSessionActionOutcome.Saved],
            ]));
            return {
                action: {
                    kind: 'chatEditingSessionAction',
                    outcome: outcomes.get(event.action.outcome) ?? ChatEditingSessionActionOutcome.Rejected,
                    uri: URI.revive(event.action.uri),
                    hasRemainingEdits: event.action.hasRemainingEdits
                }, result: ehResult
            };
        }
        else {
            return { action: event.action, result: ehResult };
        }
    }
    ChatAgentUserActionEvent.to = to;
})(ChatAgentUserActionEvent || (ChatAgentUserActionEvent = {}));
var TerminalQuickFix;
(function (TerminalQuickFix) {
    function from(quickFix, converter, disposables) {
        if ('terminalCommand' in quickFix) {
            return { terminalCommand: quickFix.terminalCommand, shouldExecute: quickFix.shouldExecute };
        }
        if ('uri' in quickFix) {
            return { uri: quickFix.uri };
        }
        return converter.toInternal(quickFix, disposables);
    }
    TerminalQuickFix.from = from;
})(TerminalQuickFix || (TerminalQuickFix = {}));
var TerminalCompletionItemDto;
(function (TerminalCompletionItemDto) {
    function from(item) {
        return {
            ...item,
            documentation: MarkdownString.fromStrict(item.documentation),
        };
    }
    TerminalCompletionItemDto.from = from;
})(TerminalCompletionItemDto || (TerminalCompletionItemDto = {}));
var TerminalCompletionList;
(function (TerminalCompletionList) {
    function from(completions) {
        if (Array.isArray(completions)) {
            return {
                items: ( completions.map(i => TerminalCompletionItemDto.from(i))),
            };
        }
        return {
            items: ( completions.items.map(i => TerminalCompletionItemDto.from(i))),
            resourceRequestConfig: completions.resourceRequestConfig ? TerminalResourceRequestConfig.from(completions.resourceRequestConfig) : undefined,
        };
    }
    TerminalCompletionList.from = from;
})(TerminalCompletionList || (TerminalCompletionList = {}));
var TerminalResourceRequestConfig;
(function (TerminalResourceRequestConfig) {
    function from(resourceRequestConfig) {
        return {
            ...resourceRequestConfig,
            pathSeparator: isWindows ? '\\' : '/',
            cwd: resourceRequestConfig.cwd ? URI.revive(resourceRequestConfig.cwd) : undefined,
        };
    }
    TerminalResourceRequestConfig.from = from;
})(TerminalResourceRequestConfig || (TerminalResourceRequestConfig = {}));
var PartialAcceptInfo;
(function (PartialAcceptInfo) {
    function to(info) {
        return {
            kind: PartialAcceptTriggerKind.to(info.kind),
            acceptedLength: info.acceptedLength,
        };
    }
    PartialAcceptInfo.to = to;
})(PartialAcceptInfo || (PartialAcceptInfo = {}));
var PartialAcceptTriggerKind;
(function (PartialAcceptTriggerKind) {
    function to(kind) {
        switch (kind) {
            case PartialAcceptTriggerKind$2.Word:
                return PartialAcceptTriggerKind$1.Word;
            case PartialAcceptTriggerKind$2.Line:
                return PartialAcceptTriggerKind$1.Line;
            case PartialAcceptTriggerKind$2.Suggest:
                return PartialAcceptTriggerKind$1.Suggest;
            default:
                return PartialAcceptTriggerKind$1.Unknown;
        }
    }
    PartialAcceptTriggerKind.to = to;
})(PartialAcceptTriggerKind || (PartialAcceptTriggerKind = {}));
var DebugTreeItem;
(function (DebugTreeItem) {
    function from(item, id) {
        return {
            id,
            label: item.label,
            description: item.description,
            canEdit: item.canEdit,
            collapsibleState: (item.collapsibleState || DebugTreeItemCollapsibleState.None),
            contextValue: item.contextValue,
        };
    }
    DebugTreeItem.from = from;
})(DebugTreeItem || (DebugTreeItem = {}));
var LanguageModelToolDescription;
(function (LanguageModelToolDescription) {
    function to(item) {
        return {
            name: item.id,
            description: item.modelDescription,
            inputSchema: item.inputSchema,
            tags: item.tags ?? [],
        };
    }
    LanguageModelToolDescription.to = to;
})(LanguageModelToolDescription || (LanguageModelToolDescription = {}));
var LanguageModelToolResult;
(function (LanguageModelToolResult) {
    function to(result) {
        return new LanguageModelToolResult$1(( result.content.map(item => {
            if (item.kind === 'text') {
                return new LanguageModelTextPart(item.value);
            }
            else {
                return new LanguageModelPromptTsxPart(item.value);
            }
        })));
    }
    LanguageModelToolResult.to = to;
    function from(result, extension) {
        if (result.toolResultMessage) {
            checkProposedApiEnabled(extension, 'chatParticipantPrivate');
        }
        return {
            content: ( result.content.map(item => {
                if (item instanceof LanguageModelTextPart) {
                    return {
                        kind: 'text',
                        value: item.value
                    };
                }
                else if (item instanceof LanguageModelPromptTsxPart) {
                    return {
                        kind: 'promptTsx',
                        value: item.value,
                    };
                }
                else {
                    throw ( new Error('Unknown LanguageModelToolResult part type'));
                }
            })),
            toolResultMessage: MarkdownString.fromStrict(result.toolResultMessage),
            toolResultDetails: result.toolResultDetails?.map(detail => URI.isUri(detail) ? detail : Location.from(detail)),
        };
    }
    LanguageModelToolResult.from = from;
})(LanguageModelToolResult || (LanguageModelToolResult = {}));
var IconPath;
(function (IconPath) {
    function fromThemeIcon(iconPath) {
        return iconPath;
    }
    IconPath.fromThemeIcon = fromThemeIcon;
})(IconPath || (IconPath = {}));

export { CallHierarchyIncomingCall, CallHierarchyItem, CallHierarchyOutgoingCall, ChatAgentCompletionItem, ChatAgentRequest, ChatAgentResult, ChatAgentUserActionEvent, ChatFollowup, ChatLanguageModelToolReference, ChatLocation, ChatPromptReference, ChatRequestDraft, ChatResponseAnchorPart, ChatResponseCodeCitationPart, ChatResponseCodeblockUriPart, ChatResponseCommandButtonPart, ChatResponseConfirmationPart, ChatResponseFilesPart, ChatResponseMarkdownPart, ChatResponseMarkdownWithVulnerabilitiesPart, ChatResponseMovePart, ChatResponseNotebookEditPart, ChatResponsePart, ChatResponseProgressPart, ChatResponseReferencePart, ChatResponseTextEditPart, ChatResponseWarningPart, ChatTask, ChatTaskResult, CodeActionTriggerKind, Color, ColorPresentation, CompletionContext, CompletionItem, CompletionItemKind, CompletionItemTag, CompletionTriggerKind, DataTransfer, DataTransferItem, DebugTreeItem, DecorationRangeBehavior, DecorationRenderOptions, DefinitionLink, Diagnostic, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, DocumentHighlight, DocumentLink, DocumentSelector, DocumentSymbol, EndOfLine, EvaluatableExpression, FoldingRange, FoldingRangeKind, GlobPattern, Hover, IconPath, InlayHint, InlayHintKind, InlayHintLabelPart, InlineValue, InlineValueContext, LanguageModelChatMessage, LanguageModelChatMessageRole, LanguageModelToolDescription, LanguageModelToolResult, LanguageSelector, Location, MarkdownString, MultiDocumentHighlight, NotebookCellData, NotebookCellExecutionState, NotebookCellExecutionSummary, NotebookCellKind, NotebookCellOutput, NotebookCellOutputItem, NotebookData, NotebookDocumentContentOptions, NotebookEdit, NotebookExclusiveDocumentPattern, NotebookKernelSourceAction, NotebookRange, NotebookRendererScript, NotebookStatusBarItem, ParameterInformation, PartialAcceptInfo, PartialAcceptTriggerKind, Position, ProgressLocation, Range, Selection, SelectionRange, SignatureHelp, SignatureInformation, SymbolKind, SymbolTag, TerminalCompletionItemDto, TerminalCompletionList, TerminalQuickFix, TerminalResourceRequestConfig, TestCoverage, TestItem, TestMessage, TestResults, TestRunProfile, TestRunProfileKind, TestTag, TextDocumentSaveReason, TextEdit, TextEditorLineNumbersStyle, TextEditorOpenOptions, ThemableDecorationAttachmentRenderOptions, ThemableDecorationRenderOptions, TokenType, TypeHierarchyItem, ViewBadge, ViewColumn, WorkspaceEdit, WorkspaceSymbol, fromRangeOrRangeWithMessage, isDecorationOptionsArr, location, pathOrURIToURI };
