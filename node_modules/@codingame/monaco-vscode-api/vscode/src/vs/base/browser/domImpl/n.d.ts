import { DisposableStore, IDisposable } from "../../common/lifecycle.js";
import { IObservable, IReader } from "../../common/observable.js";
export declare namespace n {
    const div: DomCreateFn<HTMLDivElement, HTMLDivElement>;
    const elem: DomTagCreateFn<HTMLElementTagNameMap>;
    const svg: DomCreateFn<SVGElementTagNameMap2["svg"], SVGElement>;
    const svgElem: DomTagCreateFn<SVGElementTagNameMap2>;
    function ref<T = Element>(): IRefWithVal<T>;
}
type Value<T> = T | IObservable<T>;
type ValueOrList<T> = Value<T> | ValueOrList<T>[];
type ValueOrList2<T> = ValueOrList<T> | ValueOrList<ValueOrList<T>>;
type Element = HTMLElement | SVGElement;
type SVGElementTagNameMap2 = {
    svg: SVGElement & {
        width: number;
        height: number;
        transform: string;
        viewBox: string;
        fill: string;
    };
    path: SVGElement & {
        d: string;
        stroke: string;
        fill: string;
    };
    linearGradient: SVGElement & {
        id: string;
        x1: string | number;
        x2: string | number;
    };
    stop: SVGElement & {
        offset: string;
    };
    rect: SVGElement & {
        x: number;
        y: number;
        width: number;
        height: number;
        fill: string;
    };
    defs: SVGElement;
};
type DomTagCreateFn<TMap extends Record<string, any>> = <TTag extends keyof TMap>(tag: TTag, attributes: ElementAttributeKeys<TMap[TTag]> & {
    class?: ValueOrList<string | false | undefined>;
    ref?: IRef<TMap[TTag]>;
    obsRef?: IRef<ObserverNodeWithElement<TMap[TTag]> | null>;
}, children?: ChildNode) => ObserverNode<TMap[TTag]>;
type DomCreateFn<TAttributes, TResult extends Element> = (attributes: ElementAttributeKeys<TAttributes> & {
    class?: ValueOrList<string | false | undefined>;
    ref?: IRef<TResult>;
    obsRef?: IRef<ObserverNodeWithElement<TResult> | null>;
}, children?: ChildNode) => ObserverNode<TResult>;
export type ChildNode = ValueOrList2<Element | string | ObserverNode | undefined>;
export type IRef<T> = (value: T) => void;
export interface IRefWithVal<T> extends IRef<T> {
    readonly element: T;
}
export declare abstract class ObserverNode<T extends Element = Element> {
    private readonly _deriveds;
    protected readonly _element: T;
    constructor(tag: string, ref: IRef<T> | undefined, obsRef: IRef<ObserverNodeWithElement<T> | null> | undefined, ns: string | undefined, className: ValueOrList<string | undefined | false> | undefined, attributes: ElementAttributeKeys<T>, children: ChildNode);
    readEffect(reader: IReader | undefined): void;
    keepUpdated(store: DisposableStore): ObserverNodeWithElement<T>;
    toDisposableLiveElement(): LiveElement<T>;
}
export declare class LiveElement<T extends Element = HTMLElement> {
    readonly element: T;
    private readonly _disposable;
    constructor(element: T, _disposable: IDisposable);
    dispose(): void;
}
export declare class ObserverNodeWithElement<T extends Element = Element> extends ObserverNode<T> {
    get element(): T;
    private _isHovered;
    get isHovered(): IObservable<boolean>;
    private _didMouseMoveDuringHover;
    get didMouseMoveDuringHover(): IObservable<boolean>;
}
type ElementAttributeKeys<T> = Partial<{
    [K in keyof T]: T[K] extends Function ? never : T[K] extends object ? ElementAttributeKeys<T[K]> : Value<number | T[K] | undefined | null>;
}>;
export {};
