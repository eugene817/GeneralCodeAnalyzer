import { IChangeContext, IObservable, IObservableWithChange, IObserver, IReader } from "./base.js";
import { DebugNameData, IDebugNameData } from "./debugName.js";
import { DisposableStore, IDisposable } from "./commonFacade/deps.js";
export declare function autorun(fn: (reader: IReader) => void): IDisposable;
export declare function autorunOpts(options: IDebugNameData & {}, fn: (reader: IReader) => void): IDisposable;
export declare function autorunHandleChanges<TChangeSummary>(options: IDebugNameData & {
    createEmptyChangeSummary?: () => TChangeSummary;
    handleChange: (context: IChangeContext, changeSummary: TChangeSummary) => boolean;
}, fn: (reader: IReader, changeSummary: TChangeSummary) => void): IDisposable;
export declare function autorunWithStoreHandleChanges<TChangeSummary>(options: IDebugNameData & {
    createEmptyChangeSummary?: () => TChangeSummary;
    handleChange: (context: IChangeContext, changeSummary: TChangeSummary) => boolean;
}, fn: (reader: IReader, changeSummary: TChangeSummary, store: DisposableStore) => void): IDisposable;
export declare function autorunWithStore(fn: (reader: IReader, store: DisposableStore) => void): IDisposable;
export declare function autorunDelta<T>(observable: IObservable<T>, handler: (args: {
    lastValue: T | undefined;
    newValue: T;
}) => void): IDisposable;
export declare function autorunIterableDelta<T>(getValue: (reader: IReader) => Iterable<T>, handler: (args: {
    addedValues: T[];
    removedValues: T[];
}) => void, getUniqueIdentifier?: (value: T) => unknown): IDisposable;
export declare enum AutorunState {
    dependenciesMightHaveChanged = 1,
    stale = 2,
    upToDate = 3
}
export declare class AutorunObserver<TChangeSummary = any> implements IObserver, IReader, IDisposable {
    readonly _debugNameData: DebugNameData;
    readonly _runFn: (reader: IReader, changeSummary: TChangeSummary) => void;
    private readonly createChangeSummary;
    private readonly _handleChange;
    _state: AutorunState;
    private updateCount;
    private disposed;
    _dependencies: Set<IObservable<any>>;
    private dependenciesToBeRemoved;
    private changeSummary;
    _isRunning: boolean;
    get debugName(): string;
    constructor(_debugNameData: DebugNameData, _runFn: (reader: IReader, changeSummary: TChangeSummary) => void, createChangeSummary: (() => TChangeSummary) | undefined, _handleChange: ((context: IChangeContext, summary: TChangeSummary) => boolean) | undefined);
    dispose(): void;
    private _run;
    toString(): string;
    beginUpdate(_observable: IObservable<any>): void;
    endUpdate(_observable: IObservable<any>): void;
    handlePossibleChange(observable: IObservable<any>): void;
    handleChange<T, TChange>(observable: IObservableWithChange<T, TChange>, change: TChange): void;
    private _isDependency;
    readObservable<T>(observable: IObservable<T>): T;
}
export declare namespace autorun {
    const Observer: typeof AutorunObserver;
}
