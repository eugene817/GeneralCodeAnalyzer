import { Emitter, Event } from "../../../base/common/event.js";
import { Keybinding, ResolvedKeybinding } from "../../../base/common/keybindings.js";
import { Disposable } from "../../../base/common/lifecycle.js";
import { ICommandService } from "../../commands/common/commands.service.js";
import { IContextKeyServiceTarget } from "../../contextkey/common/contextkey.js";
import { IContextKeyService } from "../../contextkey/common/contextkey.service.js";
import { IKeyboardEvent, KeybindingsSchemaContribution } from "./keybinding.js";
import { IKeybindingService } from "./keybinding.service.js";
import { ResolutionResult, KeybindingResolver } from "./keybindingResolver.js";
import { ResolvedKeybindingItem } from "./resolvedKeybindingItem.js";
import { ILogService } from "../../log/common/log.service.js";
import { INotificationService } from "../../notification/common/notification.service.js";
import { ITelemetryService } from "../../telemetry/common/telemetry.service.js";
export declare abstract class AbstractKeybindingService extends Disposable implements IKeybindingService {
    private _contextKeyService;
    protected _commandService: ICommandService;
    protected _telemetryService: ITelemetryService;
    private _notificationService;
    protected _logService: ILogService;
    _serviceBrand: undefined;
    protected readonly _onDidUpdateKeybindings: Emitter<void>;
    get onDidUpdateKeybindings(): Event<void>;
    private _currentChords;
    private _currentChordChecker;
    private _currentChordStatusMessage;
    private _ignoreSingleModifiers;
    private _currentSingleModifier;
    private _currentSingleModifierClearTimeout;
    protected _currentlyDispatchingCommandId: string | null;
    protected _logging: boolean;
    get inChordMode(): boolean;
    constructor(_contextKeyService: IContextKeyService, _commandService: ICommandService, _telemetryService: ITelemetryService, _notificationService: INotificationService, _logService: ILogService);
    dispose(): void;
    protected abstract _getResolver(): KeybindingResolver;
    protected abstract _documentHasFocus(): boolean;
    abstract resolveKeybinding(keybinding: Keybinding): ResolvedKeybinding[];
    abstract resolveKeyboardEvent(keyboardEvent: IKeyboardEvent): ResolvedKeybinding;
    abstract resolveUserBinding(userBinding: string): ResolvedKeybinding[];
    abstract registerSchemaContribution(contribution: KeybindingsSchemaContribution): void;
    abstract _dumpDebugInfo(): string;
    abstract _dumpDebugInfoJSON(): string;
    getDefaultKeybindingsContent(): string;
    toggleLogging(): boolean;
    protected _log(str: string): void;
    getDefaultKeybindings(): readonly ResolvedKeybindingItem[];
    getKeybindings(): readonly ResolvedKeybindingItem[];
    customKeybindingsCount(): number;
    lookupKeybindings(commandId: string): ResolvedKeybinding[];
    lookupKeybinding(commandId: string, context?: IContextKeyService, enforceContextCheck?: boolean): ResolvedKeybinding | undefined;
    dispatchEvent(e: IKeyboardEvent, target: IContextKeyServiceTarget): boolean;
    softDispatch(e: IKeyboardEvent, target: IContextKeyServiceTarget): ResolutionResult;
    private _scheduleLeaveChordMode;
    private _expectAnotherChord;
    private _leaveChordMode;
    dispatchByUserSettingsLabel(userSettingsLabel: string, target: IContextKeyServiceTarget): void;
    protected _dispatch(e: IKeyboardEvent, target: IContextKeyServiceTarget): boolean;
    protected _singleModifierDispatch(e: IKeyboardEvent, target: IContextKeyServiceTarget): boolean;
    private _doDispatch;
    abstract enableKeybindingHoldMode(commandId: string): Promise<void> | undefined;
    mightProducePrintableCharacter(event: IKeyboardEvent): boolean;
}
