import { VSBuffer, VSBufferReadable, VSBufferReadableStream } from "../../../base/common/buffer.js";
import { CancellationToken } from "../../../base/common/cancellation.js";
import { Event } from "../../../base/common/event.js";
import { IDisposable } from "../../../base/common/lifecycle.js";
import { URI } from "../../../base/common/uri.js";
import { IFileSystemProviderRegistrationEvent, IFileSystemProviderCapabilitiesChangeEvent, IFileSystemProviderActivationEvent, IFileSystemProvider, FileSystemProviderCapabilities, FileChangesEvent, FileOperationEvent, IResolveMetadataFileOptions, IFileStatWithMetadata, IResolveFileOptions, IFileStat, IFileStatResult, IFileStatWithPartialMetadata, IReadFileOptions, IFileContent, IReadFileStreamOptions, IFileStreamContent, IWriteFileOptions, ICreateFileOptions, IFileDeleteOptions, IWatchOptionsWithoutCorrelation, IFileSystemWatcher } from "./files.js";
export declare const IFileService: import("../../instantiation/common/instantiation.js").ServiceIdentifier<IFileService>;
export interface IFileService {
    readonly _serviceBrand: undefined;
    readonly onDidChangeFileSystemProviderRegistrations: Event<IFileSystemProviderRegistrationEvent>;
    readonly onDidChangeFileSystemProviderCapabilities: Event<IFileSystemProviderCapabilitiesChangeEvent>;
    readonly onWillActivateFileSystemProvider: Event<IFileSystemProviderActivationEvent>;
    registerProvider(scheme: string, provider: IFileSystemProvider): IDisposable;
    getProvider(scheme: string): IFileSystemProvider | undefined;
    activateProvider(scheme: string): Promise<void>;
    canHandleResource(resource: URI): Promise<boolean>;
    hasProvider(resource: URI): boolean;
    hasCapability(resource: URI, capability: FileSystemProviderCapabilities): boolean;
    listCapabilities(): Iterable<{
        scheme: string;
        capabilities: FileSystemProviderCapabilities;
    }>;
    readonly onDidFilesChange: Event<FileChangesEvent>;
    readonly onDidRunOperation: Event<FileOperationEvent>;
    resolve(resource: URI, options: IResolveMetadataFileOptions): Promise<IFileStatWithMetadata>;
    resolve(resource: URI, options?: IResolveFileOptions): Promise<IFileStat>;
    resolveAll(toResolve: {
        resource: URI;
        options: IResolveMetadataFileOptions;
    }[]): Promise<IFileStatResult[]>;
    resolveAll(toResolve: {
        resource: URI;
        options?: IResolveFileOptions;
    }[]): Promise<IFileStatResult[]>;
    stat(resource: URI): Promise<IFileStatWithPartialMetadata>;
    exists(resource: URI): Promise<boolean>;
    readFile(resource: URI, options?: IReadFileOptions, token?: CancellationToken): Promise<IFileContent>;
    readFileStream(resource: URI, options?: IReadFileStreamOptions, token?: CancellationToken): Promise<IFileStreamContent>;
    writeFile(resource: URI, bufferOrReadableOrStream: VSBuffer | VSBufferReadable | VSBufferReadableStream, options?: IWriteFileOptions): Promise<IFileStatWithMetadata>;
    move(source: URI, target: URI, overwrite?: boolean): Promise<IFileStatWithMetadata>;
    canMove(source: URI, target: URI, overwrite?: boolean): Promise<Error | true>;
    copy(source: URI, target: URI, overwrite?: boolean): Promise<IFileStatWithMetadata>;
    canCopy(source: URI, target: URI, overwrite?: boolean): Promise<Error | true>;
    cloneFile(source: URI, target: URI): Promise<void>;
    createFile(resource: URI, bufferOrReadableOrStream?: VSBuffer | VSBufferReadable | VSBufferReadableStream, options?: ICreateFileOptions): Promise<IFileStatWithMetadata>;
    canCreateFile(resource: URI, options?: ICreateFileOptions): Promise<Error | true>;
    createFolder(resource: URI): Promise<IFileStatWithMetadata>;
    del(resource: URI, options?: Partial<IFileDeleteOptions>): Promise<void>;
    canDelete(resource: URI, options?: Partial<IFileDeleteOptions>): Promise<Error | true>;
    readonly onDidWatchError: Event<Error>;
    createWatcher(resource: URI, options: IWatchOptionsWithoutCorrelation & {
        recursive: false;
    }): IFileSystemWatcher;
    watch(resource: URI, options?: IWatchOptionsWithoutCorrelation): IDisposable;
    dispose(): void;
}
