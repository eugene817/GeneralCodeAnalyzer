
import { __decorate, __param } from '@codingame/monaco-vscode-api/external/tslib/tslib.es6';
import { localize } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import { Disposable, DisposableStore } from '@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle';
import { isMacintosh, isWeb, OS } from '@codingame/monaco-vscode-api/vscode/vs/base/common/platform';
import { IKeybindingService } from '@codingame/monaco-vscode-api/vscode/vs/platform/keybinding/common/keybinding.service';
import { WorkbenchState } from '@codingame/monaco-vscode-api/vscode/vs/platform/workspace/common/workspace';
import { IWorkspaceContextService } from '@codingame/monaco-vscode-api/vscode/vs/platform/workspace/common/workspace.service';
import { IConfigurationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/configuration/common/configuration.service';
import { h, append, clearNode, $ } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/dom';
import { KeybindingLabel } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/ui/keybindingLabel/keybindingLabel';
import { CommandsRegistry } from '@codingame/monaco-vscode-api/vscode/vs/platform/commands/common/commands';
import { ContextKeyExpr } from '@codingame/monaco-vscode-api/vscode/vs/platform/contextkey/common/contextkey';
import { IContextKeyService } from '@codingame/monaco-vscode-api/vscode/vs/platform/contextkey/common/contextkey.service';
import { defaultKeybindingLabelStyles } from '@codingame/monaco-vscode-api/vscode/vs/platform/theme/browser/defaultStyles';
import { registerColor, transparent } from '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colorUtils';
import '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/baseColors';
import '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/chartsColors';
import { editorForeground } from '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/editorColors';
import '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/inputColors';
import '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/listColors';
import '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/menuColors';
import '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/minimapColors';
import '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/miscColors';
import '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/quickpickColors';
import '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/searchColors';
import { StorageScope, WillSaveStateReason, StorageTarget } from '@codingame/monaco-vscode-api/vscode/vs/platform/storage/common/storage';
import { IStorageService } from '@codingame/monaco-vscode-api/vscode/vs/platform/storage/common/storage.service';
import { coalesce, shuffle } from '@codingame/monaco-vscode-api/vscode/vs/base/common/arrays';

var EditorGroupWatermark_1;
const showCommands = { text: ( localize(3170, "Show All Commands")), id: 'workbench.action.showCommands' };
const gotoFile = { text: ( localize(3171, "Go to File")), id: 'workbench.action.quickOpen' };
const openFile = { text: ( localize(3172, "Open File")), id: 'workbench.action.files.openFile' };
const openFolder = { text: ( localize(3173, "Open Folder")), id: 'workbench.action.files.openFolder' };
const openFileOrFolder = { text: ( localize(3174, "Open File or Folder")), id: 'workbench.action.files.openFileFolder' };
const openRecent = { text: ( localize(3175, "Open Recent")), id: 'workbench.action.openRecent' };
const newUntitledFile = { text: ( localize(3176, "New Untitled Text File")), id: 'workbench.action.files.newUntitledFile' };
const findInFiles = { text: ( localize(3177, "Find in Files")), id: 'workbench.action.findInFiles' };
const toggleTerminal = { text: ( localize(3178, "Toggle Terminal")), id: 'workbench.action.terminal.toggleTerminal', when: { web: ( ContextKeyExpr.equals('terminalProcessSupported', true)) } };
const startDebugging = { text: ( localize(3179, "Start Debugging")), id: 'workbench.action.debug.start', when: { web: ( ContextKeyExpr.equals('terminalProcessSupported', true)) } };
const openSettings = { text: ( localize(3180, "Open Settings")), id: 'workbench.action.openSettings' };
const showCopilot = ( ContextKeyExpr.or(( ContextKeyExpr.equals('chatSetupHidden', false)), ( ContextKeyExpr.equals('chatSetupInstalled', true))));
const openChat = { text: ( localize(3181, "Open Chat")), id: 'workbench.action.chat.open', when: { native: showCopilot, web: showCopilot } };
const openCopilotEdits = { text: ( localize(3182, "Open Copilot Edits")), id: 'workbench.action.chat.openEditSession', when: { native: showCopilot, web: showCopilot } };
const emptyWindowEntries = coalesce([
    showCommands,
    ...(isMacintosh && !isWeb ? [openFileOrFolder] : [openFile, openFolder]),
    openRecent,
    isMacintosh && !isWeb ? newUntitledFile : undefined,
    openChat
]);
const randomEmptyWindowEntries = [
];
const workspaceEntries = [
    showCommands,
    gotoFile,
    openChat
];
const randomWorkspaceEntries = [
    findInFiles,
    startDebugging,
    toggleTerminal,
    openSettings,
    openCopilotEdits
];
let EditorGroupWatermark = class EditorGroupWatermark extends Disposable {
    static { EditorGroupWatermark_1 = this; }
    static { this.CACHED_WHEN = 'editorGroupWatermark.whenConditions'; }
    constructor(container, keybindingService, contextService, contextKeyService, configurationService, storageService) {
        super();
        this.keybindingService = keybindingService;
        this.contextService = contextService;
        this.contextKeyService = contextKeyService;
        this.configurationService = configurationService;
        this.storageService = storageService;
        this.cachedWhen = this.storageService.getObject(EditorGroupWatermark_1.CACHED_WHEN, StorageScope.PROFILE, Object.create(null));
        this.transientDisposables = this._register(( new DisposableStore()));
        this.keybindingLabels = this._register(( new DisposableStore()));
        this.enabled = false;
        this.workbenchState = this.contextService.getWorkbenchState();
        const elements = h('.editor-group-watermark', [
            h('.letterpress'),
            h('.shortcuts@shortcuts'),
        ]);
        append(container, elements.root);
        this.shortcuts = elements.shortcuts;
        this.registerListeners();
        this.render();
    }
    registerListeners() {
        this._register(this.configurationService.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('workbench.tips.enabled') && this.enabled !== this.configurationService.getValue('workbench.tips.enabled')) {
                this.render();
            }
        }));
        this._register(this.contextService.onDidChangeWorkbenchState(workbenchState => {
            if (this.workbenchState !== workbenchState) {
                this.workbenchState = workbenchState;
                this.render();
            }
        }));
        this._register(this.storageService.onWillSaveState(e => {
            if (e.reason === WillSaveStateReason.SHUTDOWN) {
                const entries = [...emptyWindowEntries, ...randomEmptyWindowEntries, ...workspaceEntries, ...randomWorkspaceEntries];
                for (const entry of entries) {
                    const when = isWeb ? entry.when?.web : entry.when?.native;
                    if (when) {
                        this.cachedWhen[entry.id] = this.contextKeyService.contextMatchesRules(when);
                    }
                }
                this.storageService.store(EditorGroupWatermark_1.CACHED_WHEN, JSON.stringify(this.cachedWhen), StorageScope.PROFILE, StorageTarget.MACHINE);
            }
        }));
    }
    render() {
        this.enabled = this.configurationService.getValue('workbench.tips.enabled');
        clearNode(this.shortcuts);
        this.transientDisposables.clear();
        if (!this.enabled) {
            return;
        }
        const fixedEntries = this.filterEntries(this.workbenchState !== WorkbenchState.EMPTY ? workspaceEntries : emptyWindowEntries, false );
        const randomEntries = this.filterEntries(this.workbenchState !== WorkbenchState.EMPTY ? randomWorkspaceEntries : randomEmptyWindowEntries, true ).slice(0, Math.max(0, 5 - fixedEntries.length));
        const entries = [...fixedEntries, ...randomEntries];
        const box = append(this.shortcuts, $('.watermark-box'));
        const update = () => {
            clearNode(box);
            this.keybindingLabels.clear();
            for (const entry of entries) {
                const keys = this.keybindingService.lookupKeybinding(entry.id);
                if (!keys) {
                    continue;
                }
                const dl = append(box, $('dl'));
                const dt = append(dl, $('dt'));
                dt.textContent = entry.text;
                const dd = append(dl, $('dd'));
                const label = this.keybindingLabels.add(( new KeybindingLabel(
                    dd,
                    OS,
                    { renderUnboundKeybindings: true, ...defaultKeybindingLabelStyles }
                )));
                label.set(keys);
            }
        };
        update();
        this.transientDisposables.add(this.keybindingService.onDidUpdateKeybindings(update));
    }
    filterEntries(entries, shuffleEntries) {
        const filteredEntries = entries
            .filter(entry => (isWeb && !entry.when?.web) || (!isWeb && !entry.when?.native) || this.cachedWhen[entry.id])
            .filter(entry => !!CommandsRegistry.getCommand(entry.id))
            .filter(entry => !!this.keybindingService.lookupKeybinding(entry.id));
        if (shuffleEntries) {
            shuffle(filteredEntries);
        }
        return filteredEntries;
    }
};
EditorGroupWatermark = EditorGroupWatermark_1 = ( __decorate([
    ( __param(1, IKeybindingService)),
    ( __param(2, IWorkspaceContextService)),
    ( __param(3, IContextKeyService)),
    ( __param(4, IConfigurationService)),
    ( __param(5, IStorageService))
], EditorGroupWatermark));
registerColor('editorWatermark.foreground', { dark: ( transparent(editorForeground, 0.6)), light: ( transparent(editorForeground, 0.68)), hcDark: editorForeground, hcLight: editorForeground }, ( localize(3183, 'Foreground color for the labels in the editor watermark.')));

export { EditorGroupWatermark };
