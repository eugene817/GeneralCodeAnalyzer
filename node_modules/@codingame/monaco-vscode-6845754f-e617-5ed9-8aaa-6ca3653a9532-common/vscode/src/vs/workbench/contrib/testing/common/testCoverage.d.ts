import { CancellationToken } from "@codingame/monaco-vscode-api/vscode/vs/base/common/cancellation";
import { ResourceMap } from "@codingame/monaco-vscode-api/vscode/vs/base/common/map";
import { ITransaction } from "@codingame/monaco-vscode-api/vscode/vs/base/common/observable";
import { IPrefixTreeNode, WellDefinedPrefixTree } from "@codingame/monaco-vscode-api/vscode/vs/base/common/prefixTree";
import { URI } from "@codingame/monaco-vscode-api/vscode/vs/base/common/uri";
import { IUriIdentityService } from "@codingame/monaco-vscode-api/vscode/vs/platform/uriIdentity/common/uriIdentity.service";
import { TestId } from "@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/testing/common/testId";
import { LiveTestResult } from "./testResult.js";
import { CoverageDetails, ICoverageCount, IFileCoverage } from "@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/testing/common/testTypes";
export interface ICoverageAccessor {
    getCoverageDetails: (id: string, testId: string | undefined, token: CancellationToken) => Promise<CoverageDetails[]>;
}
export declare class TestCoverage {
    readonly result: LiveTestResult;
    readonly fromTaskId: string;
    private readonly uriIdentityService;
    private readonly accessor;
    private readonly fileCoverage;
    readonly didAddCoverage: import("@codingame/monaco-vscode-api/vscode/vs/base/common/observable").IObservableSignal<IPrefixTreeNode<AbstractFileCoverage>[]>;
    readonly tree: WellDefinedPrefixTree<AbstractFileCoverage>;
    readonly associatedData: Map<unknown, unknown>;
    constructor(result: LiveTestResult, fromTaskId: string, uriIdentityService: IUriIdentityService, accessor: ICoverageAccessor);
    allPerTestIDs(): Generator<string, void, unknown>;
    append(coverage: IFileCoverage, tx: ITransaction | undefined): void;
    filterTreeForTest(testId: TestId): WellDefinedPrefixTree<AbstractFileCoverage>;
    getAllFiles(): ResourceMap<FileCoverage>;
    getUri(uri: URI): FileCoverage | undefined;
    getComputedForUri(uri: URI): AbstractFileCoverage | undefined;
    private treePathForUri;
    private treePathToUri;
}
export declare const getTotalCoveragePercent: (statement: ICoverageCount, branch: ICoverageCount | undefined, function_: ICoverageCount | undefined) => number;
export declare abstract class AbstractFileCoverage {
    readonly fromResult: LiveTestResult;
    id: string;
    readonly uri: URI;
    statement: ICoverageCount;
    branch?: ICoverageCount;
    declaration?: ICoverageCount;
    readonly didChange: import("@codingame/monaco-vscode-api/vscode/vs/base/common/observable").IObservableSignal<void>;
    get tpc(): number;
    perTestData?: Set<string>;
    constructor(coverage: IFileCoverage, fromResult: LiveTestResult);
}
export declare class ComputedFileCoverage extends AbstractFileCoverage {
}
export declare class BypassedFileCoverage extends ComputedFileCoverage {
    constructor(uri: URI, result: LiveTestResult);
}
export declare class FileCoverage extends AbstractFileCoverage {
    private readonly accessor;
    private _details?;
    private resolved?;
    private _detailsForTest?;
    get hasSynchronousDetails(): boolean | undefined;
    constructor(coverage: IFileCoverage, fromResult: LiveTestResult, accessor: ICoverageAccessor);
    detailsForTest(_testId: TestId, token?: Readonly<CancellationToken>): Promise<CoverageDetails[]>;
    details(token?: Readonly<CancellationToken>): Promise<CoverageDetails[]>;
}
export declare const totalFromCoverageDetails: (uri: URI, details: CoverageDetails[]) => IFileCoverage;
