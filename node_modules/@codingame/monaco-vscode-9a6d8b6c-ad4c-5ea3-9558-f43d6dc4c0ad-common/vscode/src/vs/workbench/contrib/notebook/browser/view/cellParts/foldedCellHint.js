
import { __decorate, __param } from '@codingame/monaco-vscode-api/external/tslib/tslib.es6';
import { hide, reset, show, $, addDisposableListener, EventType } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/dom';
import { Codicon } from '@codingame/monaco-vscode-api/vscode/vs/base/common/codicons';
import { ThemeIcon } from '@codingame/monaco-vscode-api/vscode/vs/base/common/themables';
import { localize } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import { FoldingController } from '../../controller/foldingController.js';
import { CellEditState, CellFoldingState } from '../../notebookBrowser.js';
import { CellContentPart } from '../cellPart.js';
import { executingStateIcon } from '../../notebookIcons.js';
import { INotebookExecutionStateService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/notebook/common/notebookExecutionStateService.service';
import { CellKind, NotebookCellExecutionState } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/notebook/common/notebookCommon';
import { MutableDisposable } from '@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle';

let FoldedCellHint = class FoldedCellHint extends CellContentPart {
    constructor(_notebookEditor, _container, _notebookExecutionStateService) {
        super();
        this._notebookEditor = _notebookEditor;
        this._container = _container;
        this._notebookExecutionStateService = _notebookExecutionStateService;
        this._runButtonListener = this._register(( new MutableDisposable()));
        this._cellExecutionListener = this._register(( new MutableDisposable()));
    }
    didRenderCell(element) {
        this.update(element);
    }
    update(element) {
        if (!this._notebookEditor.hasModel()) {
            this._cellExecutionListener.clear();
            this._runButtonListener.clear();
            return;
        }
        if (element.isInputCollapsed || element.getEditState() === CellEditState.Editing) {
            this._cellExecutionListener.clear();
            this._runButtonListener.clear();
            hide(this._container);
        }
        else if (element.foldingState === CellFoldingState.Collapsed) {
            const idx = this._notebookEditor.getViewModel().getCellIndex(element);
            const length = this._notebookEditor.getViewModel().getFoldedLength(idx);
            const runSectionButton = this.getRunFoldedSectionButton({ start: idx, end: idx + length + 1 });
            if (!runSectionButton) {
                reset(this._container, this.getHiddenCellsLabel(length), this.getHiddenCellHintButton(element));
            }
            else {
                reset(this._container, runSectionButton, this.getHiddenCellsLabel(length), this.getHiddenCellHintButton(element));
            }
            show(this._container);
            const foldHintTop = element.layoutInfo.previewHeight;
            this._container.style.top = `${foldHintTop}px`;
        }
        else {
            this._cellExecutionListener.clear();
            this._runButtonListener.clear();
            hide(this._container);
        }
    }
    getHiddenCellsLabel(num) {
        const label = num === 1 ?
            ( localize(8042, "1 cell hidden")) :
            ( localize(8043, "{0} cells hidden", num));
        return $('span.notebook-folded-hint-label', undefined, label);
    }
    getHiddenCellHintButton(element) {
        const expandIcon = $('span.cell-expand-part-button');
        expandIcon.classList.add(...ThemeIcon.asClassNameArray(Codicon.more));
        this._register(addDisposableListener(expandIcon, EventType.CLICK, () => {
            const controller = this._notebookEditor.getContribution(FoldingController.id);
            const idx = this._notebookEditor.getCellIndex(element);
            if (typeof idx === 'number') {
                controller.setFoldingStateDown(idx, CellFoldingState.Expanded, 1);
            }
        }));
        return expandIcon;
    }
    getRunFoldedSectionButton(range) {
        const runAllContainer = $('span.folded-cell-run-section-button');
        const cells = this._notebookEditor.getCellsInRange(range);
        const hasCodeCells = ( cells.some(cell => cell.cellKind === CellKind.Code));
        if (!hasCodeCells) {
            return undefined;
        }
        const isRunning = ( cells.some(cell => {
            const cellExecution = this._notebookExecutionStateService.getCellExecution(cell.uri);
            return cellExecution && cellExecution.state === NotebookCellExecutionState.Executing;
        }));
        const runAllIcon = isRunning ?
            ThemeIcon.modify(executingStateIcon, 'spin') :
            Codicon.play;
        runAllContainer.classList.add(...ThemeIcon.asClassNameArray(runAllIcon));
        this._runButtonListener.value = addDisposableListener(runAllContainer, EventType.CLICK, () => {
            this._notebookEditor.executeNotebookCells(cells);
        });
        this._cellExecutionListener.value = this._notebookExecutionStateService.onDidChangeExecution(() => {
            const isRunning = ( cells.some(cell => {
                const cellExecution = this._notebookExecutionStateService.getCellExecution(cell.uri);
                return cellExecution && cellExecution.state === NotebookCellExecutionState.Executing;
            }));
            const runAllIcon = isRunning ?
                ThemeIcon.modify(executingStateIcon, 'spin') :
                Codicon.play;
            runAllContainer.className = '';
            runAllContainer.classList.add('folded-cell-run-section-button', ...ThemeIcon.asClassNameArray(runAllIcon));
        });
        return runAllContainer;
    }
    updateInternalLayoutNow(element) {
        this.update(element);
    }
};
FoldedCellHint = ( __decorate([
    ( __param(2, INotebookExecutionStateService))
], FoldedCellHint));

export { FoldedCellHint };
