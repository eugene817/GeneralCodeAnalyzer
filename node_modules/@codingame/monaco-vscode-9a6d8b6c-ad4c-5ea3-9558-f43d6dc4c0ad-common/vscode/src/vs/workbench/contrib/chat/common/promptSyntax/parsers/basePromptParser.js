
import { __decorate, __param } from '@codingame/monaco-vscode-api/external/tslib/tslib.es6';
import { localize } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import { URI } from '@codingame/monaco-vscode-api/vscode/vs/base/common/uri';
import { ChatPromptCodec } from '../codecs/chatPromptCodec.js';
import { Emitter } from '@codingame/monaco-vscode-api/vscode/vs/base/common/event';
import { assert } from '@codingame/monaco-vscode-api/vscode/vs/base/common/assert';
import { FileReference } from '../codecs/tokens/fileReference.js';
import { assertDefined } from '@codingame/monaco-vscode-api/vscode/vs/base/common/types';
import { DeferredPromise } from '@codingame/monaco-vscode-api/vscode/vs/base/common/async';
import { ILogService } from '@codingame/monaco-vscode-api/vscode/vs/platform/log/common/log.service';
import { basename, extUri } from '@codingame/monaco-vscode-api/vscode/vs/base/common/resources';
import { isPromptFile } from '@codingame/monaco-vscode-52bb4d5b-ba1a-57fd-9bee-b28824214eac-common/vscode/vs/platform/prompts/common/constants';
import { ObservableDisposable } from '../../../../../../base/common/observableDisposable.js';
import { FilePromptContentProvider } from '../contentProviders/filePromptContentsProvider.js';
import { IInstantiationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/instantiation/common/instantiation';
import { MarkdownLink } from '../../../../../../editor/common/codecs/markdownCodec/tokens/markdownLink.js';
import { RecursiveReference, ParseError, FolderReference, NotPromptFile, OpenFailed, FailedToResolveContentsStream } from '../../promptFileReferenceErrors.js';

const errorMessages = {
    recursion: ( localize(4868, 'Recursive reference found')),
    fileOpenFailed: ( localize(4869, 'Failed to open file')),
    streamOpenFailed: ( localize(4870, 'Failed to open contents stream')),
    brokenChild: ( localize(4871, 'Contains a broken reference that will be ignored')),
};
let BasePromptParser = class BasePromptParser extends ObservableDisposable {
    onUpdate(callback) {
        this._register(this._onUpdate.event(callback));
        return this;
    }
    get errorCondition() {
        return this._errorCondition;
    }
    get resolveFailed() {
        if (!this.firstParseResult.gotFirstResult) {
            return undefined;
        }
        return !!this._errorCondition;
    }
    async settled() {
        assert(this.started, 'Cannot wait on the parser that did not start yet.');
        await this.firstParseResult.promise;
        if (this.errorCondition) {
            return this;
        }
        assertDefined(this.stream, 'No stream reference found.');
        await this.stream.settled;
        return this;
    }
    async allSettled() {
        await this.settled();
        await Promise.allSettled(( this.references.map((reference) => {
            return reference.allSettled();
        })));
        return this;
    }
    constructor(promptContentsProvider, seenReferences = [], instantiationService, logService) {
        super();
        this.promptContentsProvider = promptContentsProvider;
        this.instantiationService = instantiationService;
        this.logService = logService;
        this._references = [];
        this._onUpdate = this._register(( new Emitter()));
        this.firstParseResult = ( new FirstParseResult());
        this.started = false;
        this._onUpdate.fire = this._onUpdate.fire.bind(this._onUpdate);
        this._register(promptContentsProvider);
        if (seenReferences.includes(this.uri.path)) {
            seenReferences.push(this.uri.path);
            this._errorCondition = ( new RecursiveReference(this.uri, seenReferences));
            this._onUpdate.fire();
            this.firstParseResult.complete();
            return this;
        }
        seenReferences.push(this.uri.path);
        this._register(this.promptContentsProvider.onContentChanged((streamOrError) => {
            this.onContentsChanged(streamOrError, seenReferences);
            this.firstParseResult.complete();
        }));
    }
    onContentsChanged(streamOrError, seenReferences) {
        this.stream?.dispose();
        delete this.stream;
        delete this._errorCondition;
        this.disposeReferences();
        if (streamOrError instanceof ParseError) {
            this._errorCondition = streamOrError;
            this._onUpdate.fire();
            return;
        }
        this.stream = ChatPromptCodec.decode(streamOrError);
        this.stream.on('error', this.onStreamEnd.bind(this, this.stream));
        this.stream.on('end', this.onStreamEnd.bind(this, this.stream));
        this.stream.on('data', (token) => {
            if (token instanceof FileReference) {
                this.onReference(token, [...seenReferences]);
            }
            if (token instanceof MarkdownLink && !token.isURL) {
                this.onReference(token, [...seenReferences]);
            }
        });
        if (this.stream.disposed) {
            this.logService.warn(`[prompt parser][${basename(this.uri)}] cannot start stream that has been already disposed, aborting`);
            return;
        }
        this.stream.start();
    }
    onReference(token, seenReferences) {
        const fileReference = this.instantiationService
            .createInstance(PromptFileReference, token, this.dirname, seenReferences);
        this._references.push(fileReference);
        fileReference.onUpdate(this._onUpdate.fire);
        fileReference.start();
        this._onUpdate.fire();
        return this;
    }
    onStreamEnd(_stream, error) {
        if (error) {
            this.logService.warn(`[prompt parser][${basename(this.uri)}] received an error on the chat prompt decoder stream: ${error}`);
        }
        this._onUpdate.fire();
        return this;
    }
    disposeReferences() {
        for (const reference of [...this._references]) {
            reference.dispose();
        }
        this._references.length = 0;
    }
    start() {
        if (this.started) {
            return this;
        }
        this.started = true;
        if (this.errorCondition) {
            return this;
        }
        this.promptContentsProvider.start();
        return this;
    }
    get uri() {
        return this.promptContentsProvider.uri;
    }
    get dirname() {
        return URI.joinPath(this.uri, '..');
    }
    get references() {
        return [...this._references];
    }
    get allReferences() {
        const result = [];
        for (const reference of this.references) {
            result.push(reference);
            if (reference.type === 'file') {
                result.push(...reference.allReferences);
            }
        }
        return result;
    }
    get allValidReferences() {
        return this.allReferences
            .filter((reference) => {
            const { errorCondition } = reference;
            if (!errorCondition) {
                return true;
            }
            if (errorCondition instanceof FolderReference) {
                return false;
            }
            return (errorCondition instanceof NotPromptFile);
        });
    }
    get allValidReferencesUris() {
        return ( this.allValidReferences
            .map(child => child.uri));
    }
    get allErrors() {
        const result = [];
        const childErrorConditions = ( this
            .allReferences
            .filter((childReference) => {
            const { errorCondition } = childReference;
            return errorCondition && !(errorCondition instanceof NotPromptFile);
        })
            .map((childReference) => {
            const { errorCondition } = childReference;
            assertDefined(errorCondition, `Error condition must be present for '${childReference.uri.path}'.`);
            return errorCondition;
        }));
        result.push(...childErrorConditions);
        return result;
    }
    get topError() {
        const errors = [];
        if (this.errorCondition) {
            errors.push(this.errorCondition);
        }
        errors.push(...this.allErrors);
        if (errors.length === 0) {
            return undefined;
        }
        const [firstError, ...restErrors] = errors;
        const isRootError = (firstError === this.errorCondition);
        const prefix = (!isRootError)
            ? `${errorMessages.brokenChild}: `
            : '';
        const moreSuffix = restErrors.length > 0
            ? `\n-\n +${restErrors.length} more error${restErrors.length > 1 ? 's' : ''}`
            : '';
        const errorMessage = this.getErrorMessage(firstError);
        return {
            isRootError,
            message: `${prefix}${errorMessage}${moreSuffix}`,
        };
    }
    getErrorMessage(error) {
        if (error instanceof OpenFailed) {
            return `${errorMessages.fileOpenFailed} '${error.uri.path}'.`;
        }
        if (error instanceof FailedToResolveContentsStream) {
            return `${errorMessages.streamOpenFailed} '${error.uri.path}'.`;
        }
        if (error instanceof RecursiveReference) {
            const { recursivePath } = error;
            const recursivePathString = ( recursivePath
                .map((path) => {
                return basename(URI.file(path));
            }))
                .join(' -> ');
            return `${errorMessages.recursion}:\n${recursivePathString}`;
        }
        return error.message;
    }
    sameUri(otherUri) {
        return ( this.uri.toString()) === ( otherUri.toString());
    }
    get isPromptSnippet() {
        return isPromptFile(this.uri);
    }
    toString() {
        return `prompt:${this.uri.path}`;
    }
    dispose() {
        if (this.disposed) {
            return;
        }
        this.disposeReferences();
        this.stream?.dispose();
        this._onUpdate.fire();
        super.dispose();
    }
};
BasePromptParser = ( __decorate([
    ( __param(2, IInstantiationService)),
    ( __param(3, ILogService))
], BasePromptParser));
let PromptFileReference = class PromptFileReference extends BasePromptParser {
    constructor(token, dirname, seenReferences = [], initService, logService) {
        const fileUri = extUri.resolvePath(dirname, token.path);
        const provider = initService.createInstance(FilePromptContentProvider, fileUri);
        super(provider, seenReferences, initService, logService);
        this.token = token;
        this.type = 'file';
        this.range = this.token.range;
        this.path = this.token.path;
        this.text = this.token.text;
    }
    get linkRange() {
        if (this.token instanceof FileReference) {
            return this.token.linkRange;
        }
        if (this.token instanceof MarkdownLink) {
            return this.token.linkRange;
        }
        return undefined;
    }
    toString() {
        const prefix = (this.token instanceof FileReference)
            ? FileReference.TOKEN_START
            : 'md-link:';
        return `${prefix}${this.uri.path}`;
    }
    getErrorMessage(error) {
        if (error instanceof OpenFailed) {
            return `${errorMessages.fileOpenFailed} '${error.uri.path}'.`;
        }
        return super.getErrorMessage(error);
    }
};
PromptFileReference = ( __decorate([
    ( __param(3, IInstantiationService)),
    ( __param(4, ILogService))
], PromptFileReference));
class FirstParseResult extends DeferredPromise {
    constructor() {
        super(...arguments);
        this._gotResult = false;
    }
    get gotFirstResult() {
        return this._gotResult;
    }
    get promise() {
        return this.p;
    }
    complete() {
        this._gotResult = true;
        return super.complete(void 0);
    }
}

export { BasePromptParser, PromptFileReference };
