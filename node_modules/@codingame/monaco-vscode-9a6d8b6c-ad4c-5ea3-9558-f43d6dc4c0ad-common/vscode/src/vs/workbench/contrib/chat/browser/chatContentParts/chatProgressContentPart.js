
import { __decorate, __param } from '@codingame/monaco-vscode-api/external/tslib/tslib.es6';
import { $, append } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/dom';
import { alert } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/ui/aria/aria';
import { Codicon } from '@codingame/monaco-vscode-api/vscode/vs/base/common/codicons';
import { MarkdownString } from '@codingame/monaco-vscode-api/vscode/vs/base/common/htmlContent';
import { Disposable } from '@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle';
import { ThemeIcon } from '@codingame/monaco-vscode-api/vscode/vs/base/common/themables';
import { URI } from '@codingame/monaco-vscode-api/vscode/vs/base/common/uri';
import { localize } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import { IInstantiationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/instantiation/common/instantiation';
import { isResponseVM } from '../../common/chatViewModel.js';
import { InlineAnchorWidget } from '../chatInlineAnchorWidget.js';
import { IChatMarkdownAnchorService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/browser/chatContentParts/chatMarkdownAnchorService.service';

let ChatProgressContentPart = class ChatProgressContentPart extends Disposable {
    constructor(progress, renderer, context, forceShowSpinner, forceShowMessage, icon, instantiationService, chatMarkdownAnchorService) {
        super();
        this.instantiationService = instantiationService;
        this.chatMarkdownAnchorService = chatMarkdownAnchorService;
        const followingContent = context.content.slice(context.contentIndex + 1);
        this.showSpinner = forceShowSpinner ?? shouldShowSpinner(followingContent, context.element);
        this.isHidden = forceShowMessage !== true && ( followingContent.some(part => part.kind !== 'progressMessage'));
        if (this.isHidden) {
            this.domNode = $('');
            return;
        }
        if (this.showSpinner) {
            alert(progress.content.value);
        }
        const codicon = icon ? icon : this.showSpinner ? ThemeIcon.modify(Codicon.loading, 'spin') : Codicon.check;
        const markdown = ( new MarkdownString(progress.content.value, {
            supportThemeIcons: true
        }));
        const result = this._register(renderer.render(markdown));
        result.element.classList.add('progress-step');
        this.renderFileWidgets(result.element);
        this.domNode = $('.progress-container');
        const iconElement = $('div');
        iconElement.classList.add(...ThemeIcon.asClassNameArray(codicon));
        append(this.domNode, iconElement);
        append(this.domNode, result.element);
    }
    renderFileWidgets(element) {
        const links = element.querySelectorAll('a');
        links.forEach(a => {
            if (!a.textContent?.trim()) {
                const href = a.getAttribute('data-href');
                const uri = href ? ( URI.parse(href)) : undefined;
                if (uri?.scheme) {
                    const widget = this._register(this.instantiationService.createInstance(InlineAnchorWidget, a, { kind: 'inlineReference', inlineReference: uri }));
                    this._register(this.chatMarkdownAnchorService.register(widget));
                }
            }
        });
    }
    hasSameContent(other, followingContent, element) {
        if (( followingContent.some(part => part.kind !== 'progressMessage')) && !this.isHidden) {
            return false;
        }
        const showSpinner = shouldShowSpinner(followingContent, element);
        return other.kind === 'progressMessage' && this.showSpinner === showSpinner;
    }
};
ChatProgressContentPart = ( __decorate([
    ( __param(6, IInstantiationService)),
    ( __param(7, IChatMarkdownAnchorService))
], ChatProgressContentPart));
function shouldShowSpinner(followingContent, element) {
    return isResponseVM(element) && !element.isComplete && followingContent.length === 0;
}
let ChatWorkingProgressContentPart = class ChatWorkingProgressContentPart extends ChatProgressContentPart {
    constructor(workingProgress, renderer, context, instantiationService, chatMarkdownAnchorService) {
        const progressMessage = {
            kind: 'progressMessage',
            content: workingProgress.isPaused ?
                ( new MarkdownString()).appendText(( localize(4494, "Paused"))) :
                ( new MarkdownString()).appendText(( localize(4495, "Working")))
        };
        super(progressMessage, renderer, context, undefined, undefined, workingProgress.isPaused ? Codicon.debugPause : undefined, instantiationService, chatMarkdownAnchorService);
        this.workingProgress = workingProgress;
    }
    hasSameContent(other, followingContent, element) {
        return other.kind === 'working' && this.workingProgress.isPaused === other.isPaused;
    }
};
ChatWorkingProgressContentPart = ( __decorate([
    ( __param(3, IInstantiationService)),
    ( __param(4, IChatMarkdownAnchorService))
], ChatWorkingProgressContentPart));
class ChatCustomProgressPart {
    constructor(messageElement, icon) {
        this.domNode = $('.progress-container');
        const iconElement = $('div');
        iconElement.classList.add(...ThemeIcon.asClassNameArray(icon));
        append(this.domNode, iconElement);
        messageElement.classList.add('progress-step');
        append(this.domNode, messageElement);
    }
}

export { ChatCustomProgressPart, ChatProgressContentPart, ChatWorkingProgressContentPart };
