
import { __decorate, __param } from '@codingame/monaco-vscode-api/external/tslib/tslib.es6';
import { Emitter } from '@codingame/monaco-vscode-api/vscode/vs/base/common/event';
import { ChatPromptAttachmentModel } from './chatPromptAttachmentModel.js';
import { PromptsConfig } from '@codingame/monaco-vscode-52bb4d5b-ba1a-57fd-9bee-b28824214eac-common/vscode/vs/platform/prompts/common/config';
import { Disposable, DisposableMap } from '@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle';
import { IInstantiationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/instantiation/common/instantiation';
import { IConfigurationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/configuration/common/configuration.service';

const toChatVariable = (reference, isRoot) => {
    const { uri, isPromptSnippet } = reference;
    let id = `${uri}`;
    if (isPromptSnippet) {
        let prefix = 'vscode.prompt.instructions';
        if (isRoot) {
            prefix += '.root';
        }
        id = `${prefix}__${id}`;
    }
    return {
        id,
        name: uri.fsPath,
        value: uri,
        isSelection: false,
        enabled: true,
        isFile: true,
        isMarkedReadonly: isPromptSnippet,
    };
};
let ChatPromptAttachmentsCollection = class ChatPromptAttachmentsCollection extends Disposable {
    get references() {
        const result = [];
        for (const child of ( this.attachments.values())) {
            result.push(...child.references);
        }
        return result;
    }
    get chatAttachments() {
        const result = [];
        const attachments = [...( this.attachments.values())];
        for (const attachment of attachments) {
            const { reference } = attachment;
            result.push(...( reference.allValidReferences.map((link) => {
                return toChatVariable(link, false);
            })));
            result.push(toChatVariable(reference, true));
        }
        return result;
    }
    async allSettled() {
        const attachments = [...( this.attachments.values())];
        await Promise.allSettled(( attachments.map((attachment) => {
            return attachment.allSettled;
        })));
    }
    onUpdate(callback) {
        this._register(this._onUpdate.event(callback));
        return this;
    }
    onAdd(callback) {
        this._register(this._onAdd.event(callback));
        return this;
    }
    constructor(initService, configService) {
        super();
        this.initService = initService;
        this.configService = configService;
        this.attachments = this._register(( new DisposableMap()));
        this._onUpdate = this._register(( new Emitter()));
        this._onAdd = this._register(( new Emitter()));
        this._onUpdate.fire = this._onUpdate.fire.bind(this._onUpdate);
    }
    add(uri) {
        if (( this.attachments.has(uri.path))) {
            return this;
        }
        const instruction = this.initService.createInstance(ChatPromptAttachmentModel, uri)
            .onUpdate(this._onUpdate.fire)
            .onDispose(() => {
            this.attachments.deleteAndLeak(uri.path);
            this._onUpdate.fire();
        });
        this.attachments.set(uri.path, instruction);
        instruction.resolve();
        this._onAdd.fire(instruction);
        this._onUpdate.fire();
        return this;
    }
    remove(uri) {
        if (!( this.attachments.has(uri.path))) {
            return this;
        }
        this.attachments.deleteAndDispose(uri.path);
        return this;
    }
    get featureEnabled() {
        return PromptsConfig.enabled(this.configService);
    }
};
ChatPromptAttachmentsCollection = ( __decorate([
    ( __param(0, IInstantiationService)),
    ( __param(1, IConfigurationService))
], ChatPromptAttachmentsCollection));

export { ChatPromptAttachmentsCollection, toChatVariable };
