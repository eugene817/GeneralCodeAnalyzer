
import { FileReference } from './tokens/fileReference.js';
import { Range } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/core/range';
import { BaseDecoder } from '../../../../../../base/common/codecs/baseDecoder.js';
import { Tab } from '../../../../../../editor/common/codecs/simpleCodec/tokens/tab.js';
import { Word } from '../../../../../../editor/common/codecs/simpleCodec/tokens/word.js';
import { Hash } from '../../../../../../editor/common/codecs/simpleCodec/tokens/hash.js';
import { Space } from '../../../../../../editor/common/codecs/simpleCodec/tokens/space.js';
import { Colon } from '../../../../../../editor/common/codecs/simpleCodec/tokens/colon.js';
import { NewLine } from '../../../../../../editor/common/codecs/linesCodec/tokens/newLine.js';
import { FormFeed } from '../../../../../../editor/common/codecs/simpleCodec/tokens/formFeed.js';
import { VerticalTab } from '../../../../../../editor/common/codecs/simpleCodec/tokens/verticalTab.js';
import { MarkdownLink } from '../../../../../../editor/common/codecs/markdownCodec/tokens/markdownLink.js';
import { CarriageReturn } from '../../../../../../editor/common/codecs/linesCodec/tokens/carriageReturn.js';
import { ParserBase } from '../../../../../../editor/common/codecs/simpleCodec/parserBase.js';
import { MarkdownDecoder } from '../../../../../../editor/common/codecs/markdownCodec/markdownDecoder.js';

class PartialPromptVariableName extends ParserBase {
    constructor(token) {
        super([token]);
    }
    accept(token) {
        if (token instanceof Word) {
            if (token.text === 'file') {
                this.currentTokens.push(token);
                return {
                    result: 'success',
                    nextParser: this,
                    wasTokenConsumed: true,
                };
            }
            return {
                result: 'failure',
                wasTokenConsumed: false,
            };
        }
        if (token instanceof Colon) {
            const lastToken = this.currentTokens[this.currentTokens.length - 1];
            if (lastToken instanceof Word) {
                this.currentTokens.push(token);
                return {
                    result: 'success',
                    nextParser: ( new PartialPromptFileReference(this.currentTokens)),
                    wasTokenConsumed: true,
                };
            }
        }
        return {
            result: 'failure',
            wasTokenConsumed: false,
        };
    }
}
const PROMPT_FILE_REFERENCE_STOP_CHARACTERS = ( [Space, Tab, CarriageReturn, NewLine, VerticalTab, FormFeed]
    .map((token) => { return token.symbol; }));
class PartialPromptFileReference extends ParserBase {
    constructor(tokens) {
        super([]);
        this.fileReferenceTokens = tokens;
    }
    get tokens() {
        return [...this.fileReferenceTokens, ...this.currentTokens];
    }
    asFileReference() {
        const path = ( this.currentTokens
            .map((token) => { return token.text; }))
            .join('');
        const firstToken = this.tokens[0];
        const range = ( new Range(
            firstToken.range.startLineNumber,
            firstToken.range.startColumn,
            firstToken.range.startLineNumber,
            firstToken.range.startColumn + FileReference.TOKEN_START.length + path.length
        ));
        return ( new FileReference(range, path));
    }
    accept(token) {
        if (PROMPT_FILE_REFERENCE_STOP_CHARACTERS.includes(token.text)) {
            return {
                result: 'success',
                wasTokenConsumed: false,
                nextParser: this.asFileReference(),
            };
        }
        this.currentTokens.push(token);
        return {
            result: 'success',
            wasTokenConsumed: true,
            nextParser: this,
        };
    }
}
class ChatPromptDecoder extends BaseDecoder {
    constructor(stream) {
        super(( new MarkdownDecoder(stream)));
    }
    onStreamData(token) {
        if (token instanceof Hash && !this.current) {
            this.current = ( new PartialPromptVariableName(token));
            return;
        }
        if (!this.current) {
            if (token instanceof MarkdownLink) {
                this._onData.fire(token);
            }
            return;
        }
        const parseResult = this.current.accept(token);
        switch (parseResult.result) {
            case 'success': {
                if (parseResult.nextParser instanceof FileReference) {
                    this._onData.fire(parseResult.nextParser);
                    delete this.current;
                }
                else {
                    this.current = parseResult.nextParser;
                }
                break;
            }
            case 'failure': {
                delete this.current;
                break;
            }
        }
        if (!parseResult.wasTokenConsumed) {
            this.onStreamData(token);
        }
    }
    onStreamEnd() {
        if (this.current && this.current instanceof PartialPromptFileReference) {
            this._onData.fire(this.current.asFileReference());
            delete this.current;
        }
        super.onStreamEnd();
    }
}

export { ChatPromptDecoder };
