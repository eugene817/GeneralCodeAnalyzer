
import { Codicon } from '@codingame/monaco-vscode-api/vscode/vs/base/common/codicons';
import { KeyMod, KeyCode } from '@codingame/monaco-vscode-api/vscode/vs/base/common/keyCodes';
import { localize2, localize } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import { AccessibilitySignal } from '@codingame/monaco-vscode-api/vscode/vs/platform/accessibilitySignal/browser/accessibilitySignalService';
import { IAccessibilitySignalService } from '@codingame/monaco-vscode-api/vscode/vs/platform/accessibilitySignal/browser/accessibilitySignalService.service';
import { registerAction2, Action2, MenuId } from '@codingame/monaco-vscode-api/vscode/vs/platform/actions/common/actions';
import { ContextKeyExpr } from '@codingame/monaco-vscode-api/vscode/vs/platform/contextkey/common/contextkey';
import { IDialogService } from '@codingame/monaco-vscode-api/vscode/vs/platform/dialogs/common/dialogs.service';
import { KeybindingWeight } from '@codingame/monaco-vscode-api/vscode/vs/platform/keybinding/common/keybindingsRegistry';
import { ActiveEditorContext } from '@codingame/monaco-vscode-api/vscode/vs/workbench/common/contextkeys';
import { IViewsService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/views/common/viewsService.service';
import { isChatViewTitleActionContext } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatActions';
import { ChatAgentLocation } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatAgents';
import { IChatAgentService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatAgents.service';
import { ChatContextKeys } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatContextKeys';
import { WorkingSetEntryState, hasUndecidedChatEditingResourceContextKey, hasAppliedChatEditsContextKey } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatEditingService';
import { ChatViewId, EditsViewId } from '../chat.js';
import { IChatWidgetService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/browser/chat.service';
import { EditingSessionAction } from '../chatEditing/chatEditingActions.js';
import { ctxIsGlobalEditingSession } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/browser/chatEditing/chatEditingEditorContextKeys';
import { ChatEditorInput } from '../chatEditorInput.js';
import { CHAT_CATEGORY } from './chatActions.js';
import { clearChatEditor } from './chatClear.js';

const ACTION_ID_NEW_CHAT = `workbench.action.chat.newChat`;
const ACTION_ID_NEW_EDIT_SESSION = `workbench.action.chat.newEditSession`;
const ChatDoneActionId = 'workbench.action.chat.done';
function registerNewChatActions() {
    registerAction2(class NewChatEditorAction extends Action2 {
        constructor() {
            super({
                id: 'workbench.action.chatEditor.newChat',
                title: ( localize2(4306, "New Chat")),
                icon: Codicon.plus,
                f1: false,
                precondition: ChatContextKeys.enabled,
                menu: [{
                        id: MenuId.EditorTitle,
                        group: 'navigation',
                        order: 0,
                        when: ( ActiveEditorContext.isEqualTo(ChatEditorInput.EditorID)),
                    }]
            });
        }
        async run(accessor, ...args) {
            announceChatCleared(accessor.get(IAccessibilitySignalService));
            await clearChatEditor(accessor);
        }
    });
    registerAction2(class GlobalClearChatAction extends Action2 {
        constructor() {
            super({
                id: ACTION_ID_NEW_CHAT,
                title: ( localize2(4306, "New Chat")),
                category: CHAT_CATEGORY,
                icon: Codicon.plus,
                precondition: ( ContextKeyExpr.and(ChatContextKeys.enabled, ( ChatContextKeys.location.notEqualsTo(ChatAgentLocation.EditingSession)))),
                f1: true,
                keybinding: {
                    weight: KeybindingWeight.WorkbenchContrib,
                    primary: KeyMod.CtrlCmd | KeyCode.KeyL,
                    mac: {
                        primary: KeyMod.WinCtrl | KeyCode.KeyL
                    },
                    when: ChatContextKeys.inChatSession
                },
                menu: [{
                        id: MenuId.ChatContext,
                        group: 'z_clear'
                    },
                    {
                        id: MenuId.ViewTitle,
                        when: ( ContextKeyExpr.equals('view', ChatViewId)),
                        group: 'navigation',
                        order: -1
                    }]
            });
        }
        async run(accessor, ...args) {
            const context = args[0];
            const accessibilitySignalService = accessor.get(IAccessibilitySignalService);
            const widgetService = accessor.get(IChatWidgetService);
            let widget = widgetService.lastFocusedWidget;
            if (isChatViewTitleActionContext(context)) {
                widget = widgetService.getWidgetBySessionId(context.sessionId);
            }
            if (widget) {
                announceChatCleared(accessibilitySignalService);
                widget.clear();
                widget.focusInput();
            }
        }
    });
    registerAction2(class NewEditSessionAction extends EditingSessionAction {
        constructor() {
            super({
                id: ACTION_ID_NEW_EDIT_SESSION,
                title: ( localize2(4307, "New Edit Session")),
                category: CHAT_CATEGORY,
                icon: Codicon.plus,
                precondition: ( ContextKeyExpr.and(ChatContextKeys.enabled, ChatContextKeys.editingParticipantRegistered)),
                f1: true,
                menu: [{
                        id: MenuId.ChatContext,
                        group: 'z_clear'
                    },
                    {
                        id: MenuId.ViewTitle,
                        when: ( ContextKeyExpr.equals('view', EditsViewId)),
                        group: 'navigation',
                        order: -1
                    }],
                keybinding: {
                    weight: KeybindingWeight.WorkbenchContrib,
                    primary: KeyMod.CtrlCmd | KeyCode.KeyL,
                    mac: {
                        primary: KeyMod.WinCtrl | KeyCode.KeyL
                    },
                    when: ( ContextKeyExpr.and(ChatContextKeys.inChatSession, ( ChatContextKeys.location.isEqualTo(ChatAgentLocation.EditingSession))))
                }
            });
        }
        async _handleCurrentEditingSession(currentEditingSession, dialogService) {
            const currentEdits = currentEditingSession?.entries.get();
            const currentEditCount = currentEdits?.length;
            if (currentEditingSession && currentEditCount) {
                const undecidedEdits = currentEdits.filter((edit) => edit.state.get() === WorkingSetEntryState.Modified);
                if (undecidedEdits.length) {
                    const { result } = await dialogService.prompt({
                        title: ( localize(4308, "Start new editing session?")),
                        message: ( localize(
                            4309,
                            "Starting a new editing session will end your current session. Do you want to accept pending edits to {0} files?",
                            undecidedEdits.length
                        )),
                        type: 'info',
                        cancelButton: true,
                        buttons: [
                            {
                                label: ( localize(4310, "Accept & Continue")),
                                run: async () => {
                                    await currentEditingSession.accept();
                                    return true;
                                }
                            },
                            {
                                label: ( localize(4311, "Discard & Continue")),
                                run: async () => {
                                    await currentEditingSession.reject();
                                    return true;
                                }
                            }
                        ],
                    });
                    return Boolean(result);
                }
            }
            return true;
        }
        async runEditingSessionAction(accessor, editingSession, chatWidget, ...args) {
            const context = args[0];
            const accessibilitySignalService = accessor.get(IAccessibilitySignalService);
            const widgetService = accessor.get(IChatWidgetService);
            const dialogService = accessor.get(IDialogService);
            const viewsService = accessor.get(IViewsService);
            const agentService = accessor.get(IChatAgentService);
            if (!(await this._handleCurrentEditingSession(editingSession, dialogService))) {
                return;
            }
            const isChatViewTitleAction = isChatViewTitleActionContext(context);
            let widget;
            if (isChatViewTitleAction) {
                widget = widgetService.getWidgetBySessionId(context.sessionId);
            }
            else {
                const chatView = await viewsService.openView(EditsViewId);
                widget = chatView.widget;
            }
            announceChatCleared(accessibilitySignalService);
            if (!widget) {
                return;
            }
            await editingSession.stop(true);
            widget.clear();
            widget.attachmentModel.clear();
            widget.focusInput();
            if (!context) {
                return;
            }
            if (!isChatViewTitleAction && typeof context.agentMode === 'boolean') {
                agentService.toggleToolsAgentMode(context.agentMode);
            }
            if (context.inputValue) {
                if (context.isPartialQuery) {
                    widget.setInput(context.inputValue);
                }
                else {
                    widget.acceptInput(context.inputValue);
                }
            }
        }
    });
    registerAction2(class GlobalEditsDoneAction extends Action2 {
        constructor() {
            super({
                id: ChatDoneActionId,
                title: ( localize2(4312, "Done")),
                category: CHAT_CATEGORY,
                precondition: ( ContextKeyExpr.and(ChatContextKeys.enabled, ChatContextKeys.editingParticipantRegistered)),
                f1: false,
                menu: [{
                        id: MenuId.ChatEditingWidgetToolbar,
                        when: ( ContextKeyExpr.and(( hasUndecidedChatEditingResourceContextKey.negate()), hasAppliedChatEditsContextKey, ChatContextKeys.editingParticipantRegistered, ( ChatContextKeys.location.isEqualTo(ChatAgentLocation.EditingSession)))),
                        group: 'navigation',
                        order: 0
                    }]
            });
        }
        async run(accessor, ...args) {
            const context = args[0];
            const accessibilitySignalService = accessor.get(IAccessibilitySignalService);
            const widgetService = accessor.get(IChatWidgetService);
            if (isChatViewTitleActionContext(context)) {
                announceChatCleared(accessibilitySignalService);
                const widget = widgetService.getWidgetBySessionId(context.sessionId);
                if (widget) {
                    widget.clear();
                    widget.attachmentModel.clear();
                    widget.focusInput();
                }
            }
            else {
                const viewsService = accessor.get(IViewsService);
                const chatView = await viewsService.openView(EditsViewId);
                const widget = chatView.widget;
                announceChatCleared(accessibilitySignalService);
                widget.clear();
                widget.attachmentModel.clear();
                widget.focusInput();
            }
        }
    });
    registerAction2(class UndoChatEditInteractionAction extends EditingSessionAction {
        constructor() {
            super({
                id: 'workbench.action.chat.undoEdit',
                title: ( localize2(4313, "Undo Last Edit")),
                category: CHAT_CATEGORY,
                icon: Codicon.discard,
                precondition: ( ContextKeyExpr.and(
                    ChatContextKeys.chatEditingCanUndo,
                    ChatContextKeys.enabled,
                    ChatContextKeys.editingParticipantRegistered
                )),
                f1: true,
                menu: [{
                        id: MenuId.ViewTitle,
                        when: ( ContextKeyExpr.equals('view', EditsViewId)),
                        group: 'navigation',
                        order: -3
                    }]
            });
        }
        async runEditingSessionAction(accessor, editingSession) {
            await editingSession.undoInteraction();
        }
    });
    registerAction2(class RedoChatEditInteractionAction extends EditingSessionAction {
        constructor() {
            super({
                id: 'workbench.action.chat.redoEdit',
                title: ( localize2(4314, "Redo Last Edit")),
                category: CHAT_CATEGORY,
                icon: Codicon.redo,
                precondition: ( ContextKeyExpr.and(
                    ChatContextKeys.chatEditingCanRedo,
                    ChatContextKeys.enabled,
                    ChatContextKeys.editingParticipantRegistered
                )),
                f1: true,
                menu: [{
                        id: MenuId.ViewTitle,
                        when: ( ContextKeyExpr.equals('view', EditsViewId)),
                        group: 'navigation',
                        order: -2
                    }]
            });
        }
        async runEditingSessionAction(accessor, editingSession) {
            await editingSession.redoInteraction();
        }
    });
    registerAction2(class GlobalOpenEditsAction extends Action2 {
        constructor() {
            super({
                id: 'workbench.action.chat.openEditSession',
                title: ( localize2(4315, "Open {0}", 'Copilot Edits')),
                category: CHAT_CATEGORY,
                icon: Codicon.goToEditingSession,
                f1: true,
                menu: [{
                        id: MenuId.ViewTitle,
                        when: ( ContextKeyExpr.and(( ContextKeyExpr.equals('view', ChatViewId)), ChatContextKeys.editingParticipantRegistered, ( ContextKeyExpr.equals(`view.${EditsViewId}.visible`, false)), ( ContextKeyExpr.or(( ContextKeyExpr.and(( ContextKeyExpr.equals(`workbench.panel.chat.defaultViewContainerLocation`, true)), ( ContextKeyExpr.equals(`workbench.panel.chatEditing.defaultViewContainerLocation`, false)))), ( ContextKeyExpr.and(( ContextKeyExpr.equals(`workbench.panel.chat.defaultViewContainerLocation`, false)), ( ContextKeyExpr.equals(`workbench.panel.chatEditing.defaultViewContainerLocation`, true)))))))),
                        group: 'navigation',
                        order: 1
                    }, {
                        id: MenuId.ChatTitleBarMenu,
                        group: 'a_open',
                        order: 2
                    }, {
                        id: MenuId.ChatEditingEditorContent,
                        when: ctxIsGlobalEditingSession,
                        group: 'navigate',
                        order: 4,
                    }],
                keybinding: {
                    weight: KeybindingWeight.WorkbenchContrib,
                    primary: KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KeyI,
                    linux: {
                        primary: KeyMod.CtrlCmd | KeyMod.Alt | KeyMod.Shift | KeyCode.KeyI
                    },
                    when: ( ContextKeyExpr.and(( ContextKeyExpr.notEquals('view', EditsViewId)), ChatContextKeys.editingParticipantRegistered))
                }
            });
        }
        async run(accessor, ...args) {
            const viewsService = accessor.get(IViewsService);
            const chatView = await viewsService.openView(EditsViewId);
            chatView.widget.focusInput();
        }
    });
}
function announceChatCleared(accessibilitySignalService) {
    accessibilitySignalService.playSignal(AccessibilitySignal.clear);
}

export { ACTION_ID_NEW_CHAT, ACTION_ID_NEW_EDIT_SESSION, ChatDoneActionId, registerNewChatActions };
