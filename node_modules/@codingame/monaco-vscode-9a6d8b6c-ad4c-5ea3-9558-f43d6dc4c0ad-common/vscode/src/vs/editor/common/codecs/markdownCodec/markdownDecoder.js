
import { MarkdownLink } from './tokens/markdownLink.js';
import { NewLine } from '../linesCodec/tokens/newLine.js';
import { assert } from '@codingame/monaco-vscode-api/vscode/vs/base/common/assert';
import { FormFeed } from '../simpleCodec/tokens/formFeed.js';
import { VerticalTab } from '../simpleCodec/tokens/verticalTab.js';
import { CarriageReturn } from '../linesCodec/tokens/carriageReturn.js';
import { BaseDecoder } from '../../../../base/common/codecs/baseDecoder.js';
import { RightBracket, LeftBracket } from '../simpleCodec/tokens/brackets.js';
import { SimpleDecoder } from '../simpleCodec/simpleDecoder.js';
import { ParserBase } from '../simpleCodec/parserBase.js';
import { LeftParenthesis, RightParenthesis } from '../simpleCodec/tokens/parentheses.js';

const MARKDOWN_LINK_STOP_CHARACTERS = ( [CarriageReturn, NewLine, VerticalTab, FormFeed]
    .map((token) => { return token.symbol; }));
class PartialMarkdownLinkCaption extends ParserBase {
    constructor(token) {
        super([token]);
    }
    accept(token) {
        if (MARKDOWN_LINK_STOP_CHARACTERS.includes(token.text)) {
            return {
                result: 'failure',
                wasTokenConsumed: false,
            };
        }
        if (token instanceof RightBracket) {
            return {
                result: 'success',
                nextParser: ( new MarkdownLinkCaption([...this.tokens, token])),
                wasTokenConsumed: true,
            };
        }
        this.currentTokens.push(token);
        return {
            result: 'success',
            nextParser: this,
            wasTokenConsumed: true,
        };
    }
}
class MarkdownLinkCaption extends ParserBase {
    accept(token) {
        if (token instanceof LeftParenthesis) {
            return {
                result: 'success',
                wasTokenConsumed: true,
                nextParser: ( new PartialMarkdownLink([...this.tokens], token)),
            };
        }
        return {
            result: 'failure',
            wasTokenConsumed: false,
        };
    }
}
class PartialMarkdownLink extends ParserBase {
    constructor(captionTokens, token) {
        super([token]);
        this.captionTokens = captionTokens;
        this.openParensCount = 1;
    }
    get tokens() {
        return [...this.captionTokens, ...this.currentTokens];
    }
    accept(token) {
        if (token instanceof LeftParenthesis) {
            this.openParensCount += 1;
        }
        if (token instanceof RightParenthesis) {
            this.openParensCount -= 1;
            assert(this.openParensCount >= 0, `Unexpected right parenthesis token encountered: '${token}'.`);
            if (this.openParensCount === 0) {
                const { startLineNumber, startColumn } = this.captionTokens[0].range;
                const caption = ( this.captionTokens
                    .map((token) => { return token.text; }))
                    .join('');
                this.currentTokens.push(token);
                const reference = ( this.currentTokens
                    .map((token) => { return token.text; })).join('');
                return {
                    result: 'success',
                    wasTokenConsumed: true,
                    nextParser: ( new MarkdownLink(startLineNumber, startColumn, caption, reference)),
                };
            }
        }
        if (MARKDOWN_LINK_STOP_CHARACTERS.includes(token.text)) {
            return {
                result: 'failure',
                wasTokenConsumed: false,
            };
        }
        this.currentTokens.push(token);
        return {
            result: 'success',
            nextParser: this,
            wasTokenConsumed: true,
        };
    }
}
class MarkdownDecoder extends BaseDecoder {
    constructor(stream) {
        super(( new SimpleDecoder(stream)));
    }
    onStreamData(token) {
        if (token instanceof LeftBracket && !this.current) {
            this.current = ( new PartialMarkdownLinkCaption(token));
            return;
        }
        if (!this.current) {
            this._onData.fire(token);
            return;
        }
        const parseResult = this.current.accept(token);
        if (parseResult.result === 'success') {
            if (parseResult.nextParser instanceof MarkdownLink) {
                this._onData.fire(parseResult.nextParser);
                delete this.current;
            }
            else {
                this.current = parseResult.nextParser;
            }
        }
        else {
            for (const token of this.current.tokens) {
                this._onData.fire(token);
                delete this.current;
            }
        }
        if (!parseResult.wasTokenConsumed) {
            this.onStreamData(token);
        }
    }
    onStreamEnd() {
        if (this.current) {
            const { tokens } = this.current;
            delete this.current;
            for (const token of [...tokens]) {
                this._onData.fire(token);
            }
        }
        super.onStreamEnd();
    }
}

export { MarkdownDecoder };
