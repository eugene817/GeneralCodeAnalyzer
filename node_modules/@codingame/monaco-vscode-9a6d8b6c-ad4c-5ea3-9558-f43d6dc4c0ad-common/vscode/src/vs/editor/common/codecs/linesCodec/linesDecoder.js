
import { Line } from './tokens/line.js';
import { Range } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/core/range';
import { NewLine } from './tokens/newLine.js';
import { assert } from '@codingame/monaco-vscode-api/vscode/vs/base/common/assert';
import { CarriageReturn } from './tokens/carriageReturn.js';
import { VSBuffer } from '@codingame/monaco-vscode-api/vscode/vs/base/common/buffer';
import { assertDefined } from '@codingame/monaco-vscode-api/vscode/vs/base/common/types';
import { BaseDecoder } from '../../../../base/common/codecs/baseDecoder.js';

class LinesDecoder extends BaseDecoder {
    constructor() {
        super(...arguments);
        this.buffer = VSBuffer.alloc(0);
    }
    onStreamData(chunk) {
        this.buffer = VSBuffer.concat([this.buffer, chunk]);
        this.processData(false);
    }
    processData(streamEnded) {
        while (this.buffer.byteLength > 0) {
            const lineNumber = this.lastEmittedLine
                ? this.lastEmittedLine.range.startLineNumber + 1
                : 1;
            const endOfLineTokens = this.findEndOfLineTokens(lineNumber);
            const firstToken = endOfLineTokens[0];
            if (!firstToken) {
                if (streamEnded) {
                    this.emitLine(lineNumber, this.buffer.slice(0));
                }
                break;
            }
            this.emitLine(lineNumber, this.buffer.slice(0, firstToken.range.startColumn - 1));
            assertDefined(this.lastEmittedLine, 'No last emitted line found.');
            let startColumn = this.lastEmittedLine.range.endColumn;
            for (const token of endOfLineTokens) {
                const endColumn = startColumn + token.byte.byteLength;
                this._onData.fire(token.withRange({ startColumn, endColumn }));
                this.buffer = this.buffer.slice(token.byte.byteLength);
                startColumn = endColumn;
            }
        }
        if (streamEnded) {
            assert(this.buffer.byteLength === 0, 'Expected the input data buffer to be empty when the stream ends.');
        }
    }
    findEndOfLineTokens(lineNumber) {
        const result = [];
        const carriageReturnIndex = this.buffer.indexOf(CarriageReturn.byte);
        const newLineIndex = this.buffer.indexOf(NewLine.byte);
        if (carriageReturnIndex >= 0 && (carriageReturnIndex < newLineIndex || newLineIndex === -1)) {
            result.push(( new CarriageReturn(( new Range(
                lineNumber,
                (carriageReturnIndex + 1),
                lineNumber,
                (carriageReturnIndex + 1) + CarriageReturn.byte.byteLength
            )))));
            if (newLineIndex === carriageReturnIndex + 1) {
                result.push(( new NewLine(( new Range(
                    lineNumber,
                    (newLineIndex + 1),
                    lineNumber,
                    (newLineIndex + 1) + NewLine.byte.byteLength
                )))));
            }
            if (this.buffer.byteLength > carriageReturnIndex + 1) {
                return result;
            }
            return [];
        }
        if (newLineIndex >= 0) {
            result.push(( new NewLine(( new Range(
                lineNumber,
                (newLineIndex + 1),
                lineNumber,
                (newLineIndex + 1) + NewLine.byte.byteLength
            )))));
        }
        return result;
    }
    emitLine(lineNumber,
    lineBytes) {
        const line = ( new Line(lineNumber, ( lineBytes.toString())));
        this._onData.fire(line);
        this.lastEmittedLine = line;
        this.buffer = this.buffer.slice(lineBytes.byteLength);
    }
    onStreamEnd() {
        if (this.buffer.byteLength > 0) {
            this.processData(true);
        }
        super.onStreamEnd();
    }
}

export { LinesDecoder };
