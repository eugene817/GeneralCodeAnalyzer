
import { __decorate, __param } from '@codingame/monaco-vscode-api/external/tslib/tslib.es6';
import { localize } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import { toErrorMessage } from '@codingame/monaco-vscode-api/vscode/vs/base/common/errorMessage';
import { isEqual, basename } from '@codingame/monaco-vscode-api/vscode/vs/base/common/resources';
import { Action } from '@codingame/monaco-vscode-api/vscode/vs/base/common/actions';
import { URI } from '@codingame/monaco-vscode-api/vscode/vs/base/common/uri';
import { FileOperationResult } from '@codingame/monaco-vscode-api/vscode/vs/platform/files/common/files';
import { ITextFileService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/textfile/common/textfiles.service';
import { IInstantiationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/instantiation/common/instantiation';
import { Disposable, dispose } from '@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle';
import { ITextModelService } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/services/resolverService.service';
import { ResourceMap } from '@codingame/monaco-vscode-api/vscode/vs/base/common/map';
import { DiffEditorInput } from '@codingame/monaco-vscode-fdf643f9-94dd-5510-b97a-408abf26ad92-common/vscode/vs/workbench/common/editor/diffEditorInput';
import { RawContextKey } from '@codingame/monaco-vscode-api/vscode/vs/platform/contextkey/common/contextkey';
import { IContextKeyService } from '@codingame/monaco-vscode-api/vscode/vs/platform/contextkey/common/contextkey.service';
import { TextFileContentProvider } from '@codingame/monaco-vscode-a4c2011e-8775-52bd-abf0-4a3c07a9696b-common/vscode/vs/workbench/contrib/files/common/files';
import { FileEditorInput } from '@codingame/monaco-vscode-c4e2825a-b5b1-5f0e-b547-068c32e06d50-common/vscode/vs/workbench/contrib/files/browser/editors/fileEditorInput';
import { SAVE_FILE_AS_LABEL } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/files/browser/fileConstants';
import '@codingame/monaco-vscode-api/vscode/vs/platform/notification/common/notification';
import { INotificationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/notification/common/notification.service';
import { IOpenerService } from '@codingame/monaco-vscode-api/vscode/vs/platform/opener/common/opener.service';
import { StorageScope, StorageTarget } from '@codingame/monaco-vscode-api/vscode/vs/platform/storage/common/storage';
import { IStorageService } from '@codingame/monaco-vscode-api/vscode/vs/platform/storage/common/storage.service';
import { IProductService } from '@codingame/monaco-vscode-api/vscode/vs/platform/product/common/productService.service';
import { Event } from '@codingame/monaco-vscode-api/vscode/vs/base/common/event';
import { IEditorService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/editor/common/editorService.service';
import { isWindows } from '@codingame/monaco-vscode-api/vscode/vs/base/common/platform';
import { Schemas } from '@codingame/monaco-vscode-api/vscode/vs/base/common/network';
import { IPreferencesService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/preferences/common/preferences.service';
import { SaveReason, SideBySideEditor } from '@codingame/monaco-vscode-api/vscode/vs/workbench/common/editor';
import { hash } from '@codingame/monaco-vscode-api/vscode/vs/base/common/hash';
import Severity from '@codingame/monaco-vscode-api/vscode/vs/base/common/severity';

const CONFLICT_RESOLUTION_CONTEXT = 'saveConflictResolutionContext';
const CONFLICT_RESOLUTION_SCHEME = 'conflictResolution';
const LEARN_MORE_DIRTY_WRITE_IGNORE_KEY = 'learnMoreDirtyWriteError';
const conflictEditorHelp = ( localize(
    6603,
    "Use the actions in the editor tool bar to either undo your changes or overwrite the content of the file with your changes."
));
let TextFileSaveErrorHandler = class TextFileSaveErrorHandler extends Disposable {
    static { this.ID = 'workbench.contrib.textFileSaveErrorHandler'; }
    constructor(notificationService, textFileService, contextKeyService, editorService, textModelService, instantiationService, storageService) {
        super();
        this.notificationService = notificationService;
        this.textFileService = textFileService;
        this.contextKeyService = contextKeyService;
        this.editorService = editorService;
        this.instantiationService = instantiationService;
        this.storageService = storageService;
        this.messages = ( new ResourceMap());
        this.conflictResolutionContext = ( new RawContextKey(CONFLICT_RESOLUTION_CONTEXT, false, true)).bindTo(this.contextKeyService);
        this.activeConflictResolutionResource = undefined;
        const provider = this._register(instantiationService.createInstance(TextFileContentProvider));
        this._register(textModelService.registerTextModelContentProvider(CONFLICT_RESOLUTION_SCHEME, provider));
        this.textFileService.files.saveErrorHandler = this;
        this.registerListeners();
    }
    registerListeners() {
        this._register(this.textFileService.files.onDidSave(e => this.onFileSavedOrReverted(e.model.resource)));
        this._register(this.textFileService.files.onDidRevert(model => this.onFileSavedOrReverted(model.resource)));
        this._register(this.editorService.onDidActiveEditorChange(() => this.onActiveEditorChanged()));
    }
    onActiveEditorChanged() {
        let isActiveEditorSaveConflictResolution = false;
        let activeConflictResolutionResource;
        const activeInput = this.editorService.activeEditor;
        if (activeInput instanceof DiffEditorInput) {
            const resource = activeInput.original.resource;
            if (resource?.scheme === CONFLICT_RESOLUTION_SCHEME) {
                isActiveEditorSaveConflictResolution = true;
                activeConflictResolutionResource = activeInput.modified.resource;
            }
        }
        this.conflictResolutionContext.set(isActiveEditorSaveConflictResolution);
        this.activeConflictResolutionResource = activeConflictResolutionResource;
    }
    onFileSavedOrReverted(resource) {
        const messageHandle = this.messages.get(resource);
        if (messageHandle) {
            messageHandle.close();
            this.messages.delete(resource);
        }
    }
    onSaveError(error, model, options) {
        const fileOperationError = error;
        const resource = model.resource;
        let message;
        const primaryActions = [];
        const secondaryActions = [];
        if (fileOperationError.fileOperationResult === FileOperationResult.FILE_MODIFIED_SINCE) {
            if (this.activeConflictResolutionResource && isEqual(this.activeConflictResolutionResource, model.resource)) {
                if (this.storageService.getBoolean(LEARN_MORE_DIRTY_WRITE_IGNORE_KEY, StorageScope.APPLICATION)) {
                    return;
                }
                message = conflictEditorHelp;
                primaryActions.push(this.instantiationService.createInstance(ResolveConflictLearnMoreAction));
                secondaryActions.push(this.instantiationService.createInstance(DoNotShowResolveConflictLearnMoreAction));
            }
            else {
                message = ( localize(
                    6604,
                    "Failed to save '{0}': The content of the file is newer. Please compare your version with the file contents or overwrite the content of the file with your changes.",
                    basename(resource)
                ));
                primaryActions.push(this.instantiationService.createInstance(ResolveSaveConflictAction, model));
                primaryActions.push(this.instantiationService.createInstance(SaveModelIgnoreModifiedSinceAction, model, options));
                secondaryActions.push(this.instantiationService.createInstance(ConfigureSaveConflictAction));
            }
        }
        else {
            const isWriteLocked = fileOperationError.fileOperationResult === FileOperationResult.FILE_WRITE_LOCKED;
            const triedToUnlock = isWriteLocked && fileOperationError.options?.unlock;
            const isPermissionDenied = fileOperationError.fileOperationResult === FileOperationResult.FILE_PERMISSION_DENIED;
            const canSaveElevated = resource.scheme === Schemas.file;
            if (canSaveElevated && (isPermissionDenied || triedToUnlock)) {
                primaryActions.push(this.instantiationService.createInstance(SaveModelElevatedAction, model, options, !!triedToUnlock));
            }
            else if (isWriteLocked) {
                primaryActions.push(this.instantiationService.createInstance(UnlockModelAction, model, options));
            }
            else {
                primaryActions.push(this.instantiationService.createInstance(RetrySaveModelAction, model, options));
            }
            primaryActions.push(this.instantiationService.createInstance(SaveModelAsAction, model));
            primaryActions.push(this.instantiationService.createInstance(RevertModelAction, model));
            if (isWriteLocked) {
                if (triedToUnlock && canSaveElevated) {
                    message = isWindows ? ( localize(
                        6605,
                        "Failed to save '{0}': File is read-only. Select 'Overwrite as Admin' to retry as administrator.",
                        basename(resource)
                    )) : ( localize(
                        6606,
                        "Failed to save '{0}': File is read-only. Select 'Overwrite as Sudo' to retry as superuser.",
                        basename(resource)
                    ));
                }
                else {
                    message = ( localize(
                        6607,
                        "Failed to save '{0}': File is read-only. Select 'Overwrite' to attempt to make it writeable.",
                        basename(resource)
                    ));
                }
            }
            else if (canSaveElevated && isPermissionDenied) {
                message = isWindows ? ( localize(
                    6608,
                    "Failed to save '{0}': Insufficient permissions. Select 'Retry as Admin' to retry as administrator.",
                    basename(resource)
                )) : ( localize(
                    6609,
                    "Failed to save '{0}': Insufficient permissions. Select 'Retry as Sudo' to retry as superuser.",
                    basename(resource)
                ));
            }
            else {
                message = ( localize(
                    6610,
                    "Failed to save '{0}': {1}",
                    basename(resource),
                    toErrorMessage(error, false)
                ));
            }
        }
        const actions = { primary: primaryActions, secondary: secondaryActions };
        const handle = this.notificationService.notify({
            id: `${hash(( model.resource.toString()))}`,
            severity: Severity.Error,
            message,
            actions
        });
        Event.once(handle.onDidClose)(() => { dispose(primaryActions); dispose(secondaryActions); });
        this.messages.set(model.resource, handle);
    }
    dispose() {
        super.dispose();
        this.messages.clear();
    }
};
TextFileSaveErrorHandler = ( __decorate([
    ( __param(0, INotificationService)),
    ( __param(1, ITextFileService)),
    ( __param(2, IContextKeyService)),
    ( __param(3, IEditorService)),
    ( __param(4, ITextModelService)),
    ( __param(5, IInstantiationService)),
    ( __param(6, IStorageService))
], TextFileSaveErrorHandler));
const pendingResolveSaveConflictMessages = [];
function clearPendingResolveSaveConflictMessages() {
    while (pendingResolveSaveConflictMessages.length > 0) {
        const item = pendingResolveSaveConflictMessages.pop();
        item?.close();
    }
}
let ResolveConflictLearnMoreAction = class ResolveConflictLearnMoreAction extends Action {
    constructor(openerService) {
        super('workbench.files.action.resolveConflictLearnMore', ( localize(6611, "Learn More")));
        this.openerService = openerService;
    }
    async run() {
        await this.openerService.open(( URI.parse('https://go.microsoft.com/fwlink/?linkid=868264')));
    }
};
ResolveConflictLearnMoreAction = ( __decorate([
    ( __param(0, IOpenerService))
], ResolveConflictLearnMoreAction));
let DoNotShowResolveConflictLearnMoreAction = class DoNotShowResolveConflictLearnMoreAction extends Action {
    constructor(storageService) {
        super('workbench.files.action.resolveConflictLearnMoreDoNotShowAgain', ( localize(6612, "Don't Show Again")));
        this.storageService = storageService;
    }
    async run(notification) {
        this.storageService.store(LEARN_MORE_DIRTY_WRITE_IGNORE_KEY, true, StorageScope.APPLICATION, StorageTarget.USER);
        notification.dispose();
    }
};
DoNotShowResolveConflictLearnMoreAction = ( __decorate([
    ( __param(0, IStorageService))
], DoNotShowResolveConflictLearnMoreAction));
let ResolveSaveConflictAction = class ResolveSaveConflictAction extends Action {
    constructor(model, editorService, notificationService, instantiationService, productService) {
        super('workbench.files.action.resolveConflict', ( localize(6613, "Compare")));
        this.model = model;
        this.editorService = editorService;
        this.notificationService = notificationService;
        this.instantiationService = instantiationService;
        this.productService = productService;
    }
    async run() {
        if (!this.model.isDisposed()) {
            const resource = this.model.resource;
            const name = basename(resource);
            const editorLabel = ( localize(
                6614,
                "{0} (in file) ↔ {1} (in {2}) - Resolve save conflict",
                name,
                name,
                this.productService.nameLong
            ));
            await TextFileContentProvider.open(resource, CONFLICT_RESOLUTION_SCHEME, editorLabel, this.editorService, { pinned: true });
            const actions = { primary: [this.instantiationService.createInstance(ResolveConflictLearnMoreAction)] };
            const handle = this.notificationService.notify({
                id: `${hash(( resource.toString()))}`,
                severity: Severity.Info,
                message: conflictEditorHelp,
                actions,
                neverShowAgain: { id: LEARN_MORE_DIRTY_WRITE_IGNORE_KEY, isSecondary: true }
            });
            Event.once(handle.onDidClose)(() => dispose(actions.primary));
            pendingResolveSaveConflictMessages.push(handle);
        }
    }
};
ResolveSaveConflictAction = ( __decorate([
    ( __param(1, IEditorService)),
    ( __param(2, INotificationService)),
    ( __param(3, IInstantiationService)),
    ( __param(4, IProductService))
], ResolveSaveConflictAction));
class SaveModelElevatedAction extends Action {
    constructor(model, options, triedToUnlock) {
        super('workbench.files.action.saveModelElevated', triedToUnlock ? isWindows ? ( localize(6615, "Overwrite as Admin...")) : ( localize(6616, "Overwrite as Sudo...")) : isWindows ? ( localize(6617, "Retry as Admin...")) : ( localize(6618, "Retry as Sudo...")));
        this.model = model;
        this.options = options;
        this.triedToUnlock = triedToUnlock;
    }
    async run() {
        if (!this.model.isDisposed()) {
            await this.model.save({
                ...this.options,
                writeElevated: true,
                writeUnlock: this.triedToUnlock,
                reason: SaveReason.EXPLICIT
            });
        }
    }
}
class RetrySaveModelAction extends Action {
    constructor(model, options) {
        super('workbench.files.action.saveModel', ( localize(6619, "Retry")));
        this.model = model;
        this.options = options;
    }
    async run() {
        if (!this.model.isDisposed()) {
            await this.model.save({ ...this.options, reason: SaveReason.EXPLICIT });
        }
    }
}
class RevertModelAction extends Action {
    constructor(model) {
        super('workbench.files.action.revertModel', ( localize(6620, "Revert")));
        this.model = model;
    }
    async run() {
        if (!this.model.isDisposed()) {
            await this.model.revert();
        }
    }
}
let SaveModelAsAction = class SaveModelAsAction extends Action {
    constructor(model, editorService) {
        super('workbench.files.action.saveModelAs', SAVE_FILE_AS_LABEL.value);
        this.model = model;
        this.editorService = editorService;
    }
    async run() {
        if (!this.model.isDisposed()) {
            const editor = this.findEditor();
            if (editor) {
                await this.editorService.save(editor, { saveAs: true, reason: SaveReason.EXPLICIT });
            }
        }
    }
    findEditor() {
        let preferredMatchingEditor;
        const editors = this.editorService.findEditors(this.model.resource, { supportSideBySide: SideBySideEditor.PRIMARY });
        for (const identifier of editors) {
            if (identifier.editor instanceof FileEditorInput) {
                preferredMatchingEditor = identifier;
                break;
            }
            else if (!preferredMatchingEditor) {
                preferredMatchingEditor = identifier;
            }
        }
        return preferredMatchingEditor;
    }
};
SaveModelAsAction = ( __decorate([
    ( __param(1, IEditorService))
], SaveModelAsAction));
class UnlockModelAction extends Action {
    constructor(model, options) {
        super('workbench.files.action.unlock', ( localize(6621, "Overwrite")));
        this.model = model;
        this.options = options;
    }
    async run() {
        if (!this.model.isDisposed()) {
            await this.model.save({ ...this.options, writeUnlock: true, reason: SaveReason.EXPLICIT });
        }
    }
}
class SaveModelIgnoreModifiedSinceAction extends Action {
    constructor(model, options) {
        super('workbench.files.action.saveIgnoreModifiedSince', ( localize(6621, "Overwrite")));
        this.model = model;
        this.options = options;
    }
    async run() {
        if (!this.model.isDisposed()) {
            await this.model.save({ ...this.options, ignoreModifiedSince: true, reason: SaveReason.EXPLICIT });
        }
    }
}
let ConfigureSaveConflictAction = class ConfigureSaveConflictAction extends Action {
    constructor(preferencesService) {
        super('workbench.files.action.configureSaveConflict', ( localize(6622, "Configure")));
        this.preferencesService = preferencesService;
    }
    async run() {
        this.preferencesService.openSettings({ query: 'files.saveConflictResolution' });
    }
};
ConfigureSaveConflictAction = ( __decorate([
    ( __param(0, IPreferencesService))
], ConfigureSaveConflictAction));
const acceptLocalChangesCommand = (accessor, resource) => {
    return acceptOrRevertLocalChangesCommand(accessor, resource, true);
};
const revertLocalChangesCommand = (accessor, resource) => {
    return acceptOrRevertLocalChangesCommand(accessor, resource, false);
};
async function acceptOrRevertLocalChangesCommand(accessor, resource, accept) {
    const editorService = accessor.get(IEditorService);
    const editorPane = editorService.activeEditorPane;
    if (!editorPane) {
        return;
    }
    const editor = editorPane.input;
    const group = editorPane.group;
    clearPendingResolveSaveConflictMessages();
    if (accept) {
        const options = { ignoreModifiedSince: true, reason: SaveReason.EXPLICIT };
        await editorService.save({ editor, groupId: group.id }, options);
    }
    else {
        await editorService.revert({ editor, groupId: group.id });
    }
    await editorService.openEditor({ resource }, group);
    return group.closeEditor(editor);
}

export { CONFLICT_RESOLUTION_CONTEXT, CONFLICT_RESOLUTION_SCHEME, TextFileSaveErrorHandler, acceptLocalChangesCommand, revertLocalChangesCommand };
