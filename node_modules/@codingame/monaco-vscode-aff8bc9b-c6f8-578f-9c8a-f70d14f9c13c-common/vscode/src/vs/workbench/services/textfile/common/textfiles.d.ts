import { URI } from "@codingame/monaco-vscode-api/vscode/vs/base/common/uri";
import { Event } from "@codingame/monaco-vscode-api/vscode/vs/base/common/event";
import { IDisposable } from "@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle";
import { ISaveOptions, IRevertOptions, SaveReason } from "@codingame/monaco-vscode-api/vscode/vs/workbench/common/editor";
import { IBaseFileStatWithMetadata, IFileStatWithMetadata, IWriteFileOptions, FileOperationError, IReadFileStreamOptions, IFileReadLimits } from "@codingame/monaco-vscode-api/vscode/vs/platform/files/common/files";
import { ITextEditorModel } from "@codingame/monaco-vscode-model-service-override/vscode/vs/editor/common/services/resolverService";
import { ITextBufferFactory, ITextModel, ITextSnapshot } from "@codingame/monaco-vscode-api/vscode/vs/editor/common/model";
import { VSBuffer, VSBufferReadable } from "@codingame/monaco-vscode-api/vscode/vs/base/common/buffer";
import { IWorkingCopy, IWorkingCopySaveEvent } from "@codingame/monaco-vscode-86d65fc6-30f9-5dca-9501-e249de688591-common/vscode/vs/workbench/services/workingCopy/common/workingCopy";
import { CancellationToken } from "@codingame/monaco-vscode-api/vscode/vs/base/common/cancellation";
import { IProgress, IProgressStep } from "@codingame/monaco-vscode-api/vscode/vs/platform/progress/common/progress";
export interface IReadTextFileEncodingOptions {
    readonly encoding?: string;
    readonly autoGuessEncoding?: boolean;
    readonly candidateGuessEncodings?: string[];
    readonly acceptTextOnly?: boolean;
}
export interface IReadTextFileOptions extends IReadTextFileEncodingOptions, IReadFileStreamOptions {
}
export interface IWriteTextFileOptions extends IWriteFileOptions {
    readonly encoding?: string;
    readonly writeElevated?: boolean;
}
export declare enum TextFileOperationResult {
    FILE_IS_BINARY = 0
}
export declare class TextFileOperationError extends FileOperationError {
    textFileOperationResult: TextFileOperationResult;
    static isTextFileOperationError(obj: unknown): obj is TextFileOperationError;
    readonly options?: IReadTextFileOptions & IWriteTextFileOptions;
    constructor(message: string, textFileOperationResult: TextFileOperationResult, options?: IReadTextFileOptions & IWriteTextFileOptions);
}
export interface IResourceEncodings {
    getPreferredReadEncoding(resource: URI): Promise<IResourceEncoding>;
    getPreferredWriteEncoding(resource: URI, preferredEncoding?: string): Promise<IResourceEncoding>;
}
export interface IResourceEncoding {
    readonly encoding: string;
    readonly hasBOM: boolean;
}
export interface ISaveErrorHandler {
    onSaveError(error: Error, model: ITextFileEditorModel, options: ITextFileSaveAsOptions): void;
}
export declare enum TextFileEditorModelState {
    SAVED = 0,
    DIRTY = 1,
    PENDING_SAVE = 2,
    CONFLICT = 3,
    ORPHAN = 4,
    ERROR = 5
}
export declare enum TextFileResolveReason {
    EDITOR = 1,
    REFERENCE = 2,
    OTHER = 3
}
interface IBaseTextFileContent extends IBaseFileStatWithMetadata {
    readonly encoding: string;
}
export interface ITextFileContent extends IBaseTextFileContent {
    readonly value: string;
}
export interface ITextFileStreamContent extends IBaseTextFileContent {
    readonly value: ITextBufferFactory;
}
export interface ITextFileEditorModelResolveOrCreateOptions extends ITextFileResolveOptions {
    readonly languageId?: string;
    readonly encoding?: string;
    readonly reload?: {
        readonly async: boolean;
    };
}
export interface ITextFileSaveEvent extends ITextFileEditorModelSaveEvent {
    readonly model: ITextFileEditorModel;
}
export interface ITextFileResolveEvent {
    readonly model: ITextFileEditorModel;
    readonly reason: TextFileResolveReason;
}
export interface ITextFileSaveParticipantContext {
    readonly reason: SaveReason;
    readonly savedFrom?: URI;
}
export interface ITextFileSaveParticipant {
    readonly ordinal?: number;
    participate(model: ITextFileEditorModel, context: ITextFileSaveParticipantContext, progress: IProgress<IProgressStep>, token: CancellationToken): Promise<void>;
}
export interface ITextFileEditorModelManager {
    readonly onDidCreate: Event<ITextFileEditorModel>;
    readonly onDidResolve: Event<ITextFileResolveEvent>;
    readonly onDidChangeDirty: Event<ITextFileEditorModel>;
    readonly onDidChangeReadonly: Event<ITextFileEditorModel>;
    readonly onDidRemove: Event<URI>;
    readonly onDidChangeOrphaned: Event<ITextFileEditorModel>;
    readonly onDidChangeEncoding: Event<ITextFileEditorModel>;
    readonly onDidSaveError: Event<ITextFileEditorModel>;
    readonly onDidSave: Event<ITextFileSaveEvent>;
    readonly onDidRevert: Event<ITextFileEditorModel>;
    readonly models: ITextFileEditorModel[];
    saveErrorHandler: ISaveErrorHandler;
    get(resource: URI): ITextFileEditorModel | undefined;
    resolve(resource: URI, options?: ITextFileEditorModelResolveOrCreateOptions): Promise<ITextFileEditorModel>;
    addSaveParticipant(participant: ITextFileSaveParticipant): IDisposable;
    runSaveParticipants(model: ITextFileEditorModel, context: ITextFileSaveParticipantContext, progress: IProgress<IProgressStep>, token: CancellationToken): Promise<void>;
    canDispose(model: ITextFileEditorModel): true | Promise<true>;
}
export interface ITextFileSaveOptions extends ISaveOptions {
    readonly writeUnlock?: boolean;
    readonly writeElevated?: boolean;
    readonly ignoreModifiedSince?: boolean;
    readonly ignoreErrorHandler?: boolean;
}
export interface ITextFileSaveAsOptions extends ITextFileSaveOptions {
    readonly from?: URI;
    readonly suggestedTarget?: URI;
}
export interface ITextFileResolveOptions {
    readonly contents?: ITextBufferFactory;
    readonly forceReadFromFile?: boolean;
    readonly allowBinary?: boolean;
    readonly reason?: TextFileResolveReason;
    readonly limits?: IFileReadLimits;
}
export declare enum EncodingMode {
    Encode = 0,
    Decode = 1
}
export interface IEncodingSupport {
    getEncoding(): string | undefined;
    setEncoding(encoding: string, mode: EncodingMode): Promise<void>;
}
export interface ILanguageSupport {
    setLanguageId(languageId: string, source?: string): void;
}
export interface ITextFileEditorModelSaveEvent extends IWorkingCopySaveEvent {
    readonly stat: IFileStatWithMetadata;
}
export interface ITextFileEditorModel extends ITextEditorModel, IEncodingSupport, ILanguageSupport, IWorkingCopy {
    readonly onDidSave: Event<ITextFileEditorModelSaveEvent>;
    readonly onDidSaveError: Event<void>;
    readonly onDidChangeOrphaned: Event<void>;
    readonly onDidChangeReadonly: Event<void>;
    readonly onDidChangeEncoding: Event<void>;
    hasState(state: TextFileEditorModelState): boolean;
    joinState(state: TextFileEditorModelState.PENDING_SAVE): Promise<void>;
    updatePreferredEncoding(encoding: string | undefined): void;
    save(options?: ITextFileSaveAsOptions): Promise<boolean>;
    revert(options?: IRevertOptions): Promise<void>;
    resolve(options?: ITextFileResolveOptions): Promise<void>;
    isDirty(): this is IResolvedTextFileEditorModel;
    getLanguageId(): string | undefined;
    isResolved(): this is IResolvedTextFileEditorModel;
}
export declare function isTextFileEditorModel(model: ITextEditorModel): model is ITextFileEditorModel;
export interface IResolvedTextFileEditorModel extends ITextFileEditorModel {
    readonly textEditorModel: ITextModel;
    createSnapshot(): ITextSnapshot;
}
export declare function snapshotToString(snapshot: ITextSnapshot): string;
export declare function stringToSnapshot(value: string): ITextSnapshot;
export declare function toBufferOrReadable(value: string): VSBuffer;
export declare function toBufferOrReadable(value: ITextSnapshot): VSBufferReadable;
export declare function toBufferOrReadable(value: string | ITextSnapshot): VSBuffer | VSBufferReadable;
export declare function toBufferOrReadable(value: string | ITextSnapshot | undefined): VSBuffer | VSBufferReadable | undefined;
export {};
