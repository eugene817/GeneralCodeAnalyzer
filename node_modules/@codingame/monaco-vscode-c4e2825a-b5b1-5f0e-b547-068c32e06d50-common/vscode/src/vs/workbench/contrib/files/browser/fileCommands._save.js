
import { localize } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import { toAction } from '@codingame/monaco-vscode-api/vscode/vs/base/common/actions';
import { isCancellationError } from '@codingame/monaco-vscode-api/vscode/vs/base/common/errors';
import { hash } from '@codingame/monaco-vscode-api/vscode/vs/base/common/hash';
import { KeyMod, KeyCode, KeyChord } from '@codingame/monaco-vscode-api/vscode/vs/base/common/keyCodes';
import { ICodeEditorService } from '@codingame/monaco-vscode-api/vscode/vs/editor/browser/services/codeEditorService.service';
import { EmbeddedCodeEditorWidget } from '@codingame/monaco-vscode-api/vscode/vs/editor/browser/widget/codeEditor/embeddedCodeEditorWidget';
import { CommandsRegistry } from '@codingame/monaco-vscode-api/vscode/vs/platform/commands/common/commands';
import { IInstantiationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/instantiation/common/instantiation';
import { KeybindingsRegistry, KeybindingWeight } from '@codingame/monaco-vscode-api/vscode/vs/platform/keybinding/common/keybindingsRegistry';
import { IListService } from '@codingame/monaco-vscode-api/vscode/vs/platform/list/browser/listService.service';
import '@codingame/monaco-vscode-api/vscode/vs/platform/notification/common/notification';
import { INotificationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/notification/common/notification.service';
import { resolveCommandsContext } from '@codingame/monaco-vscode-fdf643f9-94dd-5510-b97a-408abf26ad92-common/vscode/vs/workbench/browser/parts/editor/editorCommandsContext';
import { EditorInputCapabilities, EditorResourceAccessor, SideBySideEditor, EditorsOrder, SaveReason } from '@codingame/monaco-vscode-api/vscode/vs/workbench/common/editor';
import { SideBySideEditorInput } from '@codingame/monaco-vscode-fdf643f9-94dd-5510-b97a-408abf26ad92-common/vscode/vs/workbench/common/editor/sideBySideEditorInput';
import { GroupsOrder } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/editor/common/editorGroupsService';
import { IEditorGroupsService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/editor/common/editorGroupsService.service';
import { IEditorService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/editor/common/editorService.service';
import { ITextFileService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/textfile/common/textfiles.service';
import { SAVE_FILE_COMMAND_ID, SAVE_FILE_WITHOUT_FORMATTING_COMMAND_ID, SAVE_FILE_AS_COMMAND_ID, SAVE_ALL_COMMAND_ID, SAVE_ALL_IN_GROUP_COMMAND_ID, SAVE_FILES_COMMAND_ID, REVERT_FILE_COMMAND_ID } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/files/browser/fileConstants';
import { getOpenEditorsViewMultiSelection } from './files.js';
import { isEqual } from '@codingame/monaco-vscode-api/vscode/vs/base/common/resources';
import { toErrorMessage } from '@codingame/monaco-vscode-api/vscode/vs/base/common/errorMessage';
import Severity from '@codingame/monaco-vscode-api/vscode/vs/base/common/severity';

async function saveSelectedEditors(accessor, options) {
    const editorGroupService = accessor.get(IEditorGroupsService);
    const codeEditorService = accessor.get(ICodeEditorService);
    const textFileService = accessor.get(ITextFileService);
    let editors = getOpenEditorsViewMultiSelection(accessor);
    if (!editors) {
        const activeGroup = editorGroupService.activeGroup;
        if (activeGroup.activeEditor) {
            editors = [];
            if (activeGroup.activeEditor instanceof SideBySideEditorInput &&
                !options?.saveAs && !(activeGroup.activeEditor.primary.hasCapability(EditorInputCapabilities.Untitled) || activeGroup.activeEditor.secondary.hasCapability(EditorInputCapabilities.Untitled)) &&
                activeGroup.activeEditor.secondary.isModified()) {
                editors.push({ groupId: activeGroup.id, editor: activeGroup.activeEditor.primary });
                editors.push({ groupId: activeGroup.id, editor: activeGroup.activeEditor.secondary });
            }
            else {
                editors.push({ groupId: activeGroup.id, editor: activeGroup.activeEditor });
            }
        }
    }
    if (!editors || editors.length === 0) {
        return;
    }
    await doSaveEditors(accessor, editors, options);
    const focusedCodeEditor = codeEditorService.getFocusedCodeEditor();
    if (focusedCodeEditor instanceof EmbeddedCodeEditorWidget && !focusedCodeEditor.isSimpleWidget) {
        const resource = focusedCodeEditor.getModel()?.uri;
        if (resource && !( editors.some(
            ({ editor }) => isEqual(EditorResourceAccessor.getCanonicalUri(editor, { supportSideBySide: SideBySideEditor.PRIMARY }), resource)
        ))) {
            const model = textFileService.files.get(resource);
            if (!model?.isReadonly()) {
                await textFileService.save(resource, options);
            }
        }
    }
}
function saveDirtyEditorsOfGroups(accessor, groups, options) {
    const dirtyEditors = [];
    for (const group of groups) {
        for (const editor of group.getEditors(EditorsOrder.MOST_RECENTLY_ACTIVE)) {
            if (editor.isDirty()) {
                dirtyEditors.push({ groupId: group.id, editor });
            }
        }
    }
    return doSaveEditors(accessor, dirtyEditors, options);
}
async function doSaveEditors(accessor, editors, options) {
    const editorService = accessor.get(IEditorService);
    const notificationService = accessor.get(INotificationService);
    const instantiationService = accessor.get(IInstantiationService);
    try {
        await editorService.save(editors, options);
    }
    catch (error) {
        if (!isCancellationError(error)) {
            const actions = [toAction({ id: 'workbench.action.files.saveEditors', label: ( localize(6767, "Retry")), run: () => instantiationService.invokeFunction(accessor => doSaveEditors(accessor, editors, options)) })];
            const editorsToRevert = editors.filter(({ editor }) => !editor.hasCapability(EditorInputCapabilities.Untitled) );
            if (editorsToRevert.length > 0) {
                actions.push(toAction({ id: 'workbench.action.files.revertEditors', label: editorsToRevert.length > 1 ? ( localize(6768, "Revert All")) : ( localize(6769, "Revert")), run: () => editorService.revert(editorsToRevert) }));
            }
            notificationService.notify({
                id: ( editors.map(({ editor }) => hash(editor.resource?.toString()))).join(),
                severity: Severity.Error,
                message: ( localize(
                    6770,
                    "Failed to save '{0}': {1}",
                    ( editors.map(({ editor }) => editor.getName())).join(', '),
                    toErrorMessage(error, false)
                )),
                actions: { primary: actions }
            });
        }
    }
}
KeybindingsRegistry.registerCommandAndKeybindingRule({
    when: undefined,
    weight: KeybindingWeight.WorkbenchContrib,
    primary: KeyMod.CtrlCmd | KeyCode.KeyS,
    id: SAVE_FILE_COMMAND_ID,
    handler: accessor => {
        return saveSelectedEditors(accessor, { reason: SaveReason.EXPLICIT, force: true  });
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    when: undefined,
    weight: KeybindingWeight.WorkbenchContrib,
    primary: KeyChord(KeyMod.CtrlCmd | KeyCode.KeyK, KeyCode.KeyS),
    win: { primary: KeyChord(KeyMod.CtrlCmd | KeyCode.KeyK, KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KeyS) },
    id: SAVE_FILE_WITHOUT_FORMATTING_COMMAND_ID,
    handler: accessor => {
        return saveSelectedEditors(accessor, { reason: SaveReason.EXPLICIT, force: true , skipSaveParticipants: true });
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: SAVE_FILE_AS_COMMAND_ID,
    weight: KeybindingWeight.WorkbenchContrib,
    when: undefined,
    primary: KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KeyS,
    handler: accessor => {
        return saveSelectedEditors(accessor, { reason: SaveReason.EXPLICIT, saveAs: true });
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    when: undefined,
    weight: KeybindingWeight.WorkbenchContrib,
    primary: undefined,
    mac: { primary: KeyMod.CtrlCmd | KeyMod.Alt | KeyCode.KeyS },
    win: { primary: KeyChord(KeyMod.CtrlCmd | KeyCode.KeyK, KeyCode.KeyS) },
    id: SAVE_ALL_COMMAND_ID,
    handler: accessor => {
        return saveDirtyEditorsOfGroups(accessor, accessor.get(IEditorGroupsService).getGroups(GroupsOrder.MOST_RECENTLY_ACTIVE), { reason: SaveReason.EXPLICIT });
    }
});
CommandsRegistry.registerCommand({
    id: SAVE_ALL_IN_GROUP_COMMAND_ID,
    handler: (accessor, _, editorContext) => {
        const editorGroupsService = accessor.get(IEditorGroupsService);
        const resolvedContext = resolveCommandsContext([editorContext], accessor.get(IEditorService), editorGroupsService, accessor.get(IListService));
        let groups = undefined;
        if (!resolvedContext.groupedEditors.length) {
            groups = editorGroupsService.getGroups(GroupsOrder.MOST_RECENTLY_ACTIVE);
        }
        else {
            groups = ( resolvedContext.groupedEditors.map(({ group }) => group));
        }
        return saveDirtyEditorsOfGroups(accessor, groups, { reason: SaveReason.EXPLICIT });
    }
});
CommandsRegistry.registerCommand({
    id: SAVE_FILES_COMMAND_ID,
    handler: async (accessor) => {
        const editorService = accessor.get(IEditorService);
        const res = await editorService.saveAll({ includeUntitled: false, reason: SaveReason.EXPLICIT });
        return res.success;
    }
});
CommandsRegistry.registerCommand({
    id: REVERT_FILE_COMMAND_ID,
    handler: async (accessor) => {
        const editorGroupService = accessor.get(IEditorGroupsService);
        const editorService = accessor.get(IEditorService);
        let editors = getOpenEditorsViewMultiSelection(accessor);
        if (!editors) {
            const activeGroup = editorGroupService.activeGroup;
            if (activeGroup.activeEditor) {
                editors = [{ groupId: activeGroup.id, editor: activeGroup.activeEditor }];
            }
        }
        if (!editors || editors.length === 0) {
            return;
        }
        try {
            await editorService.revert(editors.filter(({ editor }) => !editor.hasCapability(EditorInputCapabilities.Untitled) ), { force: true });
        }
        catch (error) {
            const notificationService = accessor.get(INotificationService);
            notificationService.error(( localize(
                6771,
                "Failed to revert '{0}': {1}",
                ( editors.map(({ editor }) => editor.getName())).join(', '),
                toErrorMessage(error, false)
            )));
        }
    }
});
