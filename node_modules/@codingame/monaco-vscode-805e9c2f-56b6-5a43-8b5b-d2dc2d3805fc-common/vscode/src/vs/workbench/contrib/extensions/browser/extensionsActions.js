
import { __decorate, __param } from '@codingame/monaco-vscode-api/external/tslib/tslib.es6';
import './media/extensionActions.css.js';
import { localize, localize2 } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import { Action, Separator, SubmenuAction } from '@codingame/monaco-vscode-api/vscode/vs/base/common/actions';
import { Throttler, Delayer, Promises } from '@codingame/monaco-vscode-api/vscode/vs/base/common/async';
import { getDomNodePagePosition } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/dom';
import { Emitter, Event } from '@codingame/monaco-vscode-api/vscode/vs/base/common/event';
import { parse, parseTree, findNodeAtLocation } from '@codingame/monaco-vscode-api/vscode/vs/base/common/json';
import { IContextMenuService } from '@codingame/monaco-vscode-api/vscode/vs/platform/contextview/browser/contextView.service';
import { disposeIfDisposable } from '@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle';
import { SELECT_INSTALL_VSIX_EXTENSION_COMMAND_ID, ExtensionState, ExtensionEditorTab, AutoUpdateConfigurationKey, INSTALL_ACTIONS_GROUP, UPDATE_ACTIONS_GROUP, THEME_ACTIONS_GROUP, TOGGLE_IGNORE_EXTENSION_ACTION_ID, ExtensionRuntimeActionType } from '@codingame/monaco-vscode-7ba0af96-90c2-5e11-ad7f-befdbbf246c8-common/vscode/vs/workbench/contrib/extensions/common/extensions';
import { IExtensionsWorkbenchService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/extensions/common/extensions.service';
import { ExtensionsConfigurationInitialContent } from '../common/extensionsFileTemplate.js';
import { ExtensionManagementErrorCode, InstallOperation } from '@codingame/monaco-vscode-api/vscode/vs/platform/extensionManagement/common/extensionManagement';
import { IExtensionGalleryService, IAllowedExtensionsService } from '@codingame/monaco-vscode-api/vscode/vs/platform/extensionManagement/common/extensionManagement.service';
import { EnablementState } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensionManagement/common/extensionManagement';
import { IExtensionManagementServerService, IWorkbenchExtensionEnablementService, IWorkbenchExtensionManagementService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensionManagement/common/extensionManagement.service';
import { ExtensionRecommendationReason } from '../../../services/extensionRecommendations/common/extensionRecommendations.js';
import { IExtensionRecommendationsService, IExtensionIgnoredRecommendationsService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensionRecommendations/common/extensionRecommendations.service';
import { areSameExtensions, getExtensionId } from '@codingame/monaco-vscode-api/vscode/vs/platform/extensionManagement/common/extensionManagementUtil';
import { TargetPlatform, ExtensionType, isLanguagePackExtension, isApplicationScopedExtension, ExtensionIdentifier, getWorkspaceSupportTypeMessage } from '@codingame/monaco-vscode-api/vscode/vs/platform/extensions/common/extensions';
import { IInstantiationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/instantiation/common/instantiation';
import { IFileService } from '@codingame/monaco-vscode-api/vscode/vs/platform/files/common/files.service';
import { WorkbenchState } from '@codingame/monaco-vscode-api/vscode/vs/platform/workspace/common/workspace';
import { IWorkspaceContextService } from '@codingame/monaco-vscode-api/vscode/vs/platform/workspace/common/workspace.service';
import { IHostService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/host/browser/host.service';
import { toExtensionDescription, toExtension } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensions/common/extensions';
import { IExtensionService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensions/common/extensions.service';
import { URI } from '@codingame/monaco-vscode-api/vscode/vs/base/common/uri';
import { CommandsRegistry } from '@codingame/monaco-vscode-api/vscode/vs/platform/commands/common/commands';
import { ICommandService } from '@codingame/monaco-vscode-api/vscode/vs/platform/commands/common/commands.service';
import { IConfigurationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/configuration/common/configuration.service';
import { registerThemingParticipant } from '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/themeService';
import { ThemeIcon } from '@codingame/monaco-vscode-api/vscode/vs/base/common/themables';
import { registerColor } from '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colorUtils';
import '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/baseColors';
import '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/chartsColors';
import { editorErrorForeground, editorWarningForeground, editorInfoForeground } from '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/editorColors';
import { buttonBackground, buttonForeground, buttonHoverBackground, buttonSeparator } from '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/inputColors';
import '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/listColors';
import '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/menuColors';
import '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/minimapColors';
import '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/miscColors';
import '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/quickpickColors';
import '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/searchColors';
import { IJSONEditingService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/configuration/common/jsonEditing.service';
import { ITextModelService } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/services/resolverService.service';
import { IContextKeyService } from '@codingame/monaco-vscode-api/vscode/vs/platform/contextkey/common/contextkey.service';
import { MenuId } from '@codingame/monaco-vscode-api/vscode/vs/platform/actions/common/actions';
import { IMenuService } from '@codingame/monaco-vscode-api/vscode/vs/platform/actions/common/actions.service';
import { PICK_WORKSPACE_FOLDER_COMMAND_ID } from '@codingame/monaco-vscode-a4c2011e-8775-52bd-abf0-4a3c07a9696b-common/vscode/vs/workbench/browser/actions/workspaceCommands';
import '@codingame/monaco-vscode-api/vscode/vs/platform/notification/common/notification';
import { INotificationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/notification/common/notification.service';
import { IOpenerService } from '@codingame/monaco-vscode-api/vscode/vs/platform/opener/common/opener.service';
import { IEditorService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/editor/common/editorService.service';
import { IQuickInputService } from '@codingame/monaco-vscode-api/vscode/vs/platform/quickinput/common/quickInput.service';
import { CancellationToken } from '@codingame/monaco-vscode-api/vscode/vs/base/common/cancellation';
import { alert } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/ui/aria/aria';
import { IWorkbenchThemeService } from '@codingame/monaco-vscode-7ba0af96-90c2-5e11-ad7f-befdbbf246c8-common/vscode/vs/workbench/services/themes/common/workbenchThemeService.service';
import { ILabelService } from '@codingame/monaco-vscode-api/vscode/vs/platform/label/common/label.service';
import { ITextFileService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/textfile/common/textfiles.service';
import { IProductService } from '@codingame/monaco-vscode-api/vscode/vs/platform/product/common/productService.service';
import { IDialogService } from '@codingame/monaco-vscode-api/vscode/vs/platform/dialogs/common/dialogs.service';
import { ProgressLocation } from '@codingame/monaco-vscode-api/vscode/vs/platform/progress/common/progress';
import { IProgressService } from '@codingame/monaco-vscode-api/vscode/vs/platform/progress/common/progress.service';
import { ActionViewItem } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/ui/actionbar/actionViewItems';
import { EXTENSIONS_CONFIG } from '../../../services/extensionRecommendations/common/workspaceExtensionsConfig.js';
import { isCancellationError, getErrorMessage } from '@codingame/monaco-vscode-api/vscode/vs/base/common/errors';
import { IUserDataSyncEnablementService } from '@codingame/monaco-vscode-api/vscode/vs/platform/userDataSync/common/userDataSync.service';
import { ILogService } from '@codingame/monaco-vscode-api/vscode/vs/platform/log/common/log.service';
import { manageExtensionIcon, syncIgnoredIcon, syncEnabledIcon, warningIcon, infoIcon, trustIcon, errorIcon } from '@codingame/monaco-vscode-7ba0af96-90c2-5e11-ad7f-befdbbf246c8-common/vscode/vs/workbench/contrib/extensions/browser/extensionsIcons';
import { isWeb, isIOS, language } from '@codingame/monaco-vscode-api/vscode/vs/base/common/platform';
import { IExtensionManifestPropertiesService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensions/common/extensionManifestPropertiesService.service';
import { IWorkspaceTrustEnablementService, IWorkspaceTrustManagementService } from '@codingame/monaco-vscode-api/vscode/vs/platform/workspace/common/workspaceTrust.service';
import { isVirtualWorkspace } from '@codingame/monaco-vscode-7559b0be-bfa5-5fe6-b731-1973fe9fffa1-common/vscode/vs/platform/workspace/common/virtualWorkspace';
import { MarkdownString, escapeMarkdownSyntaxTokens } from '@codingame/monaco-vscode-api/vscode/vs/base/common/htmlContent';
import { fromNow } from '@codingame/monaco-vscode-api/vscode/vs/base/common/date';
import { IPreferencesService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/preferences/common/preferences.service';
import { getLocale } from '@codingame/monaco-vscode-7ba0af96-90c2-5e11-ad7f-befdbbf246c8-common/vscode/vs/platform/languagePacks/common/languagePacks';
import { ILocaleService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/localization/common/locale.service';
import { isString } from '@codingame/monaco-vscode-api/vscode/vs/base/common/types';
import { showWindowLogActionId } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/log/common/logConstants';
import { ITelemetryService } from '@codingame/monaco-vscode-api/vscode/vs/platform/telemetry/common/telemetry.service';
import { Extensions } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensionManagement/common/extensionFeatures';
import { IExtensionFeaturesManagementService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensionManagement/common/extensionFeatures.service';
import { Registry } from '@codingame/monaco-vscode-api/vscode/vs/platform/registry/common/platform';
import { IUpdateService } from '@codingame/monaco-vscode-api/vscode/vs/platform/update/common/update.service';
import { ActionWithDropdownActionViewItem } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/ui/dropdown/dropdownActionViewItem';
import { IAuthenticationUsageService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/authentication/browser/authenticationUsageService.service';
import Severity from '@codingame/monaco-vscode-api/vscode/vs/base/common/severity';

var InstallAction_1, InstallInOtherServerAction_1, UninstallAction_1, UpdateAction_1, ToggleAutoUpdateForExtensionAction_1, ToggleAutoUpdatesForPublisherAction_1, MigrateDeprecatedExtensionAction_1, ManageExtensionAction_1, TogglePreReleaseExtensionAction_1, InstallAnotherVersionAction_1, EnableForWorkspaceAction_1, EnableGloballyAction_1, DisableForWorkspaceAction_1, DisableGloballyAction_1, ExtensionRuntimeStateAction_1, SetColorThemeAction_1, SetFileIconThemeAction_1, SetProductIconThemeAction_1, SetLanguageAction_1, ClearLanguageAction_1, ShowRecommendedExtensionAction_1, InstallRecommendedExtensionAction_1, IgnoreExtensionRecommendationAction_1, UndoIgnoreExtensionRecommendationAction_1, ExtensionStatusLabelAction_1, ToggleSyncExtensionAction_1, ExtensionStatusAction_1, InstallSpecificVersionOfExtensionAction_1;
let PromptExtensionInstallFailureAction = class PromptExtensionInstallFailureAction extends Action {
    constructor(extension, options, version, installOperation, error, productService, openerService, notificationService, dialogService, commandService, logService, extensionManagementServerService, instantiationService, galleryService, extensionManifestPropertiesService) {
        super('extension.promptExtensionInstallFailure');
        this.extension = extension;
        this.options = options;
        this.version = version;
        this.installOperation = installOperation;
        this.error = error;
        this.productService = productService;
        this.openerService = openerService;
        this.notificationService = notificationService;
        this.dialogService = dialogService;
        this.commandService = commandService;
        this.logService = logService;
        this.extensionManagementServerService = extensionManagementServerService;
        this.instantiationService = instantiationService;
        this.galleryService = galleryService;
        this.extensionManifestPropertiesService = extensionManifestPropertiesService;
    }
    async run() {
        if (isCancellationError(this.error)) {
            return;
        }
        this.logService.error(this.error);
        if (this.error.name === ExtensionManagementErrorCode.Unsupported) {
            const productName = isWeb ? ( localize(6241, "{0} for the Web", this.productService.nameLong)) : this.productService.nameLong;
            const message = ( localize(
                6242,
                "The '{0}' extension is not available in {1}. Click 'More Information' to learn more.",
                this.extension.displayName || this.extension.identifier.id,
                productName
            ));
            const { confirmed } = await this.dialogService.confirm({
                type: Severity.Info,
                message,
                primaryButton: ( localize(6243, "&&More Information")),
                cancelButton: ( localize(6244, "Close"))
            });
            if (confirmed) {
                this.openerService.open(isWeb ? ( URI.parse('https://aka.ms/vscode-web-extensions-guide')) : ( URI.parse('https://aka.ms/vscode-remote')));
            }
            return;
        }
        if (ExtensionManagementErrorCode.ReleaseVersionNotFound === this.error.name) {
            await this.dialogService.prompt({
                type: 'error',
                message: getErrorMessage(this.error),
                buttons: [{
                        label: ( localize(6245, "Install Pre-Release")),
                        run: () => {
                            const installAction = this.instantiationService.createInstance(InstallAction, { installPreReleaseVersion: true });
                            installAction.extension = this.extension;
                            return installAction.run();
                        }
                    }],
                cancelButton: ( localize(6246, "Cancel"))
            });
            return;
        }
        if ([ExtensionManagementErrorCode.Incompatible, ExtensionManagementErrorCode.IncompatibleApi, ExtensionManagementErrorCode.IncompatibleTargetPlatform, ExtensionManagementErrorCode.Malicious, ExtensionManagementErrorCode.Deprecated].includes(this.error.name)) {
            await this.dialogService.info(getErrorMessage(this.error));
            return;
        }
        if (ExtensionManagementErrorCode.PackageNotSigned === this.error.name) {
            await this.dialogService.prompt({
                type: 'error',
                message: ( localize(
                    6247,
                    "'{0}' is an extension from an unknown source. Are you sure you want to install?",
                    this.extension.displayName
                )),
                detail: getErrorMessage(this.error),
                buttons: [{
                        label: ( localize(6248, "Install Anyway")),
                        run: () => {
                            const installAction = this.instantiationService.createInstance(InstallAction, { ...this.options, donotVerifySignature: true, });
                            installAction.extension = this.extension;
                            return installAction.run();
                        }
                    }],
                cancelButton: true
            });
            return;
        }
        if (ExtensionManagementErrorCode.SignatureVerificationFailed === this.error.name || ExtensionManagementErrorCode.SignatureVerificationInternal === this.error.name) {
            await this.dialogService.prompt({
                type: 'error',
                message: ( localize(
                    6249,
                    "Cannot install '{0}' extension because {1} cannot verify the extension signature",
                    this.extension.displayName,
                    this.productService.nameLong
                )),
                detail: getErrorMessage(this.error),
                buttons: [{
                        label: ( localize(6250, "Learn More")),
                        run: () => this.openerService.open('https://code.visualstudio.com/docs/editor/extension-marketplace#_the-extension-signature-cannot-be-verified-by-vs-code')
                    }, {
                        label: ( localize(6251, "Install Anyway (Don't Verify Signature)")),
                        run: () => {
                            const installAction = this.instantiationService.createInstance(InstallAction, { ...this.options, donotVerifySignature: true, });
                            installAction.extension = this.extension;
                            return installAction.run();
                        }
                    }],
                cancelButton: true
            });
            return;
        }
        const operationMessage = this.installOperation === InstallOperation.Update ? ( localize(
            6252,
            "Error while updating '{0}' extension.",
            this.extension.displayName || this.extension.identifier.id
        ))
            : ( localize(
            6253,
            "Error while installing '{0}' extension.",
            this.extension.displayName || this.extension.identifier.id
        ));
        let additionalMessage;
        const promptChoices = [];
        const downloadUrl = await this.getDownloadUrl();
        if (downloadUrl) {
            additionalMessage = ( localize(
                6254,
                "Please check the [log]({0}) for more details.",
                `command:${showWindowLogActionId}`
            ));
            promptChoices.push({
                label: ( localize(6255, "Try Downloading Manually...")),
                run: () => this.openerService.open(downloadUrl).then(() => {
                    this.notificationService.prompt(Severity.Info, ( localize(
                        6256,
                        'Once downloaded, please manually install the downloaded VSIX of \'{0}\'.',
                        this.extension.identifier.id
                    )), [{
                            label: ( localize(6257, "Install from VSIX...")),
                            run: () => this.commandService.executeCommand(SELECT_INSTALL_VSIX_EXTENSION_COMMAND_ID)
                        }]);
                })
            });
        }
        const message = `${operationMessage}${additionalMessage ? ` ${additionalMessage}` : ''}`;
        this.notificationService.prompt(Severity.Error, message, promptChoices);
    }
    async getDownloadUrl() {
        if (isIOS) {
            return undefined;
        }
        if (!this.extension.gallery) {
            return undefined;
        }
        if (!this.productService.extensionsGallery) {
            return undefined;
        }
        if (!this.extensionManagementServerService.localExtensionManagementServer && !this.extensionManagementServerService.remoteExtensionManagementServer) {
            return undefined;
        }
        let targetPlatform = this.extension.gallery.properties.targetPlatform;
        if (targetPlatform !== TargetPlatform.UNIVERSAL && targetPlatform !== TargetPlatform.UNDEFINED && this.extensionManagementServerService.remoteExtensionManagementServer) {
            try {
                const manifest = await this.galleryService.getManifest(this.extension.gallery, CancellationToken.None);
                if (manifest && this.extensionManifestPropertiesService.prefersExecuteOnWorkspace(manifest)) {
                    targetPlatform = await this.extensionManagementServerService.remoteExtensionManagementServer.extensionManagementService.getTargetPlatform();
                }
            }
            catch (error) {
                this.logService.error(error);
                return undefined;
            }
        }
        if (targetPlatform === TargetPlatform.UNKNOWN) {
            return undefined;
        }
        return ( URI.parse(
            `${this.productService.extensionsGallery.serviceUrl}/publishers/${this.extension.publisher}/vsextensions/${this.extension.name}/${this.version}/vspackage${targetPlatform !== TargetPlatform.UNDEFINED ? `?targetPlatform=${targetPlatform}` : ''}`
        ));
    }
};
PromptExtensionInstallFailureAction = ( __decorate([
    ( __param(5, IProductService)),
    ( __param(6, IOpenerService)),
    ( __param(7, INotificationService)),
    ( __param(8, IDialogService)),
    ( __param(9, ICommandService)),
    ( __param(10, ILogService)),
    ( __param(11, IExtensionManagementServerService)),
    ( __param(12, IInstantiationService)),
    ( __param(13, IExtensionGalleryService)),
    ( __param(14, IExtensionManifestPropertiesService))
], PromptExtensionInstallFailureAction));
class ExtensionAction extends Action {
    constructor() {
        super(...arguments);
        this._onDidChange = this._register(( new Emitter()));
        this.onDidChange = this._onDidChange.event;
        this._extension = null;
        this._hidden = false;
        this.hideOnDisabled = true;
    }
    static { this.EXTENSION_ACTION_CLASS = 'extension-action'; }
    static { this.TEXT_ACTION_CLASS = `${ExtensionAction.EXTENSION_ACTION_CLASS} text`; }
    static { this.LABEL_ACTION_CLASS = `${ExtensionAction.EXTENSION_ACTION_CLASS} label`; }
    static { this.PROMINENT_LABEL_ACTION_CLASS = `${ExtensionAction.LABEL_ACTION_CLASS} prominent`; }
    static { this.ICON_ACTION_CLASS = `${ExtensionAction.EXTENSION_ACTION_CLASS} icon`; }
    get extension() { return this._extension; }
    set extension(extension) { this._extension = extension; this.update(); }
    get hidden() { return this._hidden; }
    set hidden(hidden) {
        if (this._hidden !== hidden) {
            this._hidden = hidden;
            this._onDidChange.fire({ hidden });
        }
    }
    _setEnabled(value) {
        super._setEnabled(value);
        if (this.hideOnDisabled) {
            this.hidden = !value;
        }
    }
}
class ButtonWithDropDownExtensionAction extends ExtensionAction {
    get menuActions() { return [...this._menuActions]; }
    get extension() {
        return super.extension;
    }
    set extension(extension) {
        this.extensionActions.forEach(a => a.extension = extension);
        super.extension = extension;
    }
    constructor(id, clazz, actionsGroups) {
        clazz = `${clazz} action-dropdown`;
        super(id, undefined, clazz);
        this.actionsGroups = actionsGroups;
        this.menuActionClassNames = [];
        this._menuActions = [];
        this.menuActionClassNames = clazz.split(' ');
        this.hideOnDisabled = false;
        this.extensionActions = actionsGroups.flat();
        this.update();
        this._register(Event.any(...( this.extensionActions.map(a => a.onDidChange)))(() => this.update(true)));
        this.extensionActions.forEach(a => this._register(a));
    }
    update(donotUpdateActions) {
        if (!donotUpdateActions) {
            this.extensionActions.forEach(a => a.update());
        }
        const actionsGroups = ( this.actionsGroups.map(actionsGroup => actionsGroup.filter(a => !a.hidden)));
        let actions = [];
        for (const visibleActions of actionsGroups) {
            if (visibleActions.length) {
                actions = [...actions, ...visibleActions, ( new Separator())];
            }
        }
        actions = actions.length ? actions.slice(0, actions.length - 1) : actions;
        this.primaryAction = actions[0];
        this._menuActions = actions.length > 1 ? actions : [];
        this._onDidChange.fire({ menuActions: this._menuActions });
        if (this.primaryAction) {
            this.hidden = false;
            this.enabled = this.primaryAction.enabled;
            this.label = this.getLabel(this.primaryAction);
            this.tooltip = this.primaryAction.tooltip;
        }
        else {
            this.hidden = true;
            this.enabled = false;
        }
    }
    async run() {
        if (this.enabled) {
            await this.primaryAction?.run();
        }
    }
    getLabel(action) {
        return action.label;
    }
}
class ButtonWithDropdownExtensionActionViewItem extends ActionWithDropdownActionViewItem {
    constructor(action, options, contextMenuProvider) {
        super(null, action, options, contextMenuProvider);
        this._register(action.onDidChange(e => {
            if (e.hidden !== undefined || e.menuActions !== undefined) {
                this.updateClass();
            }
        }));
    }
    render(container) {
        super.render(container);
        this.updateClass();
    }
    updateClass() {
        super.updateClass();
        if (this.element && this.dropdownMenuActionViewItem?.element) {
            this.element.classList.toggle('hide', this._action.hidden);
            const isMenuEmpty = this._action.menuActions.length === 0;
            this.element.classList.toggle('empty', isMenuEmpty);
            this.dropdownMenuActionViewItem.element.classList.toggle('hide', isMenuEmpty);
        }
    }
}
let InstallAction = class InstallAction extends ExtensionAction {
    static { InstallAction_1 = this; }
    static { this.CLASS = `${this.LABEL_ACTION_CLASS} prominent install`; }
    static { this.HIDE = `${this.CLASS} hide`; }
    set manifest(manifest) {
        this._manifest = manifest;
        this.updateLabel();
    }
    constructor(options, extensionsWorkbenchService, instantiationService, runtimeExtensionService, workbenchThemeService, labelService, dialogService, preferencesService, telemetryService, contextService, allowedExtensionsService) {
        super('extensions.install', ( localize(6258, "Install")), InstallAction_1.CLASS, false);
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.instantiationService = instantiationService;
        this.runtimeExtensionService = runtimeExtensionService;
        this.workbenchThemeService = workbenchThemeService;
        this.labelService = labelService;
        this.dialogService = dialogService;
        this.preferencesService = preferencesService;
        this.telemetryService = telemetryService;
        this.contextService = contextService;
        this.allowedExtensionsService = allowedExtensionsService;
        this._manifest = null;
        this.updateThrottler = ( new Throttler());
        this.hideOnDisabled = false;
        this.options = { isMachineScoped: false, ...options };
        this.update();
        this._register(allowedExtensionsService.onDidChangeAllowedExtensionsConfigValue(() => this.update()));
        this._register(this.labelService.onDidChangeFormatters(() => this.updateLabel(), this));
    }
    update() {
        this.updateThrottler.queue(() => this.computeAndUpdateEnablement());
    }
    async computeAndUpdateEnablement() {
        this.enabled = false;
        this.class = InstallAction_1.HIDE;
        this.hidden = true;
        if (!this.extension) {
            return;
        }
        if (this.extension.isBuiltin) {
            return;
        }
        if (this.extensionsWorkbenchService.canSetLanguage(this.extension)) {
            return;
        }
        if (this.extension.state !== ExtensionState.Uninstalled) {
            return;
        }
        if (this.options.installPreReleaseVersion && (!this.extension.hasPreReleaseVersion || this.allowedExtensionsService.isAllowed({ id: this.extension.identifier.id, publisherDisplayName: this.extension.publisherDisplayName, prerelease: true }) !== true)) {
            return;
        }
        if (!this.options.installPreReleaseVersion && !this.extension.hasReleaseVersion) {
            return;
        }
        this.hidden = false;
        this.class = InstallAction_1.CLASS;
        if ((await this.extensionsWorkbenchService.canInstall(this.extension)) === true) {
            this.enabled = true;
            this.updateLabel();
        }
    }
    async run() {
        if (!this.extension) {
            return;
        }
        if (this.extension.gallery && !this.extension.gallery.isSigned) {
            const { result } = await this.dialogService.prompt({
                type: Severity.Warning,
                message: ( localize(
                    6247,
                    "'{0}' is an extension from an unknown source. Are you sure you want to install?",
                    this.extension.displayName
                )),
                detail: ( localize(6259, "Extension is not signed.")),
                buttons: [
                    {
                        label: ( localize(6248, "Install Anyway")),
                        run: () => {
                            this.options.donotVerifySignature = true;
                            return true;
                        }
                    }
                ],
                cancelButton: {
                    run: () => false
                }
            });
            if (!result) {
                return;
            }
        }
        if (this.extension.deprecationInfo) {
            let detail = ( localize(6260, "This extension is deprecated as it is no longer being maintained."));
            let DeprecationChoice;
            (function (DeprecationChoice) {
                DeprecationChoice[DeprecationChoice["InstallAnyway"] = 0] = "InstallAnyway";
                DeprecationChoice[DeprecationChoice["ShowAlternateExtension"] = 1] = "ShowAlternateExtension";
                DeprecationChoice[DeprecationChoice["ConfigureSettings"] = 2] = "ConfigureSettings";
                DeprecationChoice[DeprecationChoice["Cancel"] = 3] = "Cancel";
            })(DeprecationChoice || (DeprecationChoice = {}));
            const buttons = [
                {
                    label: ( localize(6248, "Install Anyway")),
                    run: () => DeprecationChoice.InstallAnyway
                }
            ];
            if (this.extension.deprecationInfo.extension) {
                detail = ( localize(
                    6261,
                    "This extension is deprecated. Use the {0} extension instead.",
                    this.extension.deprecationInfo.extension.displayName
                ));
                const alternateExtension = this.extension.deprecationInfo.extension;
                buttons.push({
                    label: ( localize(6262, "&&Open {0}", this.extension.deprecationInfo.extension.displayName)),
                    run: async () => {
                        const [extension] = await this.extensionsWorkbenchService.getExtensions([{ id: alternateExtension.id, preRelease: alternateExtension.preRelease }], CancellationToken.None);
                        await this.extensionsWorkbenchService.open(extension);
                        return DeprecationChoice.ShowAlternateExtension;
                    }
                });
            }
            else if (this.extension.deprecationInfo.settings) {
                detail = ( localize(
                    6263,
                    "This extension is deprecated as this functionality is now built-in to VS Code."
                ));
                const settings = this.extension.deprecationInfo.settings;
                buttons.push({
                    label: ( localize(6264, "&&Configure Settings")),
                    run: async () => {
                        await this.preferencesService.openSettings({ query: ( settings.map(setting => `@id:${setting}`)).join(' ') });
                        return DeprecationChoice.ConfigureSettings;
                    }
                });
            }
            else if (this.extension.deprecationInfo.additionalInfo) {
                detail = ( new MarkdownString(`${detail} ${this.extension.deprecationInfo.additionalInfo}`));
            }
            const { result } = await this.dialogService.prompt({
                type: Severity.Warning,
                message: ( localize(
                    6265,
                    "Are you sure you want to install '{0}'?",
                    this.extension.displayName
                )),
                detail: isString(detail) ? detail : undefined,
                custom: isString(detail) ? undefined : {
                    markdownDetails: [{
                            markdown: detail
                        }]
                },
                buttons,
                cancelButton: {
                    run: () => DeprecationChoice.Cancel
                }
            });
            if (result !== DeprecationChoice.InstallAnyway) {
                return;
            }
        }
        this.extensionsWorkbenchService.open(this.extension, { showPreReleaseVersion: this.options.installPreReleaseVersion });
        alert(( localize(
            6266,
            "Installing extension {0} started. An editor is now open with more details on this extension",
            this.extension.displayName
        )));
        this.telemetryService.publicLog('extensions:action:install', { ...this.extension.telemetryData, actionId: this.id });
        const extension = await this.install(this.extension);
        if (extension?.local) {
            alert(( localize(6267, "Installing extension {0} is completed.", this.extension.displayName)));
            const runningExtension = await this.getRunningExtension(extension.local);
            if (runningExtension && !(runningExtension.activationEvents && ( runningExtension.activationEvents.some(activationEent => activationEent.startsWith('onLanguage'))))) {
                const action = await this.getThemeAction(extension);
                if (action) {
                    action.extension = extension;
                    try {
                        return action.run({ showCurrentTheme: true, ignoreFocusLost: true });
                    }
                    finally {
                        action.dispose();
                    }
                }
            }
        }
    }
    async getThemeAction(extension) {
        const colorThemes = await this.workbenchThemeService.getColorThemes();
        if (( colorThemes.some(theme => isThemeFromExtension(theme, extension)))) {
            return this.instantiationService.createInstance(SetColorThemeAction);
        }
        const fileIconThemes = await this.workbenchThemeService.getFileIconThemes();
        if (( fileIconThemes.some(theme => isThemeFromExtension(theme, extension)))) {
            return this.instantiationService.createInstance(SetFileIconThemeAction);
        }
        const productIconThemes = await this.workbenchThemeService.getProductIconThemes();
        if (( productIconThemes.some(theme => isThemeFromExtension(theme, extension)))) {
            return this.instantiationService.createInstance(SetProductIconThemeAction);
        }
        return undefined;
    }
    async install(extension) {
        try {
            return await this.extensionsWorkbenchService.install(extension, this.options);
        }
        catch (error) {
            await this.instantiationService.createInstance(PromptExtensionInstallFailureAction, extension, this.options, extension.latestVersion, InstallOperation.Install, error).run();
            return undefined;
        }
    }
    async getRunningExtension(extension) {
        const runningExtension = await this.runtimeExtensionService.getExtension(extension.identifier.id);
        if (runningExtension) {
            return runningExtension;
        }
        if (this.runtimeExtensionService.canAddExtension(toExtensionDescription(extension))) {
            return ( new Promise((c, e) => {
                const disposable = this.runtimeExtensionService.onDidChangeExtensions(async () => {
                    const runningExtension = await this.runtimeExtensionService.getExtension(extension.identifier.id);
                    if (runningExtension) {
                        disposable.dispose();
                        c(runningExtension);
                    }
                });
            }));
        }
        return null;
    }
    updateLabel() {
        this.label = this.getLabel();
    }
    getLabel(primary) {
        if (this.extension?.isWorkspaceScoped && this.extension.resourceExtension && this.contextService.isInsideWorkspace(this.extension.resourceExtension.location)) {
            return localize(6268, "Install Workspace Extension");
        }
        if (this.options.installPreReleaseVersion && this.extension?.hasPreReleaseVersion) {
            return primary ? ( localize(6269, "Install Pre-Release")) : ( localize(6270, "Install Pre-Release Version"));
        }
        if (this.extension?.hasPreReleaseVersion) {
            return primary ? ( localize(6258, "Install")) : ( localize(6271, "Install Release Version"));
        }
        return localize(6258, "Install");
    }
};
InstallAction = InstallAction_1 = ( __decorate([
    ( __param(1, IExtensionsWorkbenchService)),
    ( __param(2, IInstantiationService)),
    ( __param(3, IExtensionService)),
    ( __param(4, IWorkbenchThemeService)),
    ( __param(5, ILabelService)),
    ( __param(6, IDialogService)),
    ( __param(7, IPreferencesService)),
    ( __param(8, ITelemetryService)),
    ( __param(9, IWorkspaceContextService)),
    ( __param(10, IAllowedExtensionsService))
], InstallAction));
let InstallDropdownAction = class InstallDropdownAction extends ButtonWithDropDownExtensionAction {
    set manifest(manifest) {
        this.extensionActions.forEach(a => a.manifest = manifest);
        this.update();
    }
    constructor(instantiationService, extensionsWorkbenchService) {
        super(`extensions.installActions`, InstallAction.CLASS, [
            [
                instantiationService.createInstance(InstallAction, { installPreReleaseVersion: extensionsWorkbenchService.preferPreReleases }),
                instantiationService.createInstance(InstallAction, { installPreReleaseVersion: !extensionsWorkbenchService.preferPreReleases }),
            ]
        ]);
    }
    getLabel(action) {
        return action.getLabel(true);
    }
};
InstallDropdownAction = ( __decorate([
    ( __param(0, IInstantiationService)),
    ( __param(1, IExtensionsWorkbenchService))
], InstallDropdownAction));
class InstallingLabelAction extends ExtensionAction {
    static { this.LABEL = ( localize(6272, "Installing")); }
    static { this.CLASS = `${ExtensionAction.LABEL_ACTION_CLASS} install installing`; }
    constructor() {
        super('extension.installing', InstallingLabelAction.LABEL, InstallingLabelAction.CLASS, false);
    }
    update() {
        this.class = `${InstallingLabelAction.CLASS}${this.extension && this.extension.state === ExtensionState.Installing ? '' : ' hide'}`;
    }
}
let InstallInOtherServerAction = class InstallInOtherServerAction extends ExtensionAction {
    static { InstallInOtherServerAction_1 = this; }
    static { this.INSTALL_LABEL = ( localize(6258, "Install")); }
    static { this.INSTALLING_LABEL = ( localize(6272, "Installing")); }
    static { this.Class = `${ExtensionAction.LABEL_ACTION_CLASS} prominent install-other-server`; }
    static { this.InstallingClass = `${ExtensionAction.LABEL_ACTION_CLASS} install-other-server installing`; }
    constructor(id, server, canInstallAnyWhere, extensionsWorkbenchService, extensionManagementServerService, extensionManifestPropertiesService) {
        super(id, InstallInOtherServerAction_1.INSTALL_LABEL, InstallInOtherServerAction_1.Class, false);
        this.server = server;
        this.canInstallAnyWhere = canInstallAnyWhere;
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.extensionManagementServerService = extensionManagementServerService;
        this.extensionManifestPropertiesService = extensionManifestPropertiesService;
        this.updateWhenCounterExtensionChanges = true;
        this.update();
    }
    update() {
        this.enabled = false;
        this.class = InstallInOtherServerAction_1.Class;
        if (this.canInstall()) {
            const extensionInOtherServer = this.extensionsWorkbenchService.installed.filter(e => areSameExtensions(e.identifier, this.extension.identifier) && e.server === this.server)[0];
            if (extensionInOtherServer) {
                if (extensionInOtherServer.state === ExtensionState.Installing && !extensionInOtherServer.local) {
                    this.enabled = true;
                    this.label = InstallInOtherServerAction_1.INSTALLING_LABEL;
                    this.class = InstallInOtherServerAction_1.InstallingClass;
                }
            }
            else {
                this.enabled = true;
                this.label = this.getInstallLabel();
            }
        }
    }
    canInstall() {
        if (!this.extension
            || !this.server
            || !this.extension.local
            || this.extension.state !== ExtensionState.Installed
            || this.extension.type !== ExtensionType.User
            || this.extension.enablementState === EnablementState.DisabledByEnvironment || this.extension.enablementState === EnablementState.DisabledByTrustRequirement || this.extension.enablementState === EnablementState.DisabledByVirtualWorkspace) {
            return false;
        }
        if (isLanguagePackExtension(this.extension.local.manifest)) {
            return true;
        }
        if (this.server === this.extensionManagementServerService.localExtensionManagementServer && this.extensionManifestPropertiesService.prefersExecuteOnUI(this.extension.local.manifest)) {
            return true;
        }
        if (this.server === this.extensionManagementServerService.remoteExtensionManagementServer && this.extensionManifestPropertiesService.prefersExecuteOnWorkspace(this.extension.local.manifest)) {
            return true;
        }
        if (this.server === this.extensionManagementServerService.webExtensionManagementServer && this.extensionManifestPropertiesService.prefersExecuteOnWeb(this.extension.local.manifest)) {
            return true;
        }
        if (this.canInstallAnyWhere) {
            if (this.server === this.extensionManagementServerService.localExtensionManagementServer && this.extensionManifestPropertiesService.canExecuteOnUI(this.extension.local.manifest)) {
                return true;
            }
            if (this.server === this.extensionManagementServerService.remoteExtensionManagementServer && this.extensionManifestPropertiesService.canExecuteOnWorkspace(this.extension.local.manifest)) {
                return true;
            }
        }
        return false;
    }
    async run() {
        if (!this.extension?.local) {
            return;
        }
        if (!this.extension?.server) {
            return;
        }
        if (!this.server) {
            return;
        }
        this.extensionsWorkbenchService.open(this.extension);
        alert(( localize(
            6266,
            "Installing extension {0} started. An editor is now open with more details on this extension",
            this.extension.displayName
        )));
        return this.extensionsWorkbenchService.installInServer(this.extension, this.server);
    }
};
InstallInOtherServerAction = InstallInOtherServerAction_1 = ( __decorate([
    ( __param(3, IExtensionsWorkbenchService)),
    ( __param(4, IExtensionManagementServerService)),
    ( __param(5, IExtensionManifestPropertiesService))
], InstallInOtherServerAction));
let RemoteInstallAction = class RemoteInstallAction extends InstallInOtherServerAction {
    constructor(canInstallAnyWhere, extensionsWorkbenchService, extensionManagementServerService, extensionManifestPropertiesService) {
        super(`extensions.remoteinstall`, extensionManagementServerService.remoteExtensionManagementServer, canInstallAnyWhere, extensionsWorkbenchService, extensionManagementServerService, extensionManifestPropertiesService);
    }
    getInstallLabel() {
        return this.extensionManagementServerService.remoteExtensionManagementServer
            ? ( localize(
            6273,
            "Install in {0}",
            this.extensionManagementServerService.remoteExtensionManagementServer.label
        ))
            : InstallInOtherServerAction.INSTALL_LABEL;
    }
};
RemoteInstallAction = ( __decorate([
    ( __param(1, IExtensionsWorkbenchService)),
    ( __param(2, IExtensionManagementServerService)),
    ( __param(3, IExtensionManifestPropertiesService))
], RemoteInstallAction));
let LocalInstallAction = class LocalInstallAction extends InstallInOtherServerAction {
    constructor(extensionsWorkbenchService, extensionManagementServerService, extensionManifestPropertiesService) {
        super(`extensions.localinstall`, extensionManagementServerService.localExtensionManagementServer, false, extensionsWorkbenchService, extensionManagementServerService, extensionManifestPropertiesService);
    }
    getInstallLabel() {
        return localize(6274, "Install Locally");
    }
};
LocalInstallAction = ( __decorate([
    ( __param(0, IExtensionsWorkbenchService)),
    ( __param(1, IExtensionManagementServerService)),
    ( __param(2, IExtensionManifestPropertiesService))
], LocalInstallAction));
let WebInstallAction = class WebInstallAction extends InstallInOtherServerAction {
    constructor(extensionsWorkbenchService, extensionManagementServerService, extensionManifestPropertiesService) {
        super(`extensions.webInstall`, extensionManagementServerService.webExtensionManagementServer, false, extensionsWorkbenchService, extensionManagementServerService, extensionManifestPropertiesService);
    }
    getInstallLabel() {
        return localize(6275, "Install in Browser");
    }
};
WebInstallAction = ( __decorate([
    ( __param(0, IExtensionsWorkbenchService)),
    ( __param(1, IExtensionManagementServerService)),
    ( __param(2, IExtensionManifestPropertiesService))
], WebInstallAction));
let UninstallAction = class UninstallAction extends ExtensionAction {
    static { UninstallAction_1 = this; }
    static { this.UninstallLabel = ( localize(6276, "Uninstall")); }
    static { this.UninstallingLabel = ( localize(6277, "Uninstalling")); }
    static { this.UninstallClass = `${ExtensionAction.LABEL_ACTION_CLASS} uninstall`; }
    static { this.UnInstallingClass = `${ExtensionAction.LABEL_ACTION_CLASS} uninstall uninstalling`; }
    constructor(extensionsWorkbenchService, dialogService) {
        super('extensions.uninstall', UninstallAction_1.UninstallLabel, UninstallAction_1.UninstallClass, false);
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.dialogService = dialogService;
        this.update();
    }
    update() {
        if (!this.extension) {
            this.enabled = false;
            return;
        }
        const state = this.extension.state;
        if (state === ExtensionState.Uninstalling) {
            this.label = UninstallAction_1.UninstallingLabel;
            this.class = UninstallAction_1.UnInstallingClass;
            this.enabled = false;
            return;
        }
        this.label = UninstallAction_1.UninstallLabel;
        this.class = UninstallAction_1.UninstallClass;
        this.tooltip = UninstallAction_1.UninstallLabel;
        if (state !== ExtensionState.Installed) {
            this.enabled = false;
            return;
        }
        if (this.extension.isBuiltin) {
            this.enabled = false;
            return;
        }
        this.enabled = true;
    }
    async run() {
        if (!this.extension) {
            return;
        }
        alert(( localize(6278, "Uninstalling extension {0} started.", this.extension.displayName)));
        try {
            await this.extensionsWorkbenchService.uninstall(this.extension);
            alert(( localize(
                6279,
                "Please reload Visual Studio Code to complete the uninstallation of the extension {0}.",
                this.extension.displayName
            )));
        }
        catch (error) {
            if (!isCancellationError(error)) {
                this.dialogService.error(getErrorMessage(error));
            }
        }
    }
};
UninstallAction = UninstallAction_1 = ( __decorate([
    ( __param(0, IExtensionsWorkbenchService)),
    ( __param(1, IDialogService))
], UninstallAction));
let UpdateAction = class UpdateAction extends ExtensionAction {
    static { UpdateAction_1 = this; }
    static { this.EnabledClass = `${this.LABEL_ACTION_CLASS} prominent update`; }
    static { this.DisabledClass = `${this.EnabledClass} disabled`; }
    constructor(verbose, extensionsWorkbenchService, dialogService, openerService, instantiationService) {
        super(`extensions.update`, ( localize(6280, "Update")), UpdateAction_1.DisabledClass, false);
        this.verbose = verbose;
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.dialogService = dialogService;
        this.openerService = openerService;
        this.instantiationService = instantiationService;
        this.updateThrottler = ( new Throttler());
        this.update();
    }
    update() {
        this.updateThrottler.queue(() => this.computeAndUpdateEnablement());
        if (this.extension) {
            this.label = this.verbose ? ( localize(6281, "Update to v{0}", this.extension.latestVersion)) : ( localize(6280, "Update"));
        }
    }
    async computeAndUpdateEnablement() {
        this.enabled = false;
        this.class = UpdateAction_1.DisabledClass;
        if (!this.extension) {
            return;
        }
        if (this.extension.deprecationInfo) {
            return;
        }
        const canInstall = await this.extensionsWorkbenchService.canInstall(this.extension);
        const isInstalled = this.extension.state === ExtensionState.Installed;
        this.enabled = canInstall === true && isInstalled && this.extension.outdated;
        this.class = this.enabled ? UpdateAction_1.EnabledClass : UpdateAction_1.DisabledClass;
    }
    async run() {
        if (!this.extension) {
            return;
        }
        const consent = await this.extensionsWorkbenchService.shouldRequireConsentToUpdate(this.extension);
        if (consent) {
            const { result } = await this.dialogService.prompt({
                type: 'warning',
                title: ( localize(6282, "Update {0} Extension", this.extension.displayName)),
                message: ( localize(6283, "{0}\n\nWould you like to update the extension?", consent)),
                buttons: [{
                        label: ( localize(6280, "Update")),
                        run: () => 'update'
                    }, {
                        label: ( localize(6284, "Review")),
                        run: () => 'review'
                    }, {
                        label: ( localize(6246, "Cancel")),
                        run: () => 'cancel'
                    }]
            });
            if (result === 'cancel') {
                return;
            }
            if (result === 'review') {
                if (this.extension.hasChangelog()) {
                    return this.extensionsWorkbenchService.open(this.extension, { tab: ExtensionEditorTab.Changelog });
                }
                if (this.extension.repository) {
                    return this.openerService.open(this.extension.repository);
                }
                return this.extensionsWorkbenchService.open(this.extension);
            }
        }
        alert(( localize(
            6285,
            "Updating extension {0} to version {1} started.",
            this.extension.displayName,
            this.extension.latestVersion
        )));
        return this.install(this.extension);
    }
    async install(extension) {
        const options = extension.local?.preRelease ? { installPreReleaseVersion: true } : undefined;
        try {
            await this.extensionsWorkbenchService.install(extension, options);
            alert(( localize(
                6286,
                "Updating extension {0} to version {1} completed.",
                extension.displayName,
                extension.latestVersion
            )));
        }
        catch (err) {
            this.instantiationService.createInstance(PromptExtensionInstallFailureAction, extension, options, extension.latestVersion, InstallOperation.Update, err).run();
        }
    }
};
UpdateAction = UpdateAction_1 = ( __decorate([
    ( __param(1, IExtensionsWorkbenchService)),
    ( __param(2, IDialogService)),
    ( __param(3, IOpenerService)),
    ( __param(4, IInstantiationService))
], UpdateAction));
let ToggleAutoUpdateForExtensionAction = class ToggleAutoUpdateForExtensionAction extends ExtensionAction {
    static { ToggleAutoUpdateForExtensionAction_1 = this; }
    static { this.ID = 'workbench.extensions.action.toggleAutoUpdateForExtension'; }
    static { this.LABEL = ( localize2(6287, "Auto Update")); }
    static { this.EnabledClass = `${ExtensionAction.EXTENSION_ACTION_CLASS} auto-update`; }
    static { this.DisabledClass = `${this.EnabledClass} hide`; }
    constructor(extensionsWorkbenchService, extensionEnablementService, allowedExtensionsService, configurationService) {
        super(ToggleAutoUpdateForExtensionAction_1.ID, ToggleAutoUpdateForExtensionAction_1.LABEL.value, ToggleAutoUpdateForExtensionAction_1.DisabledClass);
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.extensionEnablementService = extensionEnablementService;
        this.allowedExtensionsService = allowedExtensionsService;
        this._register(configurationService.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration(AutoUpdateConfigurationKey)) {
                this.update();
            }
        }));
        this._register(allowedExtensionsService.onDidChangeAllowedExtensionsConfigValue(e => this.update()));
        this.update();
    }
    update() {
        this.enabled = false;
        this.class = ToggleAutoUpdateForExtensionAction_1.DisabledClass;
        if (!this.extension) {
            return;
        }
        if (this.extension.isBuiltin) {
            return;
        }
        if (this.extension.deprecationInfo?.disallowInstall) {
            return;
        }
        const extension = this.extension.local ?? this.extension.gallery;
        if (extension && this.allowedExtensionsService.isAllowed(extension) !== true) {
            return;
        }
        if (this.extensionsWorkbenchService.getAutoUpdateValue() === 'onlyEnabledExtensions' && !this.extensionEnablementService.isEnabledEnablementState(this.extension.enablementState)) {
            return;
        }
        this.enabled = true;
        this.class = ToggleAutoUpdateForExtensionAction_1.EnabledClass;
        this.checked = this.extensionsWorkbenchService.isAutoUpdateEnabledFor(this.extension);
    }
    async run() {
        if (!this.extension) {
            return;
        }
        const enableAutoUpdate = !this.extensionsWorkbenchService.isAutoUpdateEnabledFor(this.extension);
        await this.extensionsWorkbenchService.updateAutoUpdateEnablementFor(this.extension, enableAutoUpdate);
        if (enableAutoUpdate) {
            alert(( localize(6288, "Enabled auto updates for", this.extension.displayName)));
        }
        else {
            alert(( localize(6289, "Disabled auto updates for", this.extension.displayName)));
        }
    }
};
ToggleAutoUpdateForExtensionAction = ToggleAutoUpdateForExtensionAction_1 = ( __decorate([
    ( __param(0, IExtensionsWorkbenchService)),
    ( __param(1, IWorkbenchExtensionEnablementService)),
    ( __param(2, IAllowedExtensionsService)),
    ( __param(3, IConfigurationService))
], ToggleAutoUpdateForExtensionAction));
let ToggleAutoUpdatesForPublisherAction = class ToggleAutoUpdatesForPublisherAction extends ExtensionAction {
    static { ToggleAutoUpdatesForPublisherAction_1 = this; }
    static { this.ID = 'workbench.extensions.action.toggleAutoUpdatesForPublisher'; }
    static { this.LABEL = ( localize(6290, "Auto Update All (From Publisher)")); }
    constructor(extensionsWorkbenchService) {
        super(ToggleAutoUpdatesForPublisherAction_1.ID, ToggleAutoUpdatesForPublisherAction_1.LABEL);
        this.extensionsWorkbenchService = extensionsWorkbenchService;
    }
    update() { }
    async run() {
        if (!this.extension) {
            return;
        }
        alert(( localize(
            6291,
            "Ignoring updates published by {0}.",
            this.extension.publisherDisplayName
        )));
        const enableAutoUpdate = !this.extensionsWorkbenchService.isAutoUpdateEnabledFor(this.extension.publisher);
        await this.extensionsWorkbenchService.updateAutoUpdateEnablementFor(this.extension.publisher, enableAutoUpdate);
        if (enableAutoUpdate) {
            alert(( localize(6288, "Enabled auto updates for", this.extension.displayName)));
        }
        else {
            alert(( localize(6289, "Disabled auto updates for", this.extension.displayName)));
        }
    }
};
ToggleAutoUpdatesForPublisherAction = ToggleAutoUpdatesForPublisherAction_1 = ( __decorate([
    ( __param(0, IExtensionsWorkbenchService))
], ToggleAutoUpdatesForPublisherAction));
let MigrateDeprecatedExtensionAction = class MigrateDeprecatedExtensionAction extends ExtensionAction {
    static { MigrateDeprecatedExtensionAction_1 = this; }
    static { this.EnabledClass = `${ExtensionAction.LABEL_ACTION_CLASS} migrate`; }
    static { this.DisabledClass = `${this.EnabledClass} disabled`; }
    constructor(small, extensionsWorkbenchService) {
        super('extensionsAction.migrateDeprecatedExtension', ( localize(6292, "Migrate")), MigrateDeprecatedExtensionAction_1.DisabledClass, false);
        this.small = small;
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.update();
    }
    update() {
        this.enabled = false;
        this.class = MigrateDeprecatedExtensionAction_1.DisabledClass;
        if (!this.extension?.local) {
            return;
        }
        if (this.extension.state !== ExtensionState.Installed) {
            return;
        }
        if (!this.extension.deprecationInfo?.extension) {
            return;
        }
        const id = this.extension.deprecationInfo.extension.id;
        if (( this.extensionsWorkbenchService.local.some(e => areSameExtensions(e.identifier, { id })))) {
            return;
        }
        this.enabled = true;
        this.class = MigrateDeprecatedExtensionAction_1.EnabledClass;
        this.tooltip = ( localize(
            6293,
            "Migrate to {0}",
            this.extension.deprecationInfo.extension.displayName
        ));
        this.label = this.small ? ( localize(6294, "Migrate")) : this.tooltip;
    }
    async run() {
        if (!this.extension?.deprecationInfo?.extension) {
            return;
        }
        const local = this.extension.local;
        await this.extensionsWorkbenchService.uninstall(this.extension);
        const [extension] = await this.extensionsWorkbenchService.getExtensions([{ id: this.extension.deprecationInfo.extension.id, preRelease: this.extension.deprecationInfo?.extension?.preRelease }], CancellationToken.None);
        await this.extensionsWorkbenchService.install(extension, { isMachineScoped: local?.isMachineScoped });
    }
};
MigrateDeprecatedExtensionAction = MigrateDeprecatedExtensionAction_1 = ( __decorate([
    ( __param(1, IExtensionsWorkbenchService))
], MigrateDeprecatedExtensionAction));
let DropDownExtensionAction = class DropDownExtensionAction extends ExtensionAction {
    constructor(id, label, cssClass, enabled, instantiationService) {
        super(id, label, cssClass, enabled);
        this.instantiationService = instantiationService;
        this._actionViewItem = null;
    }
    createActionViewItem(options) {
        this._actionViewItem = this.instantiationService.createInstance(DropDownExtensionActionViewItem, this, options);
        return this._actionViewItem;
    }
    run(actionGroups) {
        this._actionViewItem?.showMenu(actionGroups);
        return Promise.resolve();
    }
};
DropDownExtensionAction = ( __decorate([
    ( __param(4, IInstantiationService))
], DropDownExtensionAction));
let DropDownExtensionActionViewItem = class DropDownExtensionActionViewItem extends ActionViewItem {
    constructor(action, options, contextMenuService) {
        super(null, action, { ...options, icon: true, label: true });
        this.contextMenuService = contextMenuService;
    }
    showMenu(menuActionGroups) {
        if (this.element) {
            const actions = this.getActions(menuActionGroups);
            const elementPosition = getDomNodePagePosition(this.element);
            const anchor = { x: elementPosition.left, y: elementPosition.top + elementPosition.height + 10 };
            this.contextMenuService.showContextMenu({
                getAnchor: () => anchor,
                getActions: () => actions,
                actionRunner: this.actionRunner,
                onHide: () => disposeIfDisposable(actions)
            });
        }
    }
    getActions(menuActionGroups) {
        let actions = [];
        for (const menuActions of menuActionGroups) {
            actions = [...actions, ...menuActions, ( new Separator())];
        }
        return actions.length ? actions.slice(0, actions.length - 1) : actions;
    }
};
DropDownExtensionActionViewItem = ( __decorate([
    ( __param(2, IContextMenuService))
], DropDownExtensionActionViewItem));
async function getContextMenuActionsGroups(extension, contextKeyService, instantiationService) {
    return instantiationService.invokeFunction(async (accessor) => {
        const extensionsWorkbenchService = accessor.get(IExtensionsWorkbenchService);
        const extensionEnablementService = accessor.get(IWorkbenchExtensionEnablementService);
        const menuService = accessor.get(IMenuService);
        const extensionRecommendationsService = accessor.get(IExtensionRecommendationsService);
        const extensionIgnoredRecommendationsService = accessor.get(IExtensionIgnoredRecommendationsService);
        const workbenchThemeService = accessor.get(IWorkbenchThemeService);
        const authenticationUsageService = accessor.get(IAuthenticationUsageService);
        const allowedExtensionsService = accessor.get(IAllowedExtensionsService);
        const cksOverlay = [];
        if (extension) {
            cksOverlay.push(['extension', extension.identifier.id]);
            cksOverlay.push(['isBuiltinExtension', extension.isBuiltin]);
            cksOverlay.push(['isDefaultApplicationScopedExtension', extension.local && isApplicationScopedExtension(extension.local.manifest)]);
            cksOverlay.push(['isApplicationScopedExtension', extension.local && extension.local.isApplicationScoped]);
            cksOverlay.push(['isWorkspaceScopedExtension', extension.isWorkspaceScoped]);
            cksOverlay.push(['isGalleryExtension', !!extension.identifier.uuid]);
            if (extension.local) {
                cksOverlay.push(['extensionSource', extension.local.source]);
            }
            cksOverlay.push(['extensionHasConfiguration', extension.local && !!extension.local.manifest.contributes && !!extension.local.manifest.contributes.configuration]);
            cksOverlay.push(['extensionHasKeybindings', extension.local && !!extension.local.manifest.contributes && !!extension.local.manifest.contributes.keybindings]);
            cksOverlay.push(['extensionHasCommands', extension.local && !!extension.local.manifest.contributes && !!extension.local.manifest.contributes?.commands]);
            cksOverlay.push(['isExtensionRecommended', !!extensionRecommendationsService.getAllRecommendationsWithReason()[extension.identifier.id.toLowerCase()]]);
            cksOverlay.push(['isExtensionWorkspaceRecommended', extensionRecommendationsService.getAllRecommendationsWithReason()[extension.identifier.id.toLowerCase()]?.reasonId === ExtensionRecommendationReason.Workspace]);
            cksOverlay.push(['isUserIgnoredRecommendation', ( extensionIgnoredRecommendationsService.globalIgnoredRecommendations.some(e => e === extension.identifier.id.toLowerCase()))]);
            cksOverlay.push(['isExtensionPinned', extension.pinned]);
            cksOverlay.push(['isExtensionEnabled', extensionEnablementService.isEnabledEnablementState(extension.enablementState)]);
            switch (extension.state) {
                case ExtensionState.Installing:
                    cksOverlay.push(['extensionStatus', 'installing']);
                    break;
                case ExtensionState.Installed:
                    cksOverlay.push(['extensionStatus', 'installed']);
                    break;
                case ExtensionState.Uninstalling:
                    cksOverlay.push(['extensionStatus', 'uninstalling']);
                    break;
                case ExtensionState.Uninstalled:
                    cksOverlay.push(['extensionStatus', 'uninstalled']);
                    break;
            }
            cksOverlay.push(['installedExtensionIsPreReleaseVersion', !!extension.local?.isPreReleaseVersion]);
            cksOverlay.push(['installedExtensionIsOptedToPreRelease', !!extension.local?.preRelease]);
            cksOverlay.push(['galleryExtensionIsPreReleaseVersion', !!extension.gallery?.properties.isPreReleaseVersion]);
            cksOverlay.push(['galleryExtensionHasPreReleaseVersion', extension.gallery?.hasPreReleaseVersion]);
            cksOverlay.push(['extensionHasPreReleaseVersion', extension.hasPreReleaseVersion]);
            cksOverlay.push(['extensionHasReleaseVersion', extension.hasReleaseVersion]);
            cksOverlay.push(['extensionDisallowInstall', !!extension.deprecationInfo?.disallowInstall]);
            cksOverlay.push(['isExtensionAllowed', allowedExtensionsService.isAllowed({ id: extension.identifier.id, publisherDisplayName: extension.publisherDisplayName }) === true]);
            cksOverlay.push(['isPreReleaseExtensionAllowed', allowedExtensionsService.isAllowed({ id: extension.identifier.id, publisherDisplayName: extension.publisherDisplayName, prerelease: true }) === true]);
            cksOverlay.push(['extensionIsUnsigned', extension.gallery && !extension.gallery.isSigned]);
            const [colorThemes, fileIconThemes, productIconThemes, extensionUsesAuth] = await Promise.all([workbenchThemeService.getColorThemes(), workbenchThemeService.getFileIconThemes(), workbenchThemeService.getProductIconThemes(), authenticationUsageService.extensionUsesAuth(extension.identifier.id.toLowerCase())]);
            cksOverlay.push(['extensionHasColorThemes', ( colorThemes.some(theme => isThemeFromExtension(theme, extension)))]);
            cksOverlay.push(['extensionHasFileIconThemes', ( fileIconThemes.some(theme => isThemeFromExtension(theme, extension)))]);
            cksOverlay.push(['extensionHasProductIconThemes', ( productIconThemes.some(theme => isThemeFromExtension(theme, extension)))]);
            cksOverlay.push(['extensionHasAccountPreferences', extensionUsesAuth]);
            cksOverlay.push(['canSetLanguage', extensionsWorkbenchService.canSetLanguage(extension)]);
            cksOverlay.push(['isActiveLanguagePackExtension', extension.gallery && language === getLocale(extension.gallery)]);
        }
        const actionsGroups = menuService.getMenuActions(MenuId.ExtensionContext, contextKeyService.createOverlay(cksOverlay), { shouldForwardArgs: true });
        return actionsGroups;
    });
}
function toActions(actionsGroups, instantiationService) {
    const result = [];
    for (const [, actions] of actionsGroups) {
        result.push(( actions.map(action => {
            if (action instanceof SubmenuAction) {
                return action;
            }
            return instantiationService.createInstance(MenuItemExtensionAction, action);
        })));
    }
    return result;
}
async function getContextMenuActions(extension, contextKeyService, instantiationService) {
    const actionsGroups = await getContextMenuActionsGroups(extension, contextKeyService, instantiationService);
    return toActions(actionsGroups, instantiationService);
}
let ManageExtensionAction = class ManageExtensionAction extends DropDownExtensionAction {
    static { ManageExtensionAction_1 = this; }
    static { this.ID = 'extensions.manage'; }
    static { this.Class = `${ExtensionAction.ICON_ACTION_CLASS} manage ` + ThemeIcon.asClassName(manageExtensionIcon); }
    static { this.HideManageExtensionClass = `${this.Class} hide`; }
    constructor(instantiationService, extensionService, contextKeyService) {
        super(ManageExtensionAction_1.ID, '', '', true, instantiationService);
        this.extensionService = extensionService;
        this.contextKeyService = contextKeyService;
        this.tooltip = ( localize(6295, "Manage"));
        this.update();
    }
    async getActionGroups() {
        const groups = [];
        const contextMenuActionsGroups = await getContextMenuActionsGroups(this.extension, this.contextKeyService, this.instantiationService);
        const themeActions = [], installActions = [], updateActions = [], otherActionGroups = [];
        for (const [group, actions] of contextMenuActionsGroups) {
            if (group === INSTALL_ACTIONS_GROUP) {
                installActions.push(...toActions([[group, actions]], this.instantiationService)[0]);
            }
            else if (group === UPDATE_ACTIONS_GROUP) {
                updateActions.push(...toActions([[group, actions]], this.instantiationService)[0]);
            }
            else if (group === THEME_ACTIONS_GROUP) {
                themeActions.push(...toActions([[group, actions]], this.instantiationService)[0]);
            }
            else {
                otherActionGroups.push(...toActions([[group, actions]], this.instantiationService));
            }
        }
        if (themeActions.length) {
            groups.push(themeActions);
        }
        groups.push([
            this.instantiationService.createInstance(EnableGloballyAction),
            this.instantiationService.createInstance(EnableForWorkspaceAction)
        ]);
        groups.push([
            this.instantiationService.createInstance(DisableGloballyAction),
            this.instantiationService.createInstance(DisableForWorkspaceAction)
        ]);
        if (updateActions.length) {
            groups.push(updateActions);
        }
        groups.push([
            ...(installActions.length ? installActions : []),
            this.instantiationService.createInstance(InstallAnotherVersionAction, this.extension, false),
            this.instantiationService.createInstance(UninstallAction),
        ]);
        otherActionGroups.forEach(actions => groups.push(actions));
        groups.forEach(group => group.forEach(extensionAction => {
            if (extensionAction instanceof ExtensionAction) {
                extensionAction.extension = this.extension;
            }
        }));
        return groups;
    }
    async run() {
        await this.extensionService.whenInstalledExtensionsRegistered();
        return super.run(await this.getActionGroups());
    }
    update() {
        this.class = ManageExtensionAction_1.HideManageExtensionClass;
        this.enabled = false;
        if (this.extension) {
            const state = this.extension.state;
            this.enabled = state === ExtensionState.Installed;
            this.class = this.enabled || state === ExtensionState.Uninstalling ? ManageExtensionAction_1.Class : ManageExtensionAction_1.HideManageExtensionClass;
        }
    }
};
ManageExtensionAction = ManageExtensionAction_1 = ( __decorate([
    ( __param(0, IInstantiationService)),
    ( __param(1, IExtensionService)),
    ( __param(2, IContextKeyService))
], ManageExtensionAction));
class ExtensionEditorManageExtensionAction extends DropDownExtensionAction {
    constructor(contextKeyService, instantiationService) {
        super('extensionEditor.manageExtension', '', `${ExtensionAction.ICON_ACTION_CLASS} manage ${ThemeIcon.asClassName(manageExtensionIcon)}`, true, instantiationService);
        this.contextKeyService = contextKeyService;
        this.tooltip = ( localize(6295, "Manage"));
    }
    update() { }
    async run() {
        const actionGroups = [];
        (await getContextMenuActions(this.extension, this.contextKeyService, this.instantiationService)).forEach(actions => actionGroups.push(actions));
        actionGroups.forEach(group => group.forEach(extensionAction => {
            if (extensionAction instanceof ExtensionAction) {
                extensionAction.extension = this.extension;
            }
        }));
        return super.run(actionGroups);
    }
}
let MenuItemExtensionAction = class MenuItemExtensionAction extends ExtensionAction {
    constructor(action, extensionsWorkbenchService) {
        super(action.id, action.label);
        this.action = action;
        this.extensionsWorkbenchService = extensionsWorkbenchService;
    }
    get enabled() {
        return this.action.enabled;
    }
    set enabled(value) {
        this.action.enabled = value;
    }
    update() {
        if (!this.extension) {
            return;
        }
        if (this.action.id === TOGGLE_IGNORE_EXTENSION_ACTION_ID) {
            this.checked = !this.extensionsWorkbenchService.isExtensionIgnoredToSync(this.extension);
        }
        else if (this.action.id === ToggleAutoUpdateForExtensionAction.ID) {
            this.checked = this.extensionsWorkbenchService.isAutoUpdateEnabledFor(this.extension);
        }
        else if (this.action.id === ToggleAutoUpdatesForPublisherAction.ID) {
            this.checked = this.extensionsWorkbenchService.isAutoUpdateEnabledFor(this.extension.publisher);
        }
        else {
            this.checked = this.action.checked;
        }
    }
    async run() {
        if (this.extension) {
            const id = this.extension.local ? getExtensionId(this.extension.local.manifest.publisher, this.extension.local.manifest.name)
                : this.extension.gallery ? getExtensionId(this.extension.gallery.publisher, this.extension.gallery.name)
                    : this.extension.identifier.id;
            const extensionArg = {
                id: this.extension.identifier.id,
                version: this.extension.version,
                location: this.extension.local?.location
            };
            await this.action.run(id, extensionArg);
        }
    }
};
MenuItemExtensionAction = ( __decorate([
    ( __param(1, IExtensionsWorkbenchService))
], MenuItemExtensionAction));
let TogglePreReleaseExtensionAction = class TogglePreReleaseExtensionAction extends ExtensionAction {
    static { TogglePreReleaseExtensionAction_1 = this; }
    static { this.ID = 'workbench.extensions.action.togglePreRlease'; }
    static { this.LABEL = ( localize(6296, "Pre-Release")); }
    static { this.EnabledClass = `${ExtensionAction.LABEL_ACTION_CLASS} pre-release`; }
    static { this.DisabledClass = `${this.EnabledClass} hide`; }
    constructor(extensionsWorkbenchService, allowedExtensionsService) {
        super(TogglePreReleaseExtensionAction_1.ID, TogglePreReleaseExtensionAction_1.LABEL, TogglePreReleaseExtensionAction_1.DisabledClass);
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.allowedExtensionsService = allowedExtensionsService;
        this._register(allowedExtensionsService.onDidChangeAllowedExtensionsConfigValue(() => this.update()));
        this.update();
    }
    update() {
        this.enabled = false;
        this.class = TogglePreReleaseExtensionAction_1.DisabledClass;
        if (!this.extension) {
            return;
        }
        if (this.extension.isBuiltin) {
            return;
        }
        if (this.extension.state !== ExtensionState.Installed) {
            return;
        }
        if (!this.extension.hasPreReleaseVersion) {
            return;
        }
        if (!this.extension.gallery) {
            return;
        }
        if (this.extension.preRelease) {
            if (!this.extension.isPreReleaseVersion) {
                return;
            }
            if (this.allowedExtensionsService.isAllowed({ id: this.extension.identifier.id, publisherDisplayName: this.extension.publisherDisplayName }) !== true) {
                return;
            }
        }
        if (!this.extension.preRelease) {
            if (!this.extension.gallery.hasPreReleaseVersion) {
                return;
            }
            if (this.allowedExtensionsService.isAllowed(this.extension.gallery) !== true) {
                return;
            }
        }
        this.enabled = true;
        this.class = TogglePreReleaseExtensionAction_1.EnabledClass;
        if (this.extension.preRelease) {
            this.label = ( localize(6297, "Switch to Release Version"));
            this.tooltip = ( localize(6298, "This will switch and enable updates to release versions"));
        }
        else {
            this.label = ( localize(6299, "Switch to Pre-Release Version"));
            this.tooltip = ( localize(
                6300,
                "This will switch to pre-release version and enable updates to latest version always"
            ));
        }
    }
    async run() {
        if (!this.extension) {
            return;
        }
        this.extensionsWorkbenchService.open(this.extension, { showPreReleaseVersion: !this.extension.preRelease });
        await this.extensionsWorkbenchService.togglePreRelease(this.extension);
    }
};
TogglePreReleaseExtensionAction = TogglePreReleaseExtensionAction_1 = ( __decorate([
    ( __param(0, IExtensionsWorkbenchService)),
    ( __param(1, IAllowedExtensionsService))
], TogglePreReleaseExtensionAction));
let InstallAnotherVersionAction = class InstallAnotherVersionAction extends ExtensionAction {
    static { InstallAnotherVersionAction_1 = this; }
    static { this.ID = 'workbench.extensions.action.install.anotherVersion'; }
    static { this.LABEL = ( localize(6301, "Install Specific Version...")); }
    constructor(extension, whenInstalled, extensionsWorkbenchService, extensionManagementService, extensionGalleryService, quickInputService, instantiationService, dialogService, allowedExtensionsService) {
        super(InstallAnotherVersionAction_1.ID, InstallAnotherVersionAction_1.LABEL, ExtensionAction.LABEL_ACTION_CLASS);
        this.whenInstalled = whenInstalled;
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.extensionManagementService = extensionManagementService;
        this.extensionGalleryService = extensionGalleryService;
        this.quickInputService = quickInputService;
        this.instantiationService = instantiationService;
        this.dialogService = dialogService;
        this.allowedExtensionsService = allowedExtensionsService;
        this._register(allowedExtensionsService.onDidChangeAllowedExtensionsConfigValue(() => this.update()));
        this.extension = extension;
        this.update();
    }
    update() {
        this.enabled = !!this.extension && !this.extension.isBuiltin && !!this.extension.identifier.uuid && !this.extension.deprecationInfo
            && this.allowedExtensionsService.isAllowed({ id: this.extension.identifier.id, publisherDisplayName: this.extension.publisherDisplayName }) === true;
        if (this.enabled && this.whenInstalled) {
            this.enabled = !!this.extension?.local && !!this.extension.server && this.extension.state === ExtensionState.Installed;
        }
    }
    async run() {
        if (!this.enabled) {
            return;
        }
        if (!this.extension) {
            return;
        }
        const targetPlatform = this.extension.server ? await this.extension.server.extensionManagementService.getTargetPlatform() : await this.extensionManagementService.getTargetPlatform();
        const allVersions = await this.extensionGalleryService.getAllCompatibleVersions(this.extension.identifier, this.extension.local?.preRelease ?? this.extension.gallery?.properties.isPreReleaseVersion ?? false, targetPlatform);
        if (!allVersions.length) {
            await this.dialogService.info(( localize(6302, "This extension has no other versions.")));
            return;
        }
        const picks = ( allVersions.map((v, i) => {
            return {
                id: v.version,
                label: v.version,
                description: `${fromNow(( new Date(Date.parse(v.date))), true)}${v.isPreReleaseVersion ? ` (${( localize(6303, "pre-release"))})` : ''}${v.version === this.extension?.local?.manifest.version ? ` (${( localize(6304, "current"))})` : ''}`,
                ariaLabel: `${v.isPreReleaseVersion ? 'Pre-Release version' : 'Release version'} ${v.version}`,
                isPreReleaseVersion: v.isPreReleaseVersion
            };
        }));
        const pick = await this.quickInputService.pick(picks, {
            placeHolder: ( localize(6305, "Select Version to Install")),
            matchOnDetail: true
        });
        if (pick) {
            if (this.extension.local?.manifest.version === pick.id) {
                return;
            }
            const options = { installPreReleaseVersion: pick.isPreReleaseVersion, version: pick.id };
            try {
                await this.extensionsWorkbenchService.install(this.extension, options);
            }
            catch (error) {
                this.instantiationService.createInstance(PromptExtensionInstallFailureAction, this.extension, options, pick.id, InstallOperation.Install, error).run();
            }
        }
        return null;
    }
};
InstallAnotherVersionAction = InstallAnotherVersionAction_1 = ( __decorate([
    ( __param(2, IExtensionsWorkbenchService)),
    ( __param(3, IWorkbenchExtensionManagementService)),
    ( __param(4, IExtensionGalleryService)),
    ( __param(5, IQuickInputService)),
    ( __param(6, IInstantiationService)),
    ( __param(7, IDialogService)),
    ( __param(8, IAllowedExtensionsService))
], InstallAnotherVersionAction));
let EnableForWorkspaceAction = class EnableForWorkspaceAction extends ExtensionAction {
    static { EnableForWorkspaceAction_1 = this; }
    static { this.ID = 'extensions.enableForWorkspace'; }
    static { this.LABEL = ( localize(6306, "Enable (Workspace)")); }
    constructor(extensionsWorkbenchService, extensionEnablementService) {
        super(EnableForWorkspaceAction_1.ID, EnableForWorkspaceAction_1.LABEL, ExtensionAction.LABEL_ACTION_CLASS);
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.extensionEnablementService = extensionEnablementService;
        this.tooltip = ( localize(6307, "Enable this extension only in this workspace"));
        this.update();
    }
    update() {
        this.enabled = false;
        if (this.extension && this.extension.local && !this.extension.isWorkspaceScoped) {
            this.enabled = this.extension.state === ExtensionState.Installed
                && !this.extensionEnablementService.isEnabled(this.extension.local)
                && this.extensionEnablementService.canChangeWorkspaceEnablement(this.extension.local);
        }
    }
    async run() {
        if (!this.extension) {
            return;
        }
        return this.extensionsWorkbenchService.setEnablement(this.extension, EnablementState.EnabledWorkspace);
    }
};
EnableForWorkspaceAction = EnableForWorkspaceAction_1 = ( __decorate([
    ( __param(0, IExtensionsWorkbenchService)),
    ( __param(1, IWorkbenchExtensionEnablementService))
], EnableForWorkspaceAction));
let EnableGloballyAction = class EnableGloballyAction extends ExtensionAction {
    static { EnableGloballyAction_1 = this; }
    static { this.ID = 'extensions.enableGlobally'; }
    static { this.LABEL = ( localize(6308, "Enable")); }
    constructor(extensionsWorkbenchService, extensionEnablementService) {
        super(EnableGloballyAction_1.ID, EnableGloballyAction_1.LABEL, ExtensionAction.LABEL_ACTION_CLASS);
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.extensionEnablementService = extensionEnablementService;
        this.tooltip = ( localize(6309, "Enable this extension"));
        this.update();
    }
    update() {
        this.enabled = false;
        if (this.extension && this.extension.local && !this.extension.isWorkspaceScoped) {
            this.enabled = this.extension.state === ExtensionState.Installed
                && this.extensionEnablementService.isDisabledGlobally(this.extension.local)
                && this.extensionEnablementService.canChangeEnablement(this.extension.local);
        }
    }
    async run() {
        if (!this.extension) {
            return;
        }
        return this.extensionsWorkbenchService.setEnablement(this.extension, EnablementState.EnabledGlobally);
    }
};
EnableGloballyAction = EnableGloballyAction_1 = ( __decorate([
    ( __param(0, IExtensionsWorkbenchService)),
    ( __param(1, IWorkbenchExtensionEnablementService))
], EnableGloballyAction));
let DisableForWorkspaceAction = class DisableForWorkspaceAction extends ExtensionAction {
    static { DisableForWorkspaceAction_1 = this; }
    static { this.ID = 'extensions.disableForWorkspace'; }
    static { this.LABEL = ( localize(6310, "Disable (Workspace)")); }
    constructor(workspaceContextService, extensionsWorkbenchService, extensionEnablementService, extensionService) {
        super(DisableForWorkspaceAction_1.ID, DisableForWorkspaceAction_1.LABEL, ExtensionAction.LABEL_ACTION_CLASS);
        this.workspaceContextService = workspaceContextService;
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.extensionEnablementService = extensionEnablementService;
        this.extensionService = extensionService;
        this.tooltip = ( localize(6311, "Disable this extension only in this workspace"));
        this.update();
        this._register(this.extensionService.onDidChangeExtensions(() => this.update()));
    }
    update() {
        this.enabled = false;
        if (this.extension && this.extension.local && !this.extension.isWorkspaceScoped && ( this.extensionService.extensions.some(
            e => areSameExtensions({ id: e.identifier.value, uuid: e.uuid }, this.extension.identifier) && this.workspaceContextService.getWorkbenchState() !== WorkbenchState.EMPTY
        ))) {
            this.enabled = this.extension.state === ExtensionState.Installed
                && (this.extension.enablementState === EnablementState.EnabledGlobally || this.extension.enablementState === EnablementState.EnabledWorkspace)
                && this.extensionEnablementService.canChangeWorkspaceEnablement(this.extension.local);
        }
    }
    async run() {
        if (!this.extension) {
            return;
        }
        return this.extensionsWorkbenchService.setEnablement(this.extension, EnablementState.DisabledWorkspace);
    }
};
DisableForWorkspaceAction = DisableForWorkspaceAction_1 = ( __decorate([
    ( __param(0, IWorkspaceContextService)),
    ( __param(1, IExtensionsWorkbenchService)),
    ( __param(2, IWorkbenchExtensionEnablementService)),
    ( __param(3, IExtensionService))
], DisableForWorkspaceAction));
let DisableGloballyAction = class DisableGloballyAction extends ExtensionAction {
    static { DisableGloballyAction_1 = this; }
    static { this.ID = 'extensions.disableGlobally'; }
    static { this.LABEL = ( localize(6312, "Disable")); }
    constructor(extensionsWorkbenchService, extensionEnablementService, extensionService) {
        super(DisableGloballyAction_1.ID, DisableGloballyAction_1.LABEL, ExtensionAction.LABEL_ACTION_CLASS);
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.extensionEnablementService = extensionEnablementService;
        this.extensionService = extensionService;
        this.tooltip = ( localize(6313, "Disable this extension"));
        this.update();
        this._register(this.extensionService.onDidChangeExtensions(() => this.update()));
    }
    update() {
        this.enabled = false;
        if (this.extension && this.extension.local && !this.extension.isWorkspaceScoped && ( this.extensionService.extensions.some(
            e => areSameExtensions({ id: e.identifier.value, uuid: e.uuid }, this.extension.identifier)
        ))) {
            this.enabled = this.extension.state === ExtensionState.Installed
                && (this.extension.enablementState === EnablementState.EnabledGlobally || this.extension.enablementState === EnablementState.EnabledWorkspace)
                && this.extensionEnablementService.canChangeEnablement(this.extension.local);
        }
    }
    async run() {
        if (!this.extension) {
            return;
        }
        return this.extensionsWorkbenchService.setEnablement(this.extension, EnablementState.DisabledGlobally);
    }
};
DisableGloballyAction = DisableGloballyAction_1 = ( __decorate([
    ( __param(0, IExtensionsWorkbenchService)),
    ( __param(1, IWorkbenchExtensionEnablementService)),
    ( __param(2, IExtensionService))
], DisableGloballyAction));
let EnableDropDownAction = class EnableDropDownAction extends ButtonWithDropDownExtensionAction {
    constructor(instantiationService) {
        super('extensions.enable', ExtensionAction.LABEL_ACTION_CLASS, [
            [
                instantiationService.createInstance(EnableGloballyAction),
                instantiationService.createInstance(EnableForWorkspaceAction)
            ]
        ]);
    }
};
EnableDropDownAction = ( __decorate([
    ( __param(0, IInstantiationService))
], EnableDropDownAction));
let DisableDropDownAction = class DisableDropDownAction extends ButtonWithDropDownExtensionAction {
    constructor(instantiationService) {
        super('extensions.disable', ExtensionAction.LABEL_ACTION_CLASS, [[
                instantiationService.createInstance(DisableGloballyAction),
                instantiationService.createInstance(DisableForWorkspaceAction)
            ]]);
    }
};
DisableDropDownAction = ( __decorate([
    ( __param(0, IInstantiationService))
], DisableDropDownAction));
let ExtensionRuntimeStateAction = class ExtensionRuntimeStateAction extends ExtensionAction {
    static { ExtensionRuntimeStateAction_1 = this; }
    static { this.EnabledClass = `${ExtensionAction.LABEL_ACTION_CLASS} reload`; }
    static { this.DisabledClass = `${this.EnabledClass} disabled`; }
    constructor(hostService, extensionsWorkbenchService, updateService, extensionService, productService, telemetryService) {
        super('extensions.runtimeState', '', ExtensionRuntimeStateAction_1.DisabledClass, false);
        this.hostService = hostService;
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.updateService = updateService;
        this.extensionService = extensionService;
        this.productService = productService;
        this.telemetryService = telemetryService;
        this.updateWhenCounterExtensionChanges = true;
        this._register(this.extensionService.onDidChangeExtensions(() => this.update()));
        this.update();
    }
    update() {
        this.enabled = false;
        this.tooltip = '';
        this.class = ExtensionRuntimeStateAction_1.DisabledClass;
        if (!this.extension) {
            return;
        }
        const state = this.extension.state;
        if (state === ExtensionState.Installing || state === ExtensionState.Uninstalling) {
            return;
        }
        if (this.extension.local && this.extension.local.manifest && this.extension.local.manifest.contributes && this.extension.local.manifest.contributes.localizations && this.extension.local.manifest.contributes.localizations.length > 0) {
            return;
        }
        const runtimeState = this.extension.runtimeState;
        if (!runtimeState) {
            return;
        }
        this.enabled = true;
        this.class = ExtensionRuntimeStateAction_1.EnabledClass;
        this.tooltip = runtimeState.reason;
        this.label = runtimeState.action === ExtensionRuntimeActionType.ReloadWindow ? ( localize(6314, 'Reload Window'))
            : runtimeState.action === ExtensionRuntimeActionType.RestartExtensions ? ( localize(6315, 'Restart Extensions'))
                : runtimeState.action === ExtensionRuntimeActionType.QuitAndInstall ? ( localize(6316, 'Restart to Update'))
                    : runtimeState.action === ExtensionRuntimeActionType.ApplyUpdate || runtimeState.action === ExtensionRuntimeActionType.DownloadUpdate ? ( localize(6317, 'Update {0}', this.productService.nameShort)) : '';
    }
    async run() {
        const runtimeState = this.extension?.runtimeState;
        if (!runtimeState?.action) {
            return;
        }
        this.telemetryService.publicLog2('extensions:runtimestate:action', {
            action: runtimeState.action
        });
        if (runtimeState?.action === ExtensionRuntimeActionType.ReloadWindow) {
            return this.hostService.reload();
        }
        else if (runtimeState?.action === ExtensionRuntimeActionType.RestartExtensions) {
            return this.extensionsWorkbenchService.updateRunningExtensions();
        }
        else if (runtimeState?.action === ExtensionRuntimeActionType.DownloadUpdate) {
            return this.updateService.downloadUpdate();
        }
        else if (runtimeState?.action === ExtensionRuntimeActionType.ApplyUpdate) {
            return this.updateService.applyUpdate();
        }
        else if (runtimeState?.action === ExtensionRuntimeActionType.QuitAndInstall) {
            return this.updateService.quitAndInstall();
        }
    }
};
ExtensionRuntimeStateAction = ExtensionRuntimeStateAction_1 = ( __decorate([
    ( __param(0, IHostService)),
    ( __param(1, IExtensionsWorkbenchService)),
    ( __param(2, IUpdateService)),
    ( __param(3, IExtensionService)),
    ( __param(4, IProductService)),
    ( __param(5, ITelemetryService))
], ExtensionRuntimeStateAction));
function isThemeFromExtension(theme, extension) {
    return !!(extension && theme.extensionData && ExtensionIdentifier.equals(theme.extensionData.extensionId, extension.identifier.id));
}
function getQuickPickEntries(themes, currentTheme, extension, showCurrentTheme) {
    const picks = [];
    for (const theme of themes) {
        if (isThemeFromExtension(theme, extension) && !(showCurrentTheme && theme === currentTheme)) {
            picks.push({ label: theme.label, id: theme.id });
        }
    }
    if (showCurrentTheme) {
        picks.push({ type: 'separator', label: ( localize(6304, "current")) });
        picks.push({ label: currentTheme.label, id: currentTheme.id });
    }
    return picks;
}
let SetColorThemeAction = class SetColorThemeAction extends ExtensionAction {
    static { SetColorThemeAction_1 = this; }
    static { this.ID = 'workbench.extensions.action.setColorTheme'; }
    static { this.TITLE = ( localize2(6318, 'Set Color Theme')); }
    static { this.EnabledClass = `${ExtensionAction.LABEL_ACTION_CLASS} theme`; }
    static { this.DisabledClass = `${this.EnabledClass} disabled`; }
    constructor(extensionService, workbenchThemeService, quickInputService, extensionEnablementService) {
        super(SetColorThemeAction_1.ID, SetColorThemeAction_1.TITLE.value, SetColorThemeAction_1.DisabledClass, false);
        this.workbenchThemeService = workbenchThemeService;
        this.quickInputService = quickInputService;
        this.extensionEnablementService = extensionEnablementService;
        this._register(Event.any(extensionService.onDidChangeExtensions, workbenchThemeService.onDidColorThemeChange)(() => this.update(), this));
        this.update();
    }
    update() {
        this.workbenchThemeService.getColorThemes().then(colorThemes => {
            this.enabled = this.computeEnablement(colorThemes);
            this.class = this.enabled ? SetColorThemeAction_1.EnabledClass : SetColorThemeAction_1.DisabledClass;
        });
    }
    computeEnablement(colorThemes) {
        return !!this.extension && this.extension.state === ExtensionState.Installed && this.extensionEnablementService.isEnabledEnablementState(this.extension.enablementState) && ( colorThemes.some(th => isThemeFromExtension(th, this.extension)));
    }
    async run({ showCurrentTheme, ignoreFocusLost } = { showCurrentTheme: false, ignoreFocusLost: false }) {
        const colorThemes = await this.workbenchThemeService.getColorThemes();
        if (!this.computeEnablement(colorThemes)) {
            return;
        }
        const currentTheme = this.workbenchThemeService.getColorTheme();
        const delayer = ( new Delayer(100));
        const picks = getQuickPickEntries(colorThemes, currentTheme, this.extension, showCurrentTheme);
        const pickedTheme = await this.quickInputService.pick(picks, {
            placeHolder: ( localize(6319, "Select Color Theme")),
            onDidFocus: item => delayer.trigger(() => this.workbenchThemeService.setColorTheme(item.id, undefined)),
            ignoreFocusLost
        });
        return this.workbenchThemeService.setColorTheme(pickedTheme ? pickedTheme.id : currentTheme.id, 'auto');
    }
};
SetColorThemeAction = SetColorThemeAction_1 = ( __decorate([
    ( __param(0, IExtensionService)),
    ( __param(1, IWorkbenchThemeService)),
    ( __param(2, IQuickInputService)),
    ( __param(3, IWorkbenchExtensionEnablementService))
], SetColorThemeAction));
let SetFileIconThemeAction = class SetFileIconThemeAction extends ExtensionAction {
    static { SetFileIconThemeAction_1 = this; }
    static { this.ID = 'workbench.extensions.action.setFileIconTheme'; }
    static { this.TITLE = ( localize2(6320, 'Set File Icon Theme')); }
    static { this.EnabledClass = `${ExtensionAction.LABEL_ACTION_CLASS} theme`; }
    static { this.DisabledClass = `${this.EnabledClass} disabled`; }
    constructor(extensionService, workbenchThemeService, quickInputService, extensionEnablementService) {
        super(SetFileIconThemeAction_1.ID, SetFileIconThemeAction_1.TITLE.value, SetFileIconThemeAction_1.DisabledClass, false);
        this.workbenchThemeService = workbenchThemeService;
        this.quickInputService = quickInputService;
        this.extensionEnablementService = extensionEnablementService;
        this._register(Event.any(extensionService.onDidChangeExtensions, workbenchThemeService.onDidFileIconThemeChange)(() => this.update(), this));
        this.update();
    }
    update() {
        this.workbenchThemeService.getFileIconThemes().then(fileIconThemes => {
            this.enabled = this.computeEnablement(fileIconThemes);
            this.class = this.enabled ? SetFileIconThemeAction_1.EnabledClass : SetFileIconThemeAction_1.DisabledClass;
        });
    }
    computeEnablement(colorThemfileIconThemess) {
        return !!this.extension && this.extension.state === ExtensionState.Installed && this.extensionEnablementService.isEnabledEnablementState(this.extension.enablementState) && ( colorThemfileIconThemess.some(th => isThemeFromExtension(th, this.extension)));
    }
    async run({ showCurrentTheme, ignoreFocusLost } = { showCurrentTheme: false, ignoreFocusLost: false }) {
        const fileIconThemes = await this.workbenchThemeService.getFileIconThemes();
        if (!this.computeEnablement(fileIconThemes)) {
            return;
        }
        const currentTheme = this.workbenchThemeService.getFileIconTheme();
        const delayer = ( new Delayer(100));
        const picks = getQuickPickEntries(fileIconThemes, currentTheme, this.extension, showCurrentTheme);
        const pickedTheme = await this.quickInputService.pick(picks, {
            placeHolder: ( localize(6321, "Select File Icon Theme")),
            onDidFocus: item => delayer.trigger(() => this.workbenchThemeService.setFileIconTheme(item.id, undefined)),
            ignoreFocusLost
        });
        return this.workbenchThemeService.setFileIconTheme(pickedTheme ? pickedTheme.id : currentTheme.id, 'auto');
    }
};
SetFileIconThemeAction = SetFileIconThemeAction_1 = ( __decorate([
    ( __param(0, IExtensionService)),
    ( __param(1, IWorkbenchThemeService)),
    ( __param(2, IQuickInputService)),
    ( __param(3, IWorkbenchExtensionEnablementService))
], SetFileIconThemeAction));
let SetProductIconThemeAction = class SetProductIconThemeAction extends ExtensionAction {
    static { SetProductIconThemeAction_1 = this; }
    static { this.ID = 'workbench.extensions.action.setProductIconTheme'; }
    static { this.TITLE = ( localize2(6322, 'Set Product Icon Theme')); }
    static { this.EnabledClass = `${ExtensionAction.LABEL_ACTION_CLASS} theme`; }
    static { this.DisabledClass = `${this.EnabledClass} disabled`; }
    constructor(extensionService, workbenchThemeService, quickInputService, extensionEnablementService) {
        super(SetProductIconThemeAction_1.ID, SetProductIconThemeAction_1.TITLE.value, SetProductIconThemeAction_1.DisabledClass, false);
        this.workbenchThemeService = workbenchThemeService;
        this.quickInputService = quickInputService;
        this.extensionEnablementService = extensionEnablementService;
        this._register(Event.any(extensionService.onDidChangeExtensions, workbenchThemeService.onDidProductIconThemeChange)(() => this.update(), this));
        this.update();
    }
    update() {
        this.workbenchThemeService.getProductIconThemes().then(productIconThemes => {
            this.enabled = this.computeEnablement(productIconThemes);
            this.class = this.enabled ? SetProductIconThemeAction_1.EnabledClass : SetProductIconThemeAction_1.DisabledClass;
        });
    }
    computeEnablement(productIconThemes) {
        return !!this.extension && this.extension.state === ExtensionState.Installed && this.extensionEnablementService.isEnabledEnablementState(this.extension.enablementState) && ( productIconThemes.some(th => isThemeFromExtension(th, this.extension)));
    }
    async run({ showCurrentTheme, ignoreFocusLost } = { showCurrentTheme: false, ignoreFocusLost: false }) {
        const productIconThemes = await this.workbenchThemeService.getProductIconThemes();
        if (!this.computeEnablement(productIconThemes)) {
            return;
        }
        const currentTheme = this.workbenchThemeService.getProductIconTheme();
        const delayer = ( new Delayer(100));
        const picks = getQuickPickEntries(productIconThemes, currentTheme, this.extension, showCurrentTheme);
        const pickedTheme = await this.quickInputService.pick(picks, {
            placeHolder: ( localize(6323, "Select Product Icon Theme")),
            onDidFocus: item => delayer.trigger(() => this.workbenchThemeService.setProductIconTheme(item.id, undefined)),
            ignoreFocusLost
        });
        return this.workbenchThemeService.setProductIconTheme(pickedTheme ? pickedTheme.id : currentTheme.id, 'auto');
    }
};
SetProductIconThemeAction = SetProductIconThemeAction_1 = ( __decorate([
    ( __param(0, IExtensionService)),
    ( __param(1, IWorkbenchThemeService)),
    ( __param(2, IQuickInputService)),
    ( __param(3, IWorkbenchExtensionEnablementService))
], SetProductIconThemeAction));
let SetLanguageAction = class SetLanguageAction extends ExtensionAction {
    static { SetLanguageAction_1 = this; }
    static { this.ID = 'workbench.extensions.action.setDisplayLanguage'; }
    static { this.TITLE = ( localize2(6324, 'Set Display Language')); }
    static { this.EnabledClass = `${ExtensionAction.LABEL_ACTION_CLASS} language`; }
    static { this.DisabledClass = `${this.EnabledClass} disabled`; }
    constructor(extensionsWorkbenchService) {
        super(SetLanguageAction_1.ID, SetLanguageAction_1.TITLE.value, SetLanguageAction_1.DisabledClass, false);
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.update();
    }
    update() {
        this.enabled = false;
        this.class = SetLanguageAction_1.DisabledClass;
        if (!this.extension) {
            return;
        }
        if (!this.extensionsWorkbenchService.canSetLanguage(this.extension)) {
            return;
        }
        if (this.extension.gallery && language === getLocale(this.extension.gallery)) {
            return;
        }
        this.enabled = true;
        this.class = SetLanguageAction_1.EnabledClass;
    }
    async run() {
        return this.extension && this.extensionsWorkbenchService.setLanguage(this.extension);
    }
};
SetLanguageAction = SetLanguageAction_1 = ( __decorate([
    ( __param(0, IExtensionsWorkbenchService))
], SetLanguageAction));
let ClearLanguageAction = class ClearLanguageAction extends ExtensionAction {
    static { ClearLanguageAction_1 = this; }
    static { this.ID = 'workbench.extensions.action.clearLanguage'; }
    static { this.TITLE = ( localize2(6325, 'Clear Display Language')); }
    static { this.EnabledClass = `${ExtensionAction.LABEL_ACTION_CLASS} language`; }
    static { this.DisabledClass = `${this.EnabledClass} disabled`; }
    constructor(extensionsWorkbenchService, localeService) {
        super(ClearLanguageAction_1.ID, ClearLanguageAction_1.TITLE.value, ClearLanguageAction_1.DisabledClass, false);
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.localeService = localeService;
        this.update();
    }
    update() {
        this.enabled = false;
        this.class = ClearLanguageAction_1.DisabledClass;
        if (!this.extension) {
            return;
        }
        if (!this.extensionsWorkbenchService.canSetLanguage(this.extension)) {
            return;
        }
        if (this.extension.gallery && language !== getLocale(this.extension.gallery)) {
            return;
        }
        this.enabled = true;
        this.class = ClearLanguageAction_1.EnabledClass;
    }
    async run() {
        return this.extension && this.localeService.clearLocalePreference();
    }
};
ClearLanguageAction = ClearLanguageAction_1 = ( __decorate([
    ( __param(0, IExtensionsWorkbenchService)),
    ( __param(1, ILocaleService))
], ClearLanguageAction));
let ShowRecommendedExtensionAction = class ShowRecommendedExtensionAction extends Action {
    static { ShowRecommendedExtensionAction_1 = this; }
    static { this.ID = 'workbench.extensions.action.showRecommendedExtension'; }
    static { this.LABEL = ( localize(6326, "Show Recommended Extension")); }
    constructor(extensionId, extensionWorkbenchService) {
        super(ShowRecommendedExtensionAction_1.ID, ShowRecommendedExtensionAction_1.LABEL, undefined, false);
        this.extensionWorkbenchService = extensionWorkbenchService;
        this.extensionId = extensionId;
    }
    async run() {
        await this.extensionWorkbenchService.openSearch(`@id:${this.extensionId}`);
        const [extension] = await this.extensionWorkbenchService.getExtensions([{ id: this.extensionId }], { source: 'install-recommendation' }, CancellationToken.None);
        if (extension) {
            return this.extensionWorkbenchService.open(extension);
        }
        return null;
    }
};
ShowRecommendedExtensionAction = ShowRecommendedExtensionAction_1 = ( __decorate([
    ( __param(1, IExtensionsWorkbenchService))
], ShowRecommendedExtensionAction));
let InstallRecommendedExtensionAction = class InstallRecommendedExtensionAction extends Action {
    static { InstallRecommendedExtensionAction_1 = this; }
    static { this.ID = 'workbench.extensions.action.installRecommendedExtension'; }
    static { this.LABEL = ( localize(6327, "Install Recommended Extension")); }
    constructor(extensionId, instantiationService, extensionWorkbenchService) {
        super(InstallRecommendedExtensionAction_1.ID, InstallRecommendedExtensionAction_1.LABEL, undefined, false);
        this.instantiationService = instantiationService;
        this.extensionWorkbenchService = extensionWorkbenchService;
        this.extensionId = extensionId;
    }
    async run() {
        await this.extensionWorkbenchService.openSearch(`@id:${this.extensionId}`);
        const [extension] = await this.extensionWorkbenchService.getExtensions([{ id: this.extensionId }], { source: 'install-recommendation' }, CancellationToken.None);
        if (extension) {
            await this.extensionWorkbenchService.open(extension);
            try {
                await this.extensionWorkbenchService.install(extension);
            }
            catch (err) {
                this.instantiationService.createInstance(PromptExtensionInstallFailureAction, extension, undefined, extension.latestVersion, InstallOperation.Install, err).run();
            }
        }
    }
};
InstallRecommendedExtensionAction = InstallRecommendedExtensionAction_1 = ( __decorate([
    ( __param(1, IInstantiationService)),
    ( __param(2, IExtensionsWorkbenchService))
], InstallRecommendedExtensionAction));
let IgnoreExtensionRecommendationAction = class IgnoreExtensionRecommendationAction extends Action {
    static { IgnoreExtensionRecommendationAction_1 = this; }
    static { this.ID = 'extensions.ignore'; }
    static { this.Class = `${ExtensionAction.LABEL_ACTION_CLASS} ignore`; }
    constructor(extension, extensionRecommendationsManagementService) {
        super(IgnoreExtensionRecommendationAction_1.ID, 'Ignore Recommendation');
        this.extension = extension;
        this.extensionRecommendationsManagementService = extensionRecommendationsManagementService;
        this.class = IgnoreExtensionRecommendationAction_1.Class;
        this.tooltip = ( localize(6328, "Do not recommend this extension again"));
        this.enabled = true;
    }
    run() {
        this.extensionRecommendationsManagementService.toggleGlobalIgnoredRecommendation(this.extension.identifier.id, true);
        return Promise.resolve();
    }
};
IgnoreExtensionRecommendationAction = IgnoreExtensionRecommendationAction_1 = ( __decorate([
    ( __param(1, IExtensionIgnoredRecommendationsService))
], IgnoreExtensionRecommendationAction));
let UndoIgnoreExtensionRecommendationAction = class UndoIgnoreExtensionRecommendationAction extends Action {
    static { UndoIgnoreExtensionRecommendationAction_1 = this; }
    static { this.ID = 'extensions.ignore'; }
    static { this.Class = `${ExtensionAction.LABEL_ACTION_CLASS} undo-ignore`; }
    constructor(extension, extensionRecommendationsManagementService) {
        super(UndoIgnoreExtensionRecommendationAction_1.ID, 'Undo');
        this.extension = extension;
        this.extensionRecommendationsManagementService = extensionRecommendationsManagementService;
        this.class = UndoIgnoreExtensionRecommendationAction_1.Class;
        this.tooltip = ( localize(6329, "Undo"));
        this.enabled = true;
    }
    run() {
        this.extensionRecommendationsManagementService.toggleGlobalIgnoredRecommendation(this.extension.identifier.id, false);
        return Promise.resolve();
    }
};
UndoIgnoreExtensionRecommendationAction = UndoIgnoreExtensionRecommendationAction_1 = ( __decorate([
    ( __param(1, IExtensionIgnoredRecommendationsService))
], UndoIgnoreExtensionRecommendationAction));
let AbstractConfigureRecommendedExtensionsAction = class AbstractConfigureRecommendedExtensionsAction extends Action {
    constructor(id, label, contextService, fileService, textFileService, editorService, jsonEditingService, textModelResolverService) {
        super(id, label);
        this.contextService = contextService;
        this.fileService = fileService;
        this.textFileService = textFileService;
        this.editorService = editorService;
        this.jsonEditingService = jsonEditingService;
        this.textModelResolverService = textModelResolverService;
    }
    openExtensionsFile(extensionsFileResource) {
        return this.getOrCreateExtensionsFile(extensionsFileResource)
            .then(({ created, content }) => this.getSelectionPosition(content, extensionsFileResource, ['recommendations'])
            .then(selection => this.editorService.openEditor({
            resource: extensionsFileResource,
            options: {
                pinned: created,
                selection
            }
        })), error => Promise.reject(( new Error(( localize(
            6330,
            "Unable to create 'extensions.json' file inside the '.vscode' folder ({0}).",
            error
        ))))));
    }
    openWorkspaceConfigurationFile(workspaceConfigurationFile) {
        return this.getOrUpdateWorkspaceConfigurationFile(workspaceConfigurationFile)
            .then(content => this.getSelectionPosition(( content.value.toString()), content.resource, ['extensions', 'recommendations']))
            .then(selection => this.editorService.openEditor({
            resource: workspaceConfigurationFile,
            options: {
                selection,
                forceReload: true
            }
        }));
    }
    getOrUpdateWorkspaceConfigurationFile(workspaceConfigurationFile) {
        return Promise.resolve(this.fileService.readFile(workspaceConfigurationFile))
            .then(content => {
            const workspaceRecommendations = parse(( content.value.toString()))['extensions'];
            if (!workspaceRecommendations || !workspaceRecommendations.recommendations) {
                return this.jsonEditingService.write(workspaceConfigurationFile, [{ path: ['extensions'], value: { recommendations: [] } }], true)
                    .then(() => this.fileService.readFile(workspaceConfigurationFile));
            }
            return content;
        });
    }
    getSelectionPosition(content, resource, path) {
        const tree = parseTree(content);
        const node = findNodeAtLocation(tree, path);
        if (node && node.parent && node.parent.children) {
            const recommendationsValueNode = node.parent.children[1];
            const lastExtensionNode = recommendationsValueNode.children && recommendationsValueNode.children.length ? recommendationsValueNode.children[recommendationsValueNode.children.length - 1] : null;
            const offset = lastExtensionNode ? lastExtensionNode.offset + lastExtensionNode.length : recommendationsValueNode.offset + 1;
            return Promise.resolve(this.textModelResolverService.createModelReference(resource))
                .then(reference => {
                const position = reference.object.textEditorModel.getPositionAt(offset);
                reference.dispose();
                return {
                    startLineNumber: position.lineNumber,
                    startColumn: position.column,
                    endLineNumber: position.lineNumber,
                    endColumn: position.column,
                };
            });
        }
        return Promise.resolve(undefined);
    }
    getOrCreateExtensionsFile(extensionsFileResource) {
        return Promise.resolve(this.fileService.readFile(extensionsFileResource)).then(content => {
            return { created: false, extensionsFileResource, content: ( content.value.toString()) };
        }, err => {
            return this.textFileService.write(extensionsFileResource, ExtensionsConfigurationInitialContent).then(() => {
                return { created: true, extensionsFileResource, content: ExtensionsConfigurationInitialContent };
            });
        });
    }
};
AbstractConfigureRecommendedExtensionsAction = ( __decorate([
    ( __param(2, IWorkspaceContextService)),
    ( __param(3, IFileService)),
    ( __param(4, ITextFileService)),
    ( __param(5, IEditorService)),
    ( __param(6, IJSONEditingService)),
    ( __param(7, ITextModelService))
], AbstractConfigureRecommendedExtensionsAction));
let ConfigureWorkspaceRecommendedExtensionsAction = class ConfigureWorkspaceRecommendedExtensionsAction extends AbstractConfigureRecommendedExtensionsAction {
    static { this.ID = 'workbench.extensions.action.configureWorkspaceRecommendedExtensions'; }
    static { this.LABEL = ( localize(6331, "Configure Recommended Extensions (Workspace)")); }
    constructor(id, label, fileService, textFileService, contextService, editorService, jsonEditingService, textModelResolverService) {
        super(id, label, contextService, fileService, textFileService, editorService, jsonEditingService, textModelResolverService);
        this._register(this.contextService.onDidChangeWorkbenchState(() => this.update(), this));
        this.update();
    }
    update() {
        this.enabled = this.contextService.getWorkbenchState() !== WorkbenchState.EMPTY;
    }
    run() {
        switch (this.contextService.getWorkbenchState()) {
            case WorkbenchState.FOLDER:
                return this.openExtensionsFile(this.contextService.getWorkspace().folders[0].toResource(EXTENSIONS_CONFIG));
            case WorkbenchState.WORKSPACE:
                return this.openWorkspaceConfigurationFile(this.contextService.getWorkspace().configuration);
        }
        return Promise.resolve();
    }
};
ConfigureWorkspaceRecommendedExtensionsAction = ( __decorate([
    ( __param(2, IFileService)),
    ( __param(3, ITextFileService)),
    ( __param(4, IWorkspaceContextService)),
    ( __param(5, IEditorService)),
    ( __param(6, IJSONEditingService)),
    ( __param(7, ITextModelService))
], ConfigureWorkspaceRecommendedExtensionsAction));
let ConfigureWorkspaceFolderRecommendedExtensionsAction = class ConfigureWorkspaceFolderRecommendedExtensionsAction extends AbstractConfigureRecommendedExtensionsAction {
    static { this.ID = 'workbench.extensions.action.configureWorkspaceFolderRecommendedExtensions'; }
    static { this.LABEL = ( localize(6332, "Configure Recommended Extensions (Workspace Folder)")); }
    constructor(id, label, fileService, textFileService, contextService, editorService, jsonEditingService, textModelResolverService, commandService) {
        super(id, label, contextService, fileService, textFileService, editorService, jsonEditingService, textModelResolverService);
        this.commandService = commandService;
    }
    run() {
        const folderCount = this.contextService.getWorkspace().folders.length;
        const pickFolderPromise = folderCount === 1 ? Promise.resolve(this.contextService.getWorkspace().folders[0]) : this.commandService.executeCommand(PICK_WORKSPACE_FOLDER_COMMAND_ID);
        return Promise.resolve(pickFolderPromise)
            .then(workspaceFolder => {
            if (workspaceFolder) {
                return this.openExtensionsFile(workspaceFolder.toResource(EXTENSIONS_CONFIG));
            }
            return null;
        });
    }
};
ConfigureWorkspaceFolderRecommendedExtensionsAction = ( __decorate([
    ( __param(2, IFileService)),
    ( __param(3, ITextFileService)),
    ( __param(4, IWorkspaceContextService)),
    ( __param(5, IEditorService)),
    ( __param(6, IJSONEditingService)),
    ( __param(7, ITextModelService)),
    ( __param(8, ICommandService))
], ConfigureWorkspaceFolderRecommendedExtensionsAction));
let ExtensionStatusLabelAction = class ExtensionStatusLabelAction extends Action {
    static { ExtensionStatusLabelAction_1 = this; }
    static { this.ENABLED_CLASS = `${ExtensionAction.TEXT_ACTION_CLASS} extension-status-label`; }
    static { this.DISABLED_CLASS = `${this.ENABLED_CLASS} hide`; }
    get extension() { return this._extension; }
    set extension(extension) {
        if (!(this._extension && extension && areSameExtensions(this._extension.identifier, extension.identifier))) {
            this.initialStatus = null;
            this.status = null;
            this.enablementState = null;
        }
        this._extension = extension;
        this.update();
    }
    constructor(extensionService, extensionManagementServerService, extensionEnablementService) {
        super('extensions.action.statusLabel', '', ExtensionStatusLabelAction_1.DISABLED_CLASS, false);
        this.extensionService = extensionService;
        this.extensionManagementServerService = extensionManagementServerService;
        this.extensionEnablementService = extensionEnablementService;
        this.initialStatus = null;
        this.status = null;
        this.version = null;
        this.enablementState = null;
        this._extension = null;
    }
    update() {
        const label = this.computeLabel();
        this.label = label || '';
        this.class = label ? ExtensionStatusLabelAction_1.ENABLED_CLASS : ExtensionStatusLabelAction_1.DISABLED_CLASS;
    }
    computeLabel() {
        if (!this.extension) {
            return null;
        }
        const currentStatus = this.status;
        const currentVersion = this.version;
        const currentEnablementState = this.enablementState;
        this.status = this.extension.state;
        this.version = this.extension.version;
        if (this.initialStatus === null) {
            this.initialStatus = this.status;
        }
        this.enablementState = this.extension.enablementState;
        const canAddExtension = () => {
            const runningExtension = this.extensionService.extensions.filter(e => areSameExtensions({ id: e.identifier.value, uuid: e.uuid }, this.extension.identifier))[0];
            if (this.extension.local) {
                if (runningExtension && this.extension.version === runningExtension.version) {
                    return true;
                }
                return this.extensionService.canAddExtension(toExtensionDescription(this.extension.local));
            }
            return false;
        };
        const canRemoveExtension = () => {
            if (this.extension.local) {
                if (this.extensionService.extensions.every(e => !(areSameExtensions({ id: e.identifier.value, uuid: e.uuid }, this.extension.identifier) && this.extension.server === this.extensionManagementServerService.getExtensionManagementServer(toExtension(e))))) {
                    return true;
                }
                return this.extensionService.canRemoveExtension(toExtensionDescription(this.extension.local));
            }
            return false;
        };
        if (currentStatus !== null) {
            if (currentStatus === ExtensionState.Installing && this.status === ExtensionState.Installed) {
                if (this.initialStatus === ExtensionState.Uninstalled && canAddExtension()) {
                    return localize(6333, "Installed");
                }
                if (this.initialStatus === ExtensionState.Installed && this.version !== currentVersion && canAddExtension()) {
                    return localize(6334, "Updated");
                }
                return null;
            }
            if (currentStatus === ExtensionState.Uninstalling && this.status === ExtensionState.Uninstalled) {
                this.initialStatus = this.status;
                return canRemoveExtension() ? ( localize(6335, "Uninstalled")) : null;
            }
        }
        if (currentEnablementState !== null) {
            const currentlyEnabled = this.extensionEnablementService.isEnabledEnablementState(currentEnablementState);
            const enabled = this.extensionEnablementService.isEnabledEnablementState(this.enablementState);
            if (!currentlyEnabled && enabled) {
                return canAddExtension() ? ( localize(6336, "Enabled")) : null;
            }
            if (currentlyEnabled && !enabled) {
                return canRemoveExtension() ? ( localize(6337, "Disabled")) : null;
            }
        }
        return null;
    }
    run() {
        return Promise.resolve();
    }
};
ExtensionStatusLabelAction = ExtensionStatusLabelAction_1 = ( __decorate([
    ( __param(0, IExtensionService)),
    ( __param(1, IExtensionManagementServerService)),
    ( __param(2, IWorkbenchExtensionEnablementService))
], ExtensionStatusLabelAction));
let ToggleSyncExtensionAction = class ToggleSyncExtensionAction extends DropDownExtensionAction {
    static { ToggleSyncExtensionAction_1 = this; }
    static { this.IGNORED_SYNC_CLASS = `${ExtensionAction.ICON_ACTION_CLASS} extension-sync ${ThemeIcon.asClassName(syncIgnoredIcon)}`; }
    static { this.SYNC_CLASS = `${this.ICON_ACTION_CLASS} extension-sync ${ThemeIcon.asClassName(syncEnabledIcon)}`; }
    constructor(configurationService, extensionsWorkbenchService, userDataSyncEnablementService, instantiationService) {
        super('extensions.sync', '', ToggleSyncExtensionAction_1.SYNC_CLASS, false, instantiationService);
        this.configurationService = configurationService;
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.userDataSyncEnablementService = userDataSyncEnablementService;
        this._register(Event.filter(this.configurationService.onDidChangeConfiguration, e => e.affectsConfiguration('settingsSync.ignoredExtensions'))(() => this.update()));
        this._register(userDataSyncEnablementService.onDidChangeEnablement(() => this.update()));
        this.update();
    }
    update() {
        this.enabled = !!this.extension && this.userDataSyncEnablementService.isEnabled() && this.extension.state === ExtensionState.Installed;
        if (this.extension) {
            const isIgnored = this.extensionsWorkbenchService.isExtensionIgnoredToSync(this.extension);
            this.class = isIgnored ? ToggleSyncExtensionAction_1.IGNORED_SYNC_CLASS : ToggleSyncExtensionAction_1.SYNC_CLASS;
            this.tooltip = isIgnored ? ( localize(6338, "This extension is ignored during sync")) : ( localize(6339, "This extension is synced"));
        }
    }
    async run() {
        return super.run([
            [
                ( new Action(
                    'extensions.syncignore',
                    this.extensionsWorkbenchService.isExtensionIgnoredToSync(this.extension) ? ( localize(6340, "Sync this extension")) : ( localize(6341, "Do not sync this extension")),
                    undefined,
                    true,
                    () => this.extensionsWorkbenchService.toggleExtensionIgnoredToSync(this.extension)
                ))
            ]
        ]);
    }
};
ToggleSyncExtensionAction = ToggleSyncExtensionAction_1 = ( __decorate([
    ( __param(0, IConfigurationService)),
    ( __param(1, IExtensionsWorkbenchService)),
    ( __param(2, IUserDataSyncEnablementService)),
    ( __param(3, IInstantiationService))
], ToggleSyncExtensionAction));
let ExtensionStatusAction = class ExtensionStatusAction extends ExtensionAction {
    static { ExtensionStatusAction_1 = this; }
    static { this.CLASS = `${ExtensionAction.ICON_ACTION_CLASS} extension-status`; }
    get status() { return this._status; }
    constructor(extensionManagementServerService, labelService, commandService, workspaceTrustEnablementService, workspaceTrustService, extensionsWorkbenchService, extensionService, extensionManifestPropertiesService, contextService, productService, allowedExtensionsService, workbenchExtensionEnablementService, extensionFeaturesManagementService) {
        super('extensions.status', '', `${ExtensionStatusAction_1.CLASS} hide`, false);
        this.extensionManagementServerService = extensionManagementServerService;
        this.labelService = labelService;
        this.commandService = commandService;
        this.workspaceTrustEnablementService = workspaceTrustEnablementService;
        this.workspaceTrustService = workspaceTrustService;
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.extensionService = extensionService;
        this.extensionManifestPropertiesService = extensionManifestPropertiesService;
        this.contextService = contextService;
        this.productService = productService;
        this.allowedExtensionsService = allowedExtensionsService;
        this.workbenchExtensionEnablementService = workbenchExtensionEnablementService;
        this.extensionFeaturesManagementService = extensionFeaturesManagementService;
        this.updateWhenCounterExtensionChanges = true;
        this._status = [];
        this._onDidChangeStatus = this._register(( new Emitter()));
        this.onDidChangeStatus = this._onDidChangeStatus.event;
        this.updateThrottler = ( new Throttler());
        this._register(this.labelService.onDidChangeFormatters(() => this.update(), this));
        this._register(this.extensionService.onDidChangeExtensions(() => this.update()));
        this._register(this.extensionFeaturesManagementService.onDidChangeAccessData(() => this.update()));
        this._register(allowedExtensionsService.onDidChangeAllowedExtensionsConfigValue(() => this.update()));
        this.update();
    }
    update() {
        this.updateThrottler.queue(() => this.computeAndUpdateStatus());
    }
    async computeAndUpdateStatus() {
        this.updateStatus(undefined, true);
        this.enabled = false;
        if (!this.extension) {
            return;
        }
        if (this.extension.isMalicious) {
            this.updateStatus({ icon: warningIcon, message: ( new MarkdownString(( localize(6342, "This extension was reported to be problematic.")))) }, true);
            return;
        }
        if (this.extension.state === ExtensionState.Uninstalled && this.extension.gallery && !this.extension.gallery.isSigned) {
            this.updateStatus({ icon: warningIcon, message: ( new MarkdownString(( localize(6343, "This extension is not signed by the Extension Marketplace.")))) }, true);
            return;
        }
        if (this.extension.deprecationInfo) {
            if (this.extension.deprecationInfo.extension) {
                const link = `[${this.extension.deprecationInfo.extension.displayName}](${( URI.parse(
                    `command:extension.open?${encodeURIComponent(JSON.stringify([this.extension.deprecationInfo.extension.id]))}`
                ))})`;
                this.updateStatus({ icon: warningIcon, message: ( new MarkdownString(( localize(6344, "This extension is deprecated. Use the {0} extension instead.", link)))) }, true);
            }
            else if (this.extension.deprecationInfo.settings) {
                const link = `[${( localize(6345, "settings"))}](${( URI.parse(
                    `command:workbench.action.openSettings?${encodeURIComponent(JSON.stringify([( this.extension.deprecationInfo.settings.map(setting => `@id:${setting}`)).join(' ')]))}`
                ))})`;
                this.updateStatus({ icon: warningIcon, message: ( new MarkdownString(( localize(
                    6346,
                    "This extension is deprecated as this functionality is now built-in to VS Code. Configure these {0} to use this functionality.",
                    link
                )))) }, true);
            }
            else {
                const message = ( new MarkdownString(( localize(6347, "This extension is deprecated as it is no longer being maintained."))));
                if (this.extension.deprecationInfo.additionalInfo) {
                    message.appendMarkdown(` ${this.extension.deprecationInfo.additionalInfo}`);
                }
                this.updateStatus({ icon: warningIcon, message }, true);
            }
            return;
        }
        if (this.extensionsWorkbenchService.canSetLanguage(this.extension)) {
            return;
        }
        if (this.extension.outdated && this.extensionsWorkbenchService.isAutoUpdateEnabledFor(this.extension)) {
            const message = await this.extensionsWorkbenchService.shouldRequireConsentToUpdate(this.extension);
            if (message) {
                const markdown = ( new MarkdownString());
                markdown.appendMarkdown(`${message} `);
                markdown.appendMarkdown(( localize(
                    6348,
                    "Please [review the extension]({0}) and update it manually.",
                    this.extension.hasChangelog()
                        ? ( ( URI.parse(
                        `command:extension.open?${encodeURIComponent(JSON.stringify([this.extension.identifier.id, ExtensionEditorTab.Changelog]))}`
                    )).toString())
                        : this.extension.repository
                            ? this.extension.repository
                            : ( ( URI.parse(
                        `command:extension.open?${encodeURIComponent(JSON.stringify([this.extension.identifier.id]))}`
                    )).toString())
                )));
                this.updateStatus({ icon: warningIcon, message: markdown }, true);
            }
        }
        if (this.extension.gallery && this.extension.state === ExtensionState.Uninstalled) {
            const result = await this.extensionsWorkbenchService.canInstall(this.extension);
            if (result !== true) {
                this.updateStatus({ icon: warningIcon, message: result }, true);
                return;
            }
        }
        if (!this.extension.local ||
            !this.extension.server ||
            this.extension.state !== ExtensionState.Installed) {
            return;
        }
        const result = this.allowedExtensionsService.isAllowed(this.extension.local);
        if (result !== true) {
            this.updateStatus({ icon: warningIcon, message: ( new MarkdownString(( localize(6349, "This extension is disabled because {0}", result.value)))) }, true);
            return;
        }
        if (this.extension.enablementState === EnablementState.DisabledByEnvironment) {
            this.updateStatus({ message: ( new MarkdownString(( localize(6350, "This extension is disabled by the environment.")))) }, true);
            return;
        }
        if (this.extension.enablementState === EnablementState.EnabledByEnvironment) {
            this.updateStatus({ message: ( new MarkdownString(( localize(
                6351,
                "This extension is enabled because it is required in the current environment."
            )))) }, true);
            return;
        }
        if (this.extension.enablementState === EnablementState.DisabledByVirtualWorkspace) {
            const details = getWorkspaceSupportTypeMessage(this.extension.local.manifest.capabilities?.virtualWorkspaces);
            this.updateStatus({ icon: infoIcon, message: ( new MarkdownString(details ? escapeMarkdownSyntaxTokens(details) : ( localize(
                6352,
                "This extension has been disabled because it does not support virtual workspaces."
            )))) }, true);
            return;
        }
        if (isVirtualWorkspace(this.contextService.getWorkspace())) {
            const virtualSupportType = this.extensionManifestPropertiesService.getExtensionVirtualWorkspaceSupportType(this.extension.local.manifest);
            const details = getWorkspaceSupportTypeMessage(this.extension.local.manifest.capabilities?.virtualWorkspaces);
            if (virtualSupportType === 'limited' || details) {
                this.updateStatus({ icon: warningIcon, message: ( new MarkdownString(details ? escapeMarkdownSyntaxTokens(details) : ( localize(
                    6353,
                    "This extension has limited features because the current workspace is virtual."
                )))) }, true);
                return;
            }
        }
        if (!this.workspaceTrustService.isWorkspaceTrusted() &&
            (this.extension.enablementState === EnablementState.DisabledByTrustRequirement ||
                (this.extension.enablementState === EnablementState.DisabledByExtensionDependency && this.workbenchExtensionEnablementService.getDependenciesEnablementStates(this.extension.local).every(([, enablementState]) => this.workbenchExtensionEnablementService.isEnabledEnablementState(enablementState) || enablementState === EnablementState.DisabledByTrustRequirement)))) {
            this.enabled = true;
            const untrustedDetails = getWorkspaceSupportTypeMessage(this.extension.local.manifest.capabilities?.untrustedWorkspaces);
            this.updateStatus({ icon: trustIcon, message: ( new MarkdownString(
                untrustedDetails ? escapeMarkdownSyntaxTokens(untrustedDetails) : ( localize(
                    6354,
                    "This extension has been disabled because the current workspace is not trusted."
                ))
            )) }, true);
            return;
        }
        if (this.workspaceTrustEnablementService.isWorkspaceTrustEnabled() && !this.workspaceTrustService.isWorkspaceTrusted()) {
            const untrustedSupportType = this.extensionManifestPropertiesService.getExtensionUntrustedWorkspaceSupportType(this.extension.local.manifest);
            const untrustedDetails = getWorkspaceSupportTypeMessage(this.extension.local.manifest.capabilities?.untrustedWorkspaces);
            if (untrustedSupportType === 'limited' || untrustedDetails) {
                this.enabled = true;
                this.updateStatus({ icon: trustIcon, message: ( new MarkdownString(
                    untrustedDetails ? escapeMarkdownSyntaxTokens(untrustedDetails) : ( localize(
                        6355,
                        "This extension has limited features because the current workspace is not trusted."
                    ))
                )) }, true);
                return;
            }
        }
        if (this.extension.enablementState === EnablementState.DisabledByExtensionKind) {
            if (!( this.extensionsWorkbenchService.installed.some(
                e => areSameExtensions(e.identifier, this.extension.identifier) && e.server !== this.extension.server
            ))) {
                let message;
                if (this.extensionManagementServerService.localExtensionManagementServer === this.extension.server) {
                    if (this.extensionManifestPropertiesService.prefersExecuteOnWorkspace(this.extension.local.manifest)) {
                        if (this.extensionManagementServerService.remoteExtensionManagementServer) {
                            message = ( new MarkdownString(`${( localize(
                                6356,
                                "This extension is disabled in this workspace because it is defined to run in the Remote Extension Host. Please install the extension in '{0}' to enable.",
                                this.extensionManagementServerService.remoteExtensionManagementServer.label
                            ))} [${( localize(6250, "Learn More"))}](https://code.visualstudio.com/api/advanced-topics/remote-extensions#architecture-and-extension-kinds)`));
                        }
                    }
                }
                else if (this.extensionManagementServerService.remoteExtensionManagementServer === this.extension.server) {
                    if (this.extensionManifestPropertiesService.prefersExecuteOnUI(this.extension.local.manifest)) {
                        if (this.extensionManagementServerService.localExtensionManagementServer) {
                            message = ( new MarkdownString(`${( localize(
                                6357,
                                "This extension is disabled in this workspace because it is defined to run in the Local Extension Host. Please install the extension locally to enable.",
                                this.extensionManagementServerService.remoteExtensionManagementServer.label
                            ))} [${( localize(6250, "Learn More"))}](https://code.visualstudio.com/api/advanced-topics/remote-extensions#architecture-and-extension-kinds)`));
                        }
                        else if (isWeb) {
                            message = ( new MarkdownString(`${( localize(
                                6358,
                                "This extension is disabled because it is defined to run only in {0} for the Desktop.",
                                this.productService.nameLong
                            ))} [${( localize(6250, "Learn More"))}](https://code.visualstudio.com/api/advanced-topics/remote-extensions#architecture-and-extension-kinds)`));
                        }
                    }
                }
                else if (this.extensionManagementServerService.webExtensionManagementServer === this.extension.server) {
                    message = ( new MarkdownString(`${( localize(
                        6359,
                        "This extension is disabled because it is not supported in {0} for the Web.",
                        this.productService.nameLong
                    ))} [${( localize(6250, "Learn More"))}](https://code.visualstudio.com/api/advanced-topics/remote-extensions#architecture-and-extension-kinds)`));
                }
                if (message) {
                    this.updateStatus({ icon: warningIcon, message }, true);
                }
                return;
            }
        }
        const extensionId = ( new ExtensionIdentifier(this.extension.identifier.id));
        const features = ( Registry.as(Extensions.ExtensionFeaturesRegistry)).getExtensionFeatures();
        for (const feature of features) {
            const status = this.extensionFeaturesManagementService.getAccessData(extensionId, feature.id)?.current?.status;
            const manageAccessLink = `[${( localize(6360, 'Manage Access'))}](${( URI.parse(
                `command:extension.open?${encodeURIComponent(JSON.stringify([this.extension.identifier.id, ExtensionEditorTab.Features, false, feature.id]))}`
            ))})`;
            if (status?.severity === Severity.Error) {
                this.updateStatus({ icon: errorIcon, message: ( new MarkdownString()).appendText(status.message).appendMarkdown(` ${manageAccessLink}`) }, true);
                return;
            }
            if (status?.severity === Severity.Warning) {
                this.updateStatus({ icon: warningIcon, message: ( new MarkdownString()).appendText(status.message).appendMarkdown(` ${manageAccessLink}`) }, true);
                return;
            }
        }
        if (this.extensionManagementServerService.remoteExtensionManagementServer) {
            if (isLanguagePackExtension(this.extension.local.manifest)) {
                if (!( this.extensionsWorkbenchService.installed.some(
                    e => areSameExtensions(e.identifier, this.extension.identifier) && e.server !== this.extension.server
                ))) {
                    const message = this.extension.server === this.extensionManagementServerService.localExtensionManagementServer
                        ? ( new MarkdownString(( localize(
                        6361,
                        "Install the language pack extension on '{0}' to enable it there also.",
                        this.extensionManagementServerService.remoteExtensionManagementServer.label
                    ))))
                        : ( new MarkdownString(( localize(
                        6362,
                        "Install the language pack extension locally to enable it there also."
                    ))));
                    this.updateStatus({ icon: infoIcon, message }, true);
                }
                return;
            }
            const runningExtension = this.extensionService.extensions.filter(e => areSameExtensions({ id: e.identifier.value, uuid: e.uuid }, this.extension.identifier))[0];
            const runningExtensionServer = runningExtension ? this.extensionManagementServerService.getExtensionManagementServer(toExtension(runningExtension)) : null;
            if (this.extension.server === this.extensionManagementServerService.localExtensionManagementServer && runningExtensionServer === this.extensionManagementServerService.remoteExtensionManagementServer) {
                if (this.extensionManifestPropertiesService.prefersExecuteOnWorkspace(this.extension.local.manifest)) {
                    this.updateStatus({ icon: infoIcon, message: ( new MarkdownString(`${( localize(
                        6363,
                        "This extension is enabled in the Remote Extension Host because it prefers to run there."
                    ))} [${( localize(6250, "Learn More"))}](https://code.visualstudio.com/api/advanced-topics/remote-extensions#architecture-and-extension-kinds)`)) }, true);
                }
                return;
            }
            if (this.extension.server === this.extensionManagementServerService.remoteExtensionManagementServer && runningExtensionServer === this.extensionManagementServerService.localExtensionManagementServer) {
                if (this.extensionManifestPropertiesService.prefersExecuteOnUI(this.extension.local.manifest)) {
                    this.updateStatus({ icon: infoIcon, message: ( new MarkdownString(`${( localize(
                        6364,
                        "This extension is enabled in the Local Extension Host because it prefers to run there."
                    ))} [${( localize(6250, "Learn More"))}](https://code.visualstudio.com/api/advanced-topics/remote-extensions#architecture-and-extension-kinds)`)) }, true);
                }
                return;
            }
            if (this.extension.server === this.extensionManagementServerService.remoteExtensionManagementServer && runningExtensionServer === this.extensionManagementServerService.webExtensionManagementServer) {
                if (this.extensionManifestPropertiesService.canExecuteOnWeb(this.extension.local.manifest)) {
                    this.updateStatus({ icon: infoIcon, message: ( new MarkdownString(`${( localize(
                        6365,
                        "This extension is enabled in the Web Worker Extension Host because it prefers to run there."
                    ))} [${( localize(6250, "Learn More"))}](https://code.visualstudio.com/api/advanced-topics/remote-extensions#architecture-and-extension-kinds)`)) }, true);
                }
                return;
            }
        }
        if (this.extension.enablementState === EnablementState.DisabledByExtensionDependency) {
            this.updateStatus({
                icon: warningIcon,
                message: ( new MarkdownString(( localize(6366, "This extension depends on an extension that is disabled."))))
                    .appendMarkdown(`&nbsp;[${( localize(6367, "Show Dependencies"))}](${( URI.parse(
                    `command:extension.open?${encodeURIComponent(JSON.stringify([this.extension.identifier.id, ExtensionEditorTab.Dependencies]))}`
                ))})`)
            }, true);
            return;
        }
        if (!this.extension.local.isValid) {
            const errors = ( this.extension.local.validations.filter(([severity]) => severity === Severity.Error).map(([, message]) => message));
            this.updateStatus({ icon: warningIcon, message: ( new MarkdownString(errors.join(' ').trim())) }, true);
            return;
        }
        const isEnabled = this.workbenchExtensionEnablementService.isEnabled(this.extension.local);
        const isRunning = ( this.extensionService.extensions.some(
            e => areSameExtensions({ id: e.identifier.value, uuid: e.uuid }, this.extension.identifier)
        ));
        if (!this.extension.isWorkspaceScoped && isEnabled && isRunning) {
            if (this.extension.enablementState === EnablementState.EnabledWorkspace) {
                this.updateStatus({ message: ( new MarkdownString(( localize(6368, "This extension is enabled for this workspace by the user.")))) }, true);
                return;
            }
            if (this.extensionManagementServerService.localExtensionManagementServer && this.extensionManagementServerService.remoteExtensionManagementServer) {
                if (this.extension.server === this.extensionManagementServerService.remoteExtensionManagementServer) {
                    this.updateStatus({ message: ( new MarkdownString(( localize(6369, "Extension is enabled on '{0}'", this.extension.server.label)))) }, true);
                    return;
                }
            }
            if (this.extension.enablementState === EnablementState.EnabledGlobally) {
                return;
            }
        }
        if (!isEnabled && !isRunning) {
            if (this.extension.enablementState === EnablementState.DisabledGlobally) {
                this.updateStatus({ message: ( new MarkdownString(( localize(6370, "This extension is disabled globally by the user.")))) }, true);
                return;
            }
            if (this.extension.enablementState === EnablementState.DisabledWorkspace) {
                this.updateStatus({ message: ( new MarkdownString(( localize(6371, "This extension is disabled for this workspace by the user.")))) }, true);
                return;
            }
        }
    }
    updateStatus(status, updateClass) {
        if (status) {
            if (( this._status.some(
                s => s.message.value === status.message.value && s.icon?.id === status.icon?.id
            ))) {
                return;
            }
        }
        else {
            if (this._status.length === 0) {
                return;
            }
            this._status = [];
        }
        if (status) {
            this._status.push(status);
            this._status.sort((a, b) => b.icon === trustIcon ? -1 :
                a.icon === trustIcon ? 1 :
                    b.icon === errorIcon ? -1 :
                        a.icon === errorIcon ? 1 :
                            b.icon === warningIcon ? -1 :
                                a.icon === warningIcon ? 1 :
                                    b.icon === infoIcon ? -1 :
                                        a.icon === infoIcon ? 1 :
                                            0);
        }
        if (updateClass) {
            if (status?.icon === errorIcon) {
                this.class = `${ExtensionStatusAction_1.CLASS} extension-status-error ${ThemeIcon.asClassName(errorIcon)}`;
            }
            else if (status?.icon === warningIcon) {
                this.class = `${ExtensionStatusAction_1.CLASS} extension-status-warning ${ThemeIcon.asClassName(warningIcon)}`;
            }
            else if (status?.icon === infoIcon) {
                this.class = `${ExtensionStatusAction_1.CLASS} extension-status-info ${ThemeIcon.asClassName(infoIcon)}`;
            }
            else if (status?.icon === trustIcon) {
                this.class = `${ExtensionStatusAction_1.CLASS} ${ThemeIcon.asClassName(trustIcon)}`;
            }
            else {
                this.class = `${ExtensionStatusAction_1.CLASS} hide`;
            }
        }
        this._onDidChangeStatus.fire();
    }
    async run() {
        if (this._status[0]?.icon === trustIcon) {
            return this.commandService.executeCommand('workbench.trust.manage');
        }
    }
};
ExtensionStatusAction = ExtensionStatusAction_1 = ( __decorate([
    ( __param(0, IExtensionManagementServerService)),
    ( __param(1, ILabelService)),
    ( __param(2, ICommandService)),
    ( __param(3, IWorkspaceTrustEnablementService)),
    ( __param(4, IWorkspaceTrustManagementService)),
    ( __param(5, IExtensionsWorkbenchService)),
    ( __param(6, IExtensionService)),
    ( __param(7, IExtensionManifestPropertiesService)),
    ( __param(8, IWorkspaceContextService)),
    ( __param(9, IProductService)),
    ( __param(10, IAllowedExtensionsService)),
    ( __param(11, IWorkbenchExtensionEnablementService)),
    ( __param(12, IExtensionFeaturesManagementService))
], ExtensionStatusAction));
let InstallSpecificVersionOfExtensionAction = class InstallSpecificVersionOfExtensionAction extends Action {
    static { InstallSpecificVersionOfExtensionAction_1 = this; }
    static { this.ID = 'workbench.extensions.action.install.specificVersion'; }
    static { this.LABEL = ( localize(6372, "Install Specific Version of Extension...")); }
    constructor(id = InstallSpecificVersionOfExtensionAction_1.ID, label = InstallSpecificVersionOfExtensionAction_1.LABEL, extensionsWorkbenchService, quickInputService, instantiationService, extensionEnablementService) {
        super(id, label);
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.quickInputService = quickInputService;
        this.instantiationService = instantiationService;
        this.extensionEnablementService = extensionEnablementService;
    }
    get enabled() {
        return ( this.extensionsWorkbenchService.local.some(l => this.isEnabled(l)));
    }
    async run() {
        const extensionPick = await this.quickInputService.pick(this.getExtensionEntries(), { placeHolder: ( localize(6373, "Select Extension")), matchOnDetail: true });
        if (extensionPick && extensionPick.extension) {
            const action = this.instantiationService.createInstance(InstallAnotherVersionAction, extensionPick.extension, true);
            await action.run();
            await this.extensionsWorkbenchService.openSearch(extensionPick.extension.identifier.id);
        }
    }
    isEnabled(extension) {
        const action = this.instantiationService.createInstance(InstallAnotherVersionAction, extension, true);
        return action.enabled && !!extension.local && this.extensionEnablementService.isEnabled(extension.local);
    }
    async getExtensionEntries() {
        const installed = await this.extensionsWorkbenchService.queryLocal();
        const entries = [];
        for (const extension of installed) {
            if (this.isEnabled(extension)) {
                entries.push({
                    id: extension.identifier.id,
                    label: extension.displayName || extension.identifier.id,
                    description: extension.identifier.id,
                    extension,
                });
            }
        }
        return entries.sort((e1, e2) => e1.extension.displayName.localeCompare(e2.extension.displayName));
    }
};
InstallSpecificVersionOfExtensionAction = InstallSpecificVersionOfExtensionAction_1 = ( __decorate([
    ( __param(2, IExtensionsWorkbenchService)),
    ( __param(3, IQuickInputService)),
    ( __param(4, IInstantiationService)),
    ( __param(5, IWorkbenchExtensionEnablementService))
], InstallSpecificVersionOfExtensionAction));
let AbstractInstallExtensionsInServerAction = class AbstractInstallExtensionsInServerAction extends Action {
    constructor(id, extensionsWorkbenchService, quickInputService, notificationService, progressService) {
        super(id);
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.quickInputService = quickInputService;
        this.notificationService = notificationService;
        this.progressService = progressService;
        this.extensions = undefined;
        this.update();
        this.extensionsWorkbenchService.queryLocal().then(() => this.updateExtensions());
        this._register(this.extensionsWorkbenchService.onChange(() => {
            if (this.extensions) {
                this.updateExtensions();
            }
        }));
    }
    updateExtensions() {
        this.extensions = this.extensionsWorkbenchService.local;
        this.update();
    }
    update() {
        this.enabled = !!this.extensions && this.getExtensionsToInstall(this.extensions).length > 0;
        this.tooltip = this.label;
    }
    async run() {
        return this.selectAndInstallExtensions();
    }
    async queryExtensionsToInstall() {
        const local = await this.extensionsWorkbenchService.queryLocal();
        return this.getExtensionsToInstall(local);
    }
    async selectAndInstallExtensions() {
        const quickPick = this.quickInputService.createQuickPick();
        quickPick.busy = true;
        const disposable = quickPick.onDidAccept(() => {
            disposable.dispose();
            quickPick.hide();
            quickPick.dispose();
            this.onDidAccept(quickPick.selectedItems);
        });
        quickPick.show();
        const localExtensionsToInstall = await this.queryExtensionsToInstall();
        quickPick.busy = false;
        if (localExtensionsToInstall.length) {
            quickPick.title = this.getQuickPickTitle();
            quickPick.placeholder = ( localize(6374, "Select extensions to install"));
            quickPick.canSelectMany = true;
            localExtensionsToInstall.sort((e1, e2) => e1.displayName.localeCompare(e2.displayName));
            quickPick.items = ( localExtensionsToInstall.map(
                extension => ({ extension, label: extension.displayName, description: extension.version })
            ));
        }
        else {
            quickPick.hide();
            quickPick.dispose();
            this.notificationService.notify({
                severity: Severity.Info,
                message: ( localize(6375, "There are no extensions to install."))
            });
        }
    }
    async onDidAccept(selectedItems) {
        if (selectedItems.length) {
            const localExtensionsToInstall = ( selectedItems.filter(r => !!r.extension).map(r => r.extension));
            if (localExtensionsToInstall.length) {
                await this.progressService.withProgress({
                    location: ProgressLocation.Notification,
                    title: ( localize(6376, "Installing Extensions..."))
                }, () => this.installExtensions(localExtensionsToInstall));
                this.notificationService.info(( localize(6377, "Successfully installed extensions.")));
            }
        }
    }
};
AbstractInstallExtensionsInServerAction = ( __decorate([
    ( __param(1, IExtensionsWorkbenchService)),
    ( __param(2, IQuickInputService)),
    ( __param(3, INotificationService)),
    ( __param(4, IProgressService))
], AbstractInstallExtensionsInServerAction));
let InstallLocalExtensionsInRemoteAction = class InstallLocalExtensionsInRemoteAction extends AbstractInstallExtensionsInServerAction {
    constructor(extensionsWorkbenchService, quickInputService, progressService, notificationService, extensionManagementServerService, extensionGalleryService, instantiationService, fileService, logService) {
        super('workbench.extensions.actions.installLocalExtensionsInRemote', extensionsWorkbenchService, quickInputService, notificationService, progressService);
        this.extensionManagementServerService = extensionManagementServerService;
        this.extensionGalleryService = extensionGalleryService;
        this.instantiationService = instantiationService;
        this.fileService = fileService;
        this.logService = logService;
    }
    get label() {
        if (this.extensionManagementServerService && this.extensionManagementServerService.remoteExtensionManagementServer) {
            return localize(
                6378,
                "Install Local Extensions in '{0}'...",
                this.extensionManagementServerService.remoteExtensionManagementServer.label
            );
        }
        return '';
    }
    getQuickPickTitle() {
        return localize(
            6379,
            "Install Local Extensions in '{0}'",
            this.extensionManagementServerService.remoteExtensionManagementServer.label
        );
    }
    getExtensionsToInstall(local) {
        return local.filter(extension => {
            const action = this.instantiationService.createInstance(RemoteInstallAction, true);
            action.extension = extension;
            return action.enabled;
        });
    }
    async installExtensions(localExtensionsToInstall) {
        const galleryExtensions = [];
        const vsixs = [];
        const targetPlatform = await this.extensionManagementServerService.remoteExtensionManagementServer.extensionManagementService.getTargetPlatform();
        await Promises.settled(( localExtensionsToInstall.map(async (extension) => {
            if (this.extensionGalleryService.isEnabled()) {
                const gallery = (await this.extensionGalleryService.getExtensions([{ ...extension.identifier, preRelease: !!extension.local?.preRelease }], { targetPlatform, compatible: true }, CancellationToken.None))[0];
                if (gallery) {
                    galleryExtensions.push(gallery);
                    return;
                }
            }
            const vsix = await this.extensionManagementServerService.localExtensionManagementServer.extensionManagementService.zip(extension.local);
            vsixs.push(vsix);
        })));
        await Promises.settled(( galleryExtensions.map(
            gallery => this.extensionManagementServerService.remoteExtensionManagementServer.extensionManagementService.installFromGallery(gallery)
        )));
        try {
            await Promises.settled(( vsixs.map(
                vsix => this.extensionManagementServerService.remoteExtensionManagementServer.extensionManagementService.install(vsix)
            )));
        }
        finally {
            try {
                await Promise.allSettled(( vsixs.map(vsix => this.fileService.del(vsix))));
            }
            catch (error) {
                this.logService.error(error);
            }
        }
    }
};
InstallLocalExtensionsInRemoteAction = ( __decorate([
    ( __param(0, IExtensionsWorkbenchService)),
    ( __param(1, IQuickInputService)),
    ( __param(2, IProgressService)),
    ( __param(3, INotificationService)),
    ( __param(4, IExtensionManagementServerService)),
    ( __param(5, IExtensionGalleryService)),
    ( __param(6, IInstantiationService)),
    ( __param(7, IFileService)),
    ( __param(8, ILogService))
], InstallLocalExtensionsInRemoteAction));
let InstallRemoteExtensionsInLocalAction = class InstallRemoteExtensionsInLocalAction extends AbstractInstallExtensionsInServerAction {
    constructor(id, extensionsWorkbenchService, quickInputService, progressService, notificationService, extensionManagementServerService, extensionGalleryService, fileService, logService) {
        super(id, extensionsWorkbenchService, quickInputService, notificationService, progressService);
        this.extensionManagementServerService = extensionManagementServerService;
        this.extensionGalleryService = extensionGalleryService;
        this.fileService = fileService;
        this.logService = logService;
    }
    get label() {
        return localize(6380, "Install Remote Extensions Locally...");
    }
    getQuickPickTitle() {
        return localize(6381, "Install Remote Extensions Locally");
    }
    getExtensionsToInstall(local) {
        return local.filter(extension => extension.type === ExtensionType.User && extension.server !== this.extensionManagementServerService.localExtensionManagementServer
            && !( this.extensionsWorkbenchService.installed.some(
            e => e.server === this.extensionManagementServerService.localExtensionManagementServer && areSameExtensions(e.identifier, extension.identifier)
        )));
    }
    async installExtensions(extensions) {
        const galleryExtensions = [];
        const vsixs = [];
        const targetPlatform = await this.extensionManagementServerService.localExtensionManagementServer.extensionManagementService.getTargetPlatform();
        await Promises.settled(( extensions.map(async (extension) => {
            if (this.extensionGalleryService.isEnabled()) {
                const gallery = (await this.extensionGalleryService.getExtensions([{ ...extension.identifier, preRelease: !!extension.local?.preRelease }], { targetPlatform, compatible: true }, CancellationToken.None))[0];
                if (gallery) {
                    galleryExtensions.push(gallery);
                    return;
                }
            }
            const vsix = await this.extensionManagementServerService.remoteExtensionManagementServer.extensionManagementService.zip(extension.local);
            vsixs.push(vsix);
        })));
        await Promises.settled(( galleryExtensions.map(
            gallery => this.extensionManagementServerService.localExtensionManagementServer.extensionManagementService.installFromGallery(gallery)
        )));
        try {
            await Promises.settled(( vsixs.map(
                vsix => this.extensionManagementServerService.localExtensionManagementServer.extensionManagementService.install(vsix)
            )));
        }
        finally {
            try {
                await Promise.allSettled(( vsixs.map(vsix => this.fileService.del(vsix))));
            }
            catch (error) {
                this.logService.error(error);
            }
        }
    }
};
InstallRemoteExtensionsInLocalAction = ( __decorate([
    ( __param(1, IExtensionsWorkbenchService)),
    ( __param(2, IQuickInputService)),
    ( __param(3, IProgressService)),
    ( __param(4, INotificationService)),
    ( __param(5, IExtensionManagementServerService)),
    ( __param(6, IExtensionGalleryService)),
    ( __param(7, IFileService)),
    ( __param(8, ILogService))
], InstallRemoteExtensionsInLocalAction));
CommandsRegistry.registerCommand('workbench.extensions.action.showExtensionsForLanguage', function (accessor, fileExtension) {
    const extensionsWorkbenchService = accessor.get(IExtensionsWorkbenchService);
    return extensionsWorkbenchService.openSearch(`ext:${fileExtension.replace(/^\./, '')}`);
});
const showExtensionsWithIdsCommandId = 'workbench.extensions.action.showExtensionsWithIds';
CommandsRegistry.registerCommand(showExtensionsWithIdsCommandId, function (accessor, extensionIds) {
    const extensionsWorkbenchService = accessor.get(IExtensionsWorkbenchService);
    return extensionsWorkbenchService.openSearch(( extensionIds.map(id => `@id:${id}`)).join(' '));
});
registerColor('extensionButton.background', {
    dark: buttonBackground,
    light: buttonBackground,
    hcDark: null,
    hcLight: null
}, ( localize(6382, "Button background color for extension actions.")));
registerColor('extensionButton.foreground', {
    dark: buttonForeground,
    light: buttonForeground,
    hcDark: null,
    hcLight: null
}, ( localize(6383, "Button foreground color for extension actions.")));
registerColor('extensionButton.hoverBackground', {
    dark: buttonHoverBackground,
    light: buttonHoverBackground,
    hcDark: null,
    hcLight: null
}, ( localize(6384, "Button background hover color for extension actions.")));
registerColor('extensionButton.separator', buttonSeparator, ( localize(6385, "Button separator color for extension actions")));
const extensionButtonProminentBackground = registerColor('extensionButton.prominentBackground', {
    dark: buttonBackground,
    light: buttonBackground,
    hcDark: null,
    hcLight: null
}, ( localize(
    6386,
    "Button background color for extension actions that stand out (e.g. install button)."
)));
registerColor('extensionButton.prominentForeground', {
    dark: buttonForeground,
    light: buttonForeground,
    hcDark: null,
    hcLight: null
}, ( localize(
    6387,
    "Button foreground color for extension actions that stand out (e.g. install button)."
)));
registerColor('extensionButton.prominentHoverBackground', {
    dark: buttonHoverBackground,
    light: buttonHoverBackground,
    hcDark: null,
    hcLight: null
}, ( localize(
    6388,
    "Button background hover color for extension actions that stand out (e.g. install button)."
)));
registerThemingParticipant((theme, collector) => {
    const errorColor = theme.getColor(editorErrorForeground);
    if (errorColor) {
        collector.addRule(`.extension-editor .header .actions-status-container > .status ${ThemeIcon.asCSSSelector(errorIcon)} { color: ${errorColor}; }`);
        collector.addRule(`.extension-editor .body .subcontent .runtime-status ${ThemeIcon.asCSSSelector(errorIcon)} { color: ${errorColor}; }`);
        collector.addRule(`.monaco-hover.extension-hover .markdown-hover .hover-contents ${ThemeIcon.asCSSSelector(errorIcon)} { color: ${errorColor}; }`);
    }
    const warningColor = theme.getColor(editorWarningForeground);
    if (warningColor) {
        collector.addRule(`.extension-editor .header .actions-status-container > .status ${ThemeIcon.asCSSSelector(warningIcon)} { color: ${warningColor}; }`);
        collector.addRule(`.extension-editor .body .subcontent .runtime-status ${ThemeIcon.asCSSSelector(warningIcon)} { color: ${warningColor}; }`);
        collector.addRule(`.monaco-hover.extension-hover .markdown-hover .hover-contents ${ThemeIcon.asCSSSelector(warningIcon)} { color: ${warningColor}; }`);
    }
    const infoColor = theme.getColor(editorInfoForeground);
    if (infoColor) {
        collector.addRule(`.extension-editor .header .actions-status-container > .status ${ThemeIcon.asCSSSelector(infoIcon)} { color: ${infoColor}; }`);
        collector.addRule(`.extension-editor .body .subcontent .runtime-status ${ThemeIcon.asCSSSelector(infoIcon)} { color: ${infoColor}; }`);
        collector.addRule(`.monaco-hover.extension-hover .markdown-hover .hover-contents ${ThemeIcon.asCSSSelector(infoIcon)} { color: ${infoColor}; }`);
    }
});

export { AbstractConfigureRecommendedExtensionsAction, AbstractInstallExtensionsInServerAction, ButtonWithDropDownExtensionAction, ButtonWithDropdownExtensionActionViewItem, ClearLanguageAction, ConfigureWorkspaceFolderRecommendedExtensionsAction, ConfigureWorkspaceRecommendedExtensionsAction, DisableDropDownAction, DisableForWorkspaceAction, DisableGloballyAction, DropDownExtensionAction, DropDownExtensionActionViewItem, EnableDropDownAction, EnableForWorkspaceAction, EnableGloballyAction, ExtensionAction, ExtensionEditorManageExtensionAction, ExtensionRuntimeStateAction, ExtensionStatusAction, ExtensionStatusLabelAction, IgnoreExtensionRecommendationAction, InstallAction, InstallAnotherVersionAction, InstallDropdownAction, InstallInOtherServerAction, InstallLocalExtensionsInRemoteAction, InstallRecommendedExtensionAction, InstallRemoteExtensionsInLocalAction, InstallSpecificVersionOfExtensionAction, InstallingLabelAction, LocalInstallAction, ManageExtensionAction, MenuItemExtensionAction, MigrateDeprecatedExtensionAction, PromptExtensionInstallFailureAction, RemoteInstallAction, SetColorThemeAction, SetFileIconThemeAction, SetLanguageAction, SetProductIconThemeAction, ShowRecommendedExtensionAction, ToggleAutoUpdateForExtensionAction, ToggleAutoUpdatesForPublisherAction, TogglePreReleaseExtensionAction, ToggleSyncExtensionAction, UndoIgnoreExtensionRecommendationAction, UninstallAction, UpdateAction, WebInstallAction, extensionButtonProminentBackground, getContextMenuActions, showExtensionsWithIdsCommandId };
