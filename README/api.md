## Api

Здесь находятся 4 директории. 
Они очень плотно связаны между собой, потому что хэндлеры отправляют загруженные данными
шаблоны из папки `templates`, а в свою очередь к шаблонам подключены стили сгенерированные
`tailwindcss` из папки `static`


Пройдемся по порядку каждой из них:

### handlers/

#### `handlers.go`
Этот модуль определяет структуру `Handler` хранящую две переменные:
`svc` - структура сервисов нашего приложения
`db` - это интерфейс базы данных для взаимодействия с ней

Дальше функция создания новой инстанции этой структуры
`func NewHandler` возвращающая новый `Handler`


#### `health.go`
Это так называемый healthcheck приложения, функция
`HealthCheckHandler` обрабатывает запрос типа healthcheck, возвращая код 200, который
означает что приложение работает


#### `routes.go`
pass

#### `auth.go`
Это модуль отвечающий за аутентификацию пользователей, их логин и регистрацию и 
JWT токены

`func (h *Handler) Register` это функция отвечает за регистрацию пользователя, она 
расшифровывает из запроса логин и пароль пользователя, шифрует пароль с помощью `bcrypt`
и создает пользователя в базе данных. Дальше она перенаправляет пользоваетеля на страницу 
логина

`func (h *Handler) Login` эта функция занимается логикой логина пользователя, она расшифровывает из
запроса логин и пароль пользователя, дальше функция `Authenticate` - проверяет есть ли в базе данных такой
пользователь и если есть проверяет его пароль и пароль из запроса на сходство (естественно зашифрованные),
а потом создается `JWT токен` пользователя через функцию `CreateJWT` - которая просто создает токен, который и возвращает его.
Дальше функция `Login` устанавливает сессионные куки на jwt токен и перенаправляет пользователя на главную страницу


#### `c_analyze.go`
Это модуль отвечающий за запросы приходящие на бэкенд связаные с анализом языка C

В начале определяются две структуры:

`CAnalyzeRequest` - структура отвечающая за запрос, здесь находится одно поле `CCode`
`CData` - структура отвечающая за возвращаемые данные, среди них:
`Result` `Metrics` `Recommendations` `LLMAnswer`.

Дальше идут функции, первая из которых - `CAnalyzeData`, которая:
1. Расшифровивает запрос, проверяя при этом не прислан ли пустой код
2. Запускает контейнер вместе с метриками
3. Генерирует Реккомендации
4. Парсит ответ из контейнера и реккомендации
5. Отправляет запрос в нейросеть, для генерации дополнительных рекомендаций
6. Возвращает структуру ответа


`AnalyzeHandlerTemplateC` - это уже функция отвечающая за обработку вставку данных в шаблон и высылание этого шаблона.
В параметрах контекст `echo`, нужный для работы с REST API

Первое что делает функция это расшифровка данных уже из запроса к API,
потом идет вызов предыдущей функции, для получения данных анализа
и на конец все данные вставляются в шаблон `c_analytics.html` (движок шаблонов в go позволяет не писать .html) и шаблон рендерится,
то есть отправляется клиенту

Дальше идет секция статического анализа кода, так называемые линтеры

По аналогии с динамическим анализом идет определение структуры
`CLintRequest`, отвечающую за запрос, хранят одно текстовое поле соответственно код в C и статический анализ

Дальше идет функция `CLintHandler`, которая берет код из запроса, запускает функцию по статическому анализу:
`LintCInContainer` и возвращает данные из этого контейнера обернутые в html

#### `python_analyze.go`
Это файл/модуль отвечающий за обработку запросов связаных с анализом python

В начале определяются две структуры:

`PythonAnalyzeRequest` - структура отвечающая за запрос, здесь находится одно поле `PythonCode`
`PythonData` - структура отвечающая за возвращаемые данные, среди них:
`Result` `Metrics` `Recommendations` `LLMAnswer`.

Дальше идут функции, первая из которых - `PythonAnalyzeData`, которая:
1. Расшифровивает запрос, проверяя при этом не прислан ли пустой код
2. Запускает контейнер вместе с метриками
3. Генерирует Реккомендации
4. Парсит ответ из контейнера и реккомендации
5. Отправляет запрос в нейросеть, для генерации дополнительных рекомендаций
6. Возвращает структуру ответа


`AnalyzeHandlerTemplatePython` - это уже функция отвечающая за обработку вставку данных в шаблон и высылание этого шаблона.
В параметрах контекст `echo`, нужный для работы с REST API

Первое что делает функция это расшифровка данных уже из запроса к API,
потом идет вызов предыдущей функции, для получения данных анализа
и на конец все данные вставляются в шаблон `python_analytics.html` (движок шаблонов в go позволяет не писать .html) и шаблон рендерится,
то есть отправляется клиенту

Дальше идет секция статического анализа кода, так называемые линтеры

По аналогии с динамическим анализом идет определение структуры
`PythonLintRequest`, отвечающую за запрос, хранят одно текстовое поле соответственно код в C и статический анализ

Дальше идет функция `PythonLintHandler`, которая берет код из запроса, запускает функцию по статическому анализу:
`LintPythonInContainer` и возвращает данные из этого контейнера обернутые в html


#### `sql_analyze.go`
Это файл/модуль отвечающий за обработку запросов связаных с анализом sql

В начале определяются две структуры:

`AnalyzeRequest` - структура отвечающая за запрос, здесь находится два поля: `SQLQuery` - запрос в sql, `InitSQL` - база данных
`Data` - структура отвечающая за возвращаемые данные, среди них:
`Result` `Metrics` `Analytics` `Recommendations` `LLMAnswer`.

Дальше идут функции, первая из которых - `AnalyzeData`, которая:
1. Расшифровивает запрос, проверяя при этом не прислан ли пустой код
2. Запускает контейнер вместе с метриками
3. Генерирует Рекомендации
4. Парсит ответ из контейнера и реккомендации
5. Отправляет запрос в нейросеть, для генерации дополнительных рекомендаций
6. Возвращает структуру ответа


`AnalyzeHandlerTemplate` - это уже функция отвечающая за обработку вставку данных в шаблон и высылание этого шаблона.
В параметрах контекст `echo`, нужный для работы с REST API

Первое что делает функция это расшифровка данных уже из запроса к API,
потом идет вызов предыдущей функции, для получения данных анализа
и на конец все данные вставляются в шаблон `sql_analytics.html` (движок шаблонов в go позволяет не писать .html) и шаблон рендерится,
то есть отправляется клиенту

#### `llm.go`
Этот модуль отвечает за генерацию запросов к искусственному интелекту, 
основное это генерация промптов на анализ конкретного кода.

В модуле находятся 3 функции: `GeneratePrompt`, `GeneratePromptPython` и `GeneratePromptC`
Работают они по схожей логике, вставляют данные из параметров в подготовленный текст,
и возвращают этот текст. Текст-Промпт задает задачу ИИ проанализировать код и его метрики

### `/static`
Здесь находятся статические файлы, а именно `css` файлы

#### `input.css`
В этом файле находятся станадртные правила для `tailwincss`, нужные для того
чтобы из этого файла и этих правил `tailwindcss` сгенерировал файл `css` который
уже можно использовать в модулях

#### `styles.css`
Это выходной файл `tailwindcss`, и в нем описывается обычные стили `css`, которые используются
в шаблонах из папки `api/handlers/templates`. Этот файл генерируется автоматически

### `/templates`
Эта папка отвечает за шаблоны и логику работы с ними

#### `templates.go`
Этот модуль определяет функии упрощающие работу с шаблонами, самое важное здесь это функция
`Render`, оперирующая на структуре `Template` - она позволяет использовать контекст фреймворка `Echo`
как простое `context.Render(шаблон, данные в шаблоне)`
Нужно это для упрощения работы с шаблонами и по сути это добавление функциональности к фреймворку `Echo`


#### `template_routes.go`
Это модуль определяющий функцию для регистрации путей в API для шаблонов

`RegisterTemplatesRoutes` - функция где создается соотношение путь - рендер шаблона,
Так же здесь происходит регистрация путей шаблонов Login и Register и групируются шаблоны
анализа кода в одну группу `/api`, которая защищена проверкой логина и пароля

#### `login_partial.html` и `register_partial.html`
Это файлы содержащие часть html для логина и регистрации соответственно,
из непонятного на первый взгляд здесь это параметры в тегах html, начинающиеся с hx,
Это параметры для работы `htmx`, работают они так, что например мы указываем путь и запрос через
`hx-post="/login"` - это говорит нам что при взаимодействии с этим элементом мы будем выполеять запрос
типа POST на путь `/login`, дальше идет `hx-target="body"` где мы указываем какой элемент дерева html будет
заменен на полученый ответ. `hx-swap="outerHTML` говорит нам что полученный ответ заменяет весь элемент, а не только то
что находится внутри него. Ну и `hx-ext="json-enc"` определяет использование расширения htmx, под названием `json-enc`,
оно импортируется на ряду с самим `htmx`, но здесь его нет, потому что в моменте когда эта часть html вставляется в другой,
это расширение уже импортировано (в index/base.html) и это расширение нужно для того чтобы запросы отправляемые этим тегом
содержали `body` с `json` частью содержащую данные, вместо отправки данных в параметрах запроса

#### `base.html`
Этот файл это первое что видит пользователь при заходе в приложение. Это главный файл, в котором изменяются только части
до момента логина или регистрации.
В `head` файла можно увидеть импорты `htmx`, `json-enc` и `monaco`. 
`Monaco` - это оупенсорс онлайн редактор кода, который можно встроить в свои веб-страницы или веб-приложения, и здесь он
используется чисто в декорационных целях и для удобства написания кода

Дальше определение тела страницы, а самое важное это кнопок перехода на логин и регистрацию

#### `index.html`
После логина пользователь получает именно эту страницу, здесь определяются кнопки перехода на страницы анализа
конкретного кода: `sql`, `c`, `python`

#### `/c`, `/python`, `/sql`
Структура этих папок схожа и файлов в этих папках тоже.
Разберем на примере `/python`

- `python.html`
Этот файл - входная страница для анализа кода python
Здесь идет определение формы для вписание кода python, которая через script в низу файла заменяется
на текстовую область `monaco` editor. В эту форму по умолчанию вписывается работающий код python, чтобы не
оставлять эту форму пустой. Дальше идет определение двух кнопок. Первая это отправка запроса на динамический анализ
кода, а вторая это запрос на статический анализ кода. 

Ну и в конце файла идет определения области в которой будет находится ответ статического анализа

Дальше идет `python_analytics.html`, файл где просто структурировано выписываются все ответы динамического анализа,
каждый в своей секции.

А в конце кнопка возврата к анализу кода


